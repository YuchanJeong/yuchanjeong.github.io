[{"content":" 실제 적용 시 더 편리하게 바뀐 부분들 반영 안됨 변경 예정!!! rem to vw #현재 B2B의 스타일은 rtv(rem-to-vw)라는 특이한 단위 시스템을 사용하고 있다. rtv란 rem 단위를 vw 단위로 치환해서 디자인 형태을 유지하는 방식이다.\nB2B 프로젝트를 처음 시작했을 때 파트너사가 사용하는 특정 테블릿에 맞춰서 디자인 작업이 진행되었는데, 뷰포트가 아니라 해상도에 맞춰서 작업이 진행되었기 때문에 디자인된 형태가 실제 구현 시 유지되지 않았다. 하지만 디자인 작업을 다시 하기에는 디자이너가 너무 바빴고 마감 기간도 얼마 남지 않았었다.\n그래서 나온 아이디어가 해상도에 맞게 디자인된 작업물을 뷰포트에 맞게 비율대로 줄이는 것이고 이 아이디어를 구현한 것이 rtv이다.\n1,000 / 디자인 사이즈 * 1vw\n@function rtv($size) { @return calc(calc((1000 / design-size) * $size) * 1vw); } /* 1000이라는 숫자는 디자인은 px, 개발은 rem 단위를 사용하고 있고, 현재 프로젝트에서 1rem === 10px이기 때문에 나온 숫자이다. */ 하지만 웹사이트에서 확인할 경우 모니터 사이즈에 따라 너무 확대되는 문제가 있었다. 그래서 브래이크 포인트를 정해서 해당 포인트부터는 고정된 rem 단위를 사용할 수 있게 만들었다.\nbreak-point / 디자인 사이즈 * 1rem 추가로 모바일 혹은 테블릿 각각에서만 필요한 화면도 구현하기 위해서 테마 시스템을 도입했다.\nuseSetTheme.tsx export type MediaTheme = \u0026#34;mobile\u0026#34; | \u0026#34;tablet\u0026#34; | \u0026#34;mobile-to-tablet\u0026#34;; export const useSetTheme = (theme: MediaTheme) =\u0026gt; { useEffect(() =\u0026gt; { const prevTheme = document.documentElement.getAttribute(\u0026#34;data-theme-media\u0026#34;) ?? \u0026#34;\u0026#34;; document.documentElement.setAttribute(\u0026#34;data-theme-media\u0026#34;, theme); return () =\u0026gt; { document.documentElement.setAttribute(\u0026#34;data-theme-media\u0026#34;, prevTheme); }; }, [theme]); }; styles/_media.scss /* breakpoint */ /* design-mobile: 390px; /design-tablet: 1024px; */ $qs-breakpoint-minimum: 320px; $qs-breakpoint-tablet: 600px; $qs-breakpoint-desktop: 1024px; /* theme */ @mixin qs-theme-mobile { --qs-rtv: clamp(0.8205rem, 2.564vw, 1.5384rem); /* font-size */ --qs-fs-1: calc(var(--qs-rtv) * 1.4); --qs-fs-2: calc(var(--qs-rtv) * 1.6); --qs-fs-3: calc(var(--qs-rtv) * 1.8); --qs-fs-4: calc(var(--qs-rtv) * 2); --qs-fs-5: calc(var(--qs-rtv) * 2.4); /* gap */ --qs-gap-1: calc(var(--qs-rtv) * 0.5); --qs-gap-2: calc(var(--qs-rtv) * 1); --qs-gap-3: calc(var(--qs-rtv) * 1.5); --qs-gap-4: calc(var(--qs-rtv) * 2); --qs-gap-5: calc(var(--qs-rtv) * 3); --qs-gap-6: calc(var(--qs-rtv) * 4); --qs-gap-inner-padding: var(--qs-gap-4); /* border-radius */ --qs-radius-s: calc(var(--qs-rtv) * 0.6); --qs-radius-m: calc(var(--qs-rtv) * 1.2); --qs-radius-l: calc(var(--qs-rtv) * 2.4); /* border-width */ --qs-border-s: calc(var(--qs-rtv) * 0.1); --qs-border-m: calc(var(--qs-rtv) * 0.2); --qs-border-l: calc(var(--qs-rtv) * 0.3); /* height */ --qs-height-header: calc(var(--qs-rtv) * 8); --qs-height-navigator: calc(var(--qs-rtv) * 8); --qs-height-btn-sub: calc(var(--qs-rtv) * 3.2); --qs-height-btn-main: calc(var(--qs-rtv) * 4.8); } @mixin qs-theme-tablet { --qs-rtv: clamp(0.5859rem, 0.9765vw, 1rem); /* font-size */ --qs-fs-1: calc(var(--qs-rtv) * 1.6); --qs-fs-2: calc(var(--qs-rtv) * 2); --qs-fs-3: calc(var(--qs-rtv) * 2.4); --qs-fs-4: calc(var(--qs-rtv) * 2.6); --qs-fs-5: calc(var(--qs-rtv) * 3.2); /* gap */ --qs-gap-1: calc(var(--qs-rtv) * 0.6); --qs-gap-2: calc(var(--qs-rtv) * 1.2); --qs-gap-3: calc(var(--qs-rtv) * 1.8); --qs-gap-4: calc(var(--qs-rtv) * 2.4); --qs-gap-5: calc(var(--qs-rtv) * 3.6); --qs-gap-6: calc(var(--qs-rtv) * 4.8); --qs-gap-inner-padding: var(--qs-gap-6); /* border-radius */ --qs-radius-s: calc(var(--qs-rtv) * 1); --qs-radius-m: calc(var(--qs-rtv) * 2); --qs-radius-l: calc(var(--qs-rtv) * 2.8); /* border-width */ --qs-border-s: calc(var(--qs-rtv) * 0.15); --qs-border-m: calc(var(--qs-rtv) * 0.25); --qs-border-l: calc(var(--qs-rtv) * 0.3); /* height */ --qs-height-header: calc(var(--qs-rtv) * 10); --qs-height-navigator: calc(var(--qs-rtv) * 10); --qs-height-btn-sub: calc(var(--qs-rtv) * 5); --qs-height-btn-main: calc(var(--qs-rtv) * 7); } html { --qs-line-height: 1.26; } html[data-theme-media=\u0026#34;mobile\u0026#34;] { --qs-min: 320px; --qs-max: 600px; @include qs-theme-mobile; } html[data-theme-media=\u0026#34;tablet\u0026#34;] { --qs-min: 600px; --qs-max: 1024px; @include qs-theme-tablet; } html[data-theme-media=\u0026#34;mobile-to-tablet\u0026#34;], html:not( [data-theme-media=\u0026#34;mobile\u0026#34;], [data-theme-media=\u0026#34;tablet\u0026#34;], [data-theme-media=\u0026#34;mobile-to-tablet\u0026#34;] ) { --qs-min: 320px; --qs-max: 1024px; @include qs-theme-tablet; @media (max-width: calc($qs-breakpoint-tablet - 1px)) { @include qs-theme-mobile; } } /* responsive */ @mixin qs-responsive-mobile { html[data-theme-media=\u0026#34;mobile\u0026#34;] { @content; } html[data-theme-media=\u0026#34;mobile-to-tablet\u0026#34;], html:not( [data-theme-media=\u0026#34;mobile\u0026#34;], [data-theme-media=\u0026#34;tablet\u0026#34;], [data-theme-media=\u0026#34;mobile-to-tablet\u0026#34;] ) { @media (max-width: calc($qs-breakpoint-tablet - 1px)) { @content; } } } /* rem to vw */ @function qs-rtv($size) { @return calc($size * var(--qs-rtv)); } quick style #기존에는 스타일 작업의 중복 코드를 줄이기 위해 믹스인을 많이 사용했었다. 사용 및 수정이 편했으나 자유도가 너무 높고, 프로퍼티 입력 시의 안전성이 떨어지며, 문서화 및 공유가 까다로운 문제가 있었다. 그리고 한두 가지의 스타일 적용 때문에 추가 파일을 만드는 것에 피로도를 느꼈고, 그렇다고 클래스를 활용하기에는 스타일 작업의 일관성이 떨어진다고 느껴서 싫었다.\n추가로 스토리북을 활용해서 컴포넌트의 문서화를 하고 싶었기 때문에 css-in-js의 컨셉을 가져와서 공용 믹스인들을 컴포넌트화해서 사용하는 방식을 사용하기로 했다. 이때 믹스인에 사용된 클래스들을 quickStyle이라는 객체에 넣어서 사용의 편리성을 높이고 오타의 가능성을 없앴다. 그리고 공용 변수들을 :export로 추출하고 타입을 정리해서 안전성 및 유지 보수성을 높였다.\nstyles/_color.module.scss /* color 변경 시 아래의 variables, map, export 그리고 color.ts 수정 필요 */ $qs-color-primary-black: #000000; $qs-color-primary-purple: #6435c7; $qs-color-primary-purple-dark: #351083; $qs-color-primary-lavender: #eeedef; $qs-color-primary-light: #f4eeff; $qs-color-primary-light-2: #d4c0ff; $qs-color-secondary-yellow: #ffa500; $qs-color-secondary-orange: #fd5e02; $qs-color-secondary-red: #ff0000; $qs-color-secondary-light: #fbece4; $qs-color-secondary-light-2: #ffd7c0; $qs-color-gray-medium: #939393; $qs-color-gray-light: #cecece; $qs-color-gray-light-2: #f8f8f8; $qs-color-gray-light-3: #bdbdbd; $qs-color-gray-white: #ffffff; $qs-color-etc-green: #2abd27; $qs-color-etc-green-light: #e2ffe1; $qs-color-etc-green-light-2: #a5eea4; $qs-color-etc-orange: #ff7020; $qs-color-etc-orange-light: #ffe6d8; $qs-color-etc-orange-light-2: #ffc5a5; $qs-color-etc-red: #bb2727; $qs-color-etc-kakao-container: #f3e926; $qs-color-etc-kakao-label: #191919; $qs-color-etc-dawn: #93b0d6; $qs-color-etc-lemon-yellow: #f5f49b; $qs-color-card-1: #e3dbca; $qs-color-card-2: #eae9e7; $qs-color-card-3: #d4d0dc; $qs-color-card-4: #e8dacd; $qs-color-map: ( primary-black: $qs-color-primary-black, primary-purple: $qs-color-primary-purple, primary-purple-dark: $qs-color-primary-purple-dark, primary-lavender: $qs-color-primary-lavender, primary-light: $qs-color-primary-light, primary-light-2: $qs-color-primary-light-2, secondary-yellow: $qs-color-secondary-yellow, secondary-orange: $qs-color-secondary-orange, secondary-red: $qs-color-secondary-red, secondary-light: $qs-color-secondary-light, secondary-light-2: $qs-color-secondary-light-2, gray-medium: $qs-color-gray-medium, gray-light: $qs-color-gray-light, gray-light-2: $qs-color-gray-light-2, gray-light-3: $qs-color-gray-light-3, gray-white: $qs-color-gray-white, etc-green: $qs-color-etc-green, etc-green-light: $qs-color-etc-green-light, etc-green-light-2: $qs-color-etc-green-light-2, etc-orange: $qs-color-etc-orange, etc-orange-light: $qs-color-etc-orange-light, etc-orange-light-2: $qs-color-etc-orange-light-2, etc-red: $qs-color-etc-red, etc-kakao-container: $qs-color-etc-kakao-container, etc-kakao-label: $qs-color-etc-kakao-label, etc-dawn: $qs-color-etc-dawn, etc-lemon-yellow: $qs-color-etc-lemon-yellow, card-1: $qs-color-card-1, card-2: $qs-color-card-2, card-3: $qs-color-card-3, card-4: $qs-color-card-4, ); :export { primary-black: $qs-color-primary-black; primary-purple: $qs-color-primary-purple; primary-purple-dark: $qs-color-primary-purple-dark; primary-lavender: $qs-color-primary-lavender; primary-light: $qs-color-primary-light; primary-light-2: $qs-color-primary-light-2; secondary-yellow: $qs-color-secondary-yellow; secondary-orange: $qs-color-secondary-orange; secondary-red: $qs-color-secondary-red; secondary-light: $qs-color-secondary-light; secondary-light-2: $qs-color-secondary-light-2; gray-medium: $qs-color-gray-medium; gray-light: $qs-color-gray-light; gray-light-2: $qs-color-gray-light-2; gray-light-3: $qs-color-gray-light-3; gray-white: $qs-color-gray-white; etc-green: $qs-color-etc-green; etc-green-light: $qs-color-etc-green-light; etc-green-light-2: $qs-color-etc-green-light-2; etc-orange: $qs-color-etc-orange; etc-orange-light: $qs-color-etc-orange-light; etc-orange-light-2: $qs-color-etc-orange-light-2; etc-red: $qs-color-etc-red; etc-kakao-container: $qs-color-etc-kakao-container; etc-kakao-label: $qs-color-etc-kakao-label; etc-dawn: $qs-color-etc-dawn; etc-lemon-yellow: $qs-color-etc-lemon-yellow; card-1: $qs-color-card-1; card-2: $qs-color-card-2; card-3: $qs-color-card-3; card-4: $qs-color-card-4; } @mixin qs-background-color { @each $key, $value in $qs-color-map { \u0026amp;.qs-background-color-#{$key} { background-color: $value; } } } @mixin qs-border-color { @each $key, $value in $qs-color-map { \u0026amp;.qs-border-color-#{$key} { border-color: $value; } } } @mixin qs-svg-color { @each $key, $value in $qs-color-map { \u0026amp;.qs-svg-color-#{$key} { path { fill: $value; } } } } @mixin qs-font-color { @each $key, $value in $qs-color-map { \u0026amp;.qs-font-color-#{$key} { color: $value; } } } @mixin qs-font-border-color { @each $key, $value in $qs-color-map { \u0026amp;.qs-font-border-color-#{$key} { text-shadow: -1px 0 $value, 0 1px $value, 1px 0 $value, 0 -1px $value; } } } styles/_figure.module.scss /* min \u0026amp; max */ $qs-min: var(--qs-min); $qs-max: var(--qs-max); /* line-height */ $qs-line-height: var(--qs-line-height); /* font */ $qs-fs-1: var(--qs-fs-1); $qs-fs-2: var(--qs-fs-2); $qs-fs-3: var(--qs-fs-3); $qs-fs-4: var(--qs-fs-4); $qs-fs-5: var(--qs-fs-5); $qs-fs-map: ( 1: $qs-fs-1, 2: $qs-fs-2, 3: $qs-fs-3, 4: $qs-fs-4, 5: $qs-fs-5, ); $qs-fw-map: ( light: 300, regular: 400, medium: 500, bold: 700, ); @mixin qs-font-size { @each $key, $value in $qs-fs-map { \u0026amp;.qs-font-size-#{$key} { font-size: $value; } } } @mixin qs-font-weight { @each $key, $value in $qs-fw-map { \u0026amp;.qs-font-weight-#{$key} { font-weight: $value; } } } @mixin qs-svg-size { @each $key, $value in $qs-fs-map { \u0026amp;.qs-svg-size-#{$key} { width: $value; height: $value; \u0026gt; svg { width: $value; height: $value; } } } } /* gap */ $qs-gap-1: var(--qs-gap-1); $qs-gap-2: var(--qs-gap-2); $qs-gap-3: var(--qs-gap-3); $qs-gap-4: var(--qs-gap-4); $qs-gap-5: var(--qs-gap-5); $qs-gap-6: var(--qs-gap-6); $qs-gap-inner-padding: var(--qs-gap-inner-padding); $qs-gap-map: ( 0: 0, 1: $qs-gap-1, 2: $qs-gap-2, 3: $qs-gap-3, 4: $qs-gap-4, 5: $qs-gap-5, 6: $qs-gap-6, inner-padding: $qs-gap-inner-padding, ); @mixin qs-margin { @each $key, $value in $qs-gap-map { \u0026amp;.qs-margin-top-#{$key} { margin-top: $value; } \u0026amp;.qs-margin-right-#{$key} { margin-right: $value; } \u0026amp;.qs-margin-bottom-#{$key} { margin-bottom: $value; } \u0026amp;.qs-margin-left-#{$key} { margin-left: $value; } } } @mixin qs-padding { @each $key, $value in $qs-gap-map { \u0026amp;.qs-padding-top-#{$key} { padding-top: $value; } \u0026amp;.qs-padding-left-#{$key} { padding-left: $value; } \u0026amp;.qs-padding-bottom-#{$key} { padding-bottom: $value; } \u0026amp;.qs-padding-right-#{$key} { padding-right: $value; } } } @mixin qs-gap { @each $key, $value in $qs-gap-map { \u0026amp;.qs-row-gap-#{$key} { row-gap: $value; } \u0026amp;.qs-column-gap-#{$key} { column-gap: $value; } } } /* border */ $qs-radius-s: var(--qs-radius-s); $qs-radius-m: var(--qs-radius-m); $qs-radius-l: var(--qs-radius-l); $qs-border-s: var(--qs-border-s); $qs-border-m: var(--qs-border-m); $qs-border-l: var(--qs-border-l); $qs-radius-map: ( none: 0, s: $qs-radius-s, m: $qs-radius-m, l: $qs-radius-l, ); $qs-border-map: ( none: 0, s: $qs-border-s, m: $qs-border-m, l: $qs-border-l, ); @mixin qs-border-radius { @each $key, $value in $qs-radius-map { \u0026amp;.qs-radius-#{$key} { border-radius: $value; @each $key2, $value2 in $qs-border-map { \u0026amp;.qs-border-#{$key2} { border-radius: calc($value + $value2); } } } } } @mixin qs-border-width { border-style: solid; @each $key, $value in $qs-border-map { \u0026amp;.qs-border-#{$key} { border-width: $value; } } } /* sizing */ $qs-sizing-map: ( auto: auto, fit-content: fit-content, full: 100%, ); $qs-sizing-type-map: ( normal: null, min: \u0026#34;min-\u0026#34;, max: \u0026#34;max-\u0026#34;, ); /* width */ @mixin qs-width { @each $key, $value in $qs-sizing-map { \u0026amp;.qs-normal-width-#{$key} { width: $value; } } @each $key, $value in $qs-gap-map { @each $key2, $value2 in $qs-sizing-type-map { \u0026amp;.qs-#{$key2}-width-gap-#{$key} { #{$value2}width: $value; } } } @for $i from 0 through 100 { @each $key, $value in $qs-sizing-type-map { \u0026amp;.qs-#{$key}-width-#{$i} { #{$value}width: qs-rtv($i); } } @each $key, $value in $qs-sizing-type-map { \u0026amp;.qs-#{$key}-width-#{$i}-percent { #{$value}width: calc($i * 1%); } } } } /* height */ $qs-height-header: var(--qs-height-header); $qs-height-navigator: var(--qs-height-navigator); $qs-height-btn-sub: var(--qs-height-btn-sub); $qs-height-btn-main: var(--qs-height-btn-main); $qs-height-specific-map: ( btn-sub: $qs-height-btn-sub, btn-main: $qs-height-btn-main, ); @mixin qs-height { @each $key, $value in $qs-sizing-map { \u0026amp;.qs-normal-height-#{$key} { height: $value; } } @each $key, $value in $qs-gap-map { @each $key2, $value2 in $qs-sizing-type-map { \u0026amp;.qs-#{$key2}-height-gap-#{$key} { #{$value2}height: $value; } } } @for $i from 0 through 100 { @each $key, $value in $qs-sizing-type-map { \u0026amp;.qs-#{$key}-height-#{$i} { #{$value}height: qs-rtv($i); } } @each $key, $value in $qs-sizing-type-map { \u0026amp;.qs-#{$key}-height-#{$i}-percent { #{$value}height: calc($i * 1%); } } } @each $key, $value in $qs-sizing-type-map { \u0026amp;.qs-#{$key}-height-header { #{$value}height: $qs-height-header; @supports (-webkit-touch-callout: none) { #{$value}height: calc($qs-navigator-height + env(safe-area-inset-top)); } } } @each $key, $value in $qs-sizing-type-map { \u0026amp;.qs-#{$key}-height-navigator { #{$value}height: $qs-height-navigator; @supports (-webkit-touch-callout: none) { #{$value}height: calc( $qs-navigator-height + env(safe-area-inset-bottom) ); } } } @each $key, $value in $qs-gap-map { @each $key2, $value2 in $qs-sizing-type-map { \u0026amp;.qs-#{$key2}-height-#{$key} { #{$value2}height: $value; } } } } /* opacity */ @mixin qs-opacity { @for $i from 1 through 10 { \u0026amp;.qs-opacity-#{$i} { opacity: $i * 0.1; } } } /* backdrop-blur */ @mixin qs-backdrop-blur { @for $i from 0 through 50 { \u0026amp;.qs-backdrop-blur-#{$i} { backdrop-filter: blur(calc($i * 1px)); } } } /* z-index */ @mixin qs-z-index { @for $i from -1 through 10 { \u0026amp;.qs-z-index-#{$i} { z-index: $i; } } } /* aspect-ratio */ @mixin qs-aspect-ratio { \u0026amp;.qs-aspect-ratio-auto { aspect-ratio: auto; } @for $i from 1 through 50 { \u0026amp;.qs-aspect-ratio-#{$i} { aspect-ratio: calc($i * 0.1); } } } @constants/styles/color.ts import _color from \u0026#34;styles/_color.module.scss\u0026#34;; export const COLOR = _color as { \u0026#34;primary-black\u0026#34;: string; \u0026#34;primary-purple\u0026#34;: string; \u0026#34;primary-purple-dark\u0026#34;: string; \u0026#34;primary-lavender\u0026#34;: string; \u0026#34;primary-light\u0026#34;: string; \u0026#34;primary-light-2\u0026#34;: string; \u0026#34;secondary-yellow\u0026#34;: string; \u0026#34;secondary-orange\u0026#34;: string; \u0026#34;secondary-red\u0026#34;: string; \u0026#34;secondary-light\u0026#34;: string; \u0026#34;secondary-light-2\u0026#34;: string; \u0026#34;gray-medium\u0026#34;: string; \u0026#34;gray-light\u0026#34;: string; \u0026#34;gray-light-2\u0026#34;: string; \u0026#34;gray-light-3\u0026#34;: string; \u0026#34;gray-white\u0026#34;: string; \u0026#34;etc-green\u0026#34;: string; \u0026#34;etc-green-light\u0026#34;: string; \u0026#34;etc-green-light-2\u0026#34;: string; \u0026#34;etc-orange\u0026#34;: string; \u0026#34;etc-orange-light\u0026#34;: string; \u0026#34;etc-orange-light-2\u0026#34;: string; \u0026#34;etc-red\u0026#34;: string; \u0026#34;etc-kakao-container\u0026#34;: string; \u0026#34;etc-kakao-label\u0026#34;: string; \u0026#34;etc-dawn\u0026#34;: string; \u0026#34;etc-lemon-yellow\u0026#34;: string; \u0026#34;card-1\u0026#34;: string; \u0026#34;card-2\u0026#34;: string; \u0026#34;card-3\u0026#34;: string; \u0026#34;card-4\u0026#34;: string; }; @constants/styles/types.ts import { COLOR } from \u0026#34;@constants/styles/color\u0026#34;; export type Color = keyof typeof COLOR; export type FontSize = 1 | 2 | 3 | 4 | 5; export type FontWeight = \u0026#34;light\u0026#34; | \u0026#34;regular\u0026#34; | \u0026#34;medium\u0026#34; | \u0026#34;bold\u0026#34;; export type Gap = 0 | 1 | 2 | 3 | 4 | 5 | 6 | \u0026#34;inner-padding\u0026#34;; export type SizingGap = | \u0026#34;gap-0\u0026#34; | \u0026#34;gap-1\u0026#34; | \u0026#34;gap-2\u0026#34; | \u0026#34;gap-3\u0026#34; | \u0026#34;gap-4\u0026#34; | \u0026#34;gap-5\u0026#34; | \u0026#34;gap-6\u0026#34; | \u0026#34;gap-inner-padding\u0026#34;; export type Space = [Gap] | [Gap, Gap] | [Gap, Gap, Gap] | [Gap, Gap, Gap, Gap]; export type Radius = \u0026#34;none\u0026#34; | \u0026#34;s\u0026#34; | \u0026#34;m\u0026#34; | \u0026#34;l\u0026#34;; export type Border = \u0026#34;none\u0026#34; | \u0026#34;s\u0026#34; | \u0026#34;m\u0026#34; | \u0026#34;l\u0026#34;; export type ZeroToHundred = | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 | 91 | 92 | 93 | 94 | 95 | 96 | 97 | 98 | 99 | 100; export type Percent = | \u0026#34;0%\u0026#34; | \u0026#34;1%\u0026#34; | \u0026#34;2%\u0026#34; | \u0026#34;3%\u0026#34; | \u0026#34;4%\u0026#34; | \u0026#34;5%\u0026#34; | \u0026#34;6%\u0026#34; | \u0026#34;7%\u0026#34; | \u0026#34;8%\u0026#34; | \u0026#34;9%\u0026#34; | \u0026#34;10%\u0026#34; | \u0026#34;11%\u0026#34; | \u0026#34;12%\u0026#34; | \u0026#34;13%\u0026#34; | \u0026#34;14%\u0026#34; | \u0026#34;15%\u0026#34; | \u0026#34;16%\u0026#34; | \u0026#34;17%\u0026#34; | \u0026#34;18%\u0026#34; | \u0026#34;19%\u0026#34; | \u0026#34;20%\u0026#34; | \u0026#34;21%\u0026#34; | \u0026#34;22%\u0026#34; | \u0026#34;23%\u0026#34; | \u0026#34;24%\u0026#34; | \u0026#34;25%\u0026#34; | \u0026#34;26%\u0026#34; | \u0026#34;27%\u0026#34; | \u0026#34;28%\u0026#34; | \u0026#34;29%\u0026#34; | \u0026#34;30%\u0026#34; | \u0026#34;31%\u0026#34; | \u0026#34;32%\u0026#34; | \u0026#34;33%\u0026#34; | \u0026#34;34%\u0026#34; | \u0026#34;35%\u0026#34; | \u0026#34;36%\u0026#34; | \u0026#34;37%\u0026#34; | \u0026#34;38%\u0026#34; | \u0026#34;39%\u0026#34; | \u0026#34;40%\u0026#34; | \u0026#34;41%\u0026#34; | \u0026#34;42%\u0026#34; | \u0026#34;43%\u0026#34; | \u0026#34;44%\u0026#34; | \u0026#34;45%\u0026#34; | \u0026#34;46%\u0026#34; | \u0026#34;47%\u0026#34; | \u0026#34;48%\u0026#34; | \u0026#34;49%\u0026#34; | \u0026#34;50%\u0026#34; | \u0026#34;51%\u0026#34; | \u0026#34;52%\u0026#34; | \u0026#34;53%\u0026#34; | \u0026#34;54%\u0026#34; | \u0026#34;55%\u0026#34; | \u0026#34;56%\u0026#34; | \u0026#34;57%\u0026#34; | \u0026#34;58%\u0026#34; | \u0026#34;59%\u0026#34; | \u0026#34;60%\u0026#34; | \u0026#34;61%\u0026#34; | \u0026#34;62%\u0026#34; | \u0026#34;63%\u0026#34; | \u0026#34;64%\u0026#34; | \u0026#34;65%\u0026#34; | \u0026#34;66%\u0026#34; | \u0026#34;67%\u0026#34; | \u0026#34;68%\u0026#34; | \u0026#34;69%\u0026#34; | \u0026#34;70%\u0026#34; | \u0026#34;71%\u0026#34; | \u0026#34;72%\u0026#34; | \u0026#34;73%\u0026#34; | \u0026#34;74%\u0026#34; | \u0026#34;75%\u0026#34; | \u0026#34;76%\u0026#34; | \u0026#34;77%\u0026#34; | \u0026#34;78%\u0026#34; | \u0026#34;79%\u0026#34; | \u0026#34;80%\u0026#34; | \u0026#34;81%\u0026#34; | \u0026#34;82%\u0026#34; | \u0026#34;83%\u0026#34; | \u0026#34;84%\u0026#34; | \u0026#34;85%\u0026#34; | \u0026#34;86%\u0026#34; | \u0026#34;87%\u0026#34; | \u0026#34;88%\u0026#34; | \u0026#34;89%\u0026#34; | \u0026#34;90%\u0026#34; | \u0026#34;91%\u0026#34; | \u0026#34;92%\u0026#34; | \u0026#34;93%\u0026#34; | \u0026#34;94%\u0026#34; | \u0026#34;95%\u0026#34; | \u0026#34;96%\u0026#34; | \u0026#34;97%\u0026#34; | \u0026#34;98%\u0026#34; | \u0026#34;99%\u0026#34; | \u0026#34;100%\u0026#34;; export type Sizing = \u0026#34;auto\u0026#34; | \u0026#34;fit-content\u0026#34; | \u0026#34;full\u0026#34;; export type Width = Sizing | SizingGap | ZeroToHundred | Percent; export type SpecificHeight = \u0026#34;header\u0026#34; | \u0026#34;navigator\u0026#34; | \u0026#34;btn-sub\u0026#34; | \u0026#34;btn-main\u0026#34;; export type Height = | Sizing | SizingGap | ZeroToHundred | Percent | SpecificHeight; export type OpacityMultiplyTen = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10; export type BackdropBlurPx = | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50; export type ZIndex = -1 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10; export type AspectRatioMultiplyTen = | \u0026#34;auto\u0026#34; | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50; @constants/styles/quickStyle.ts import { AspectRatioMultiplyTen, BackdropBlurPx, Border, Color, FontSize, FontWeight, Gap, Height, OpacityMultiplyTen, Radius, Sizing, Space, Width, ZIndex, } from \u0026#34;@constants/styles/types\u0026#34;; const transformWidthPercent = (width: Width) =\u0026gt; { if (typeof width !== \u0026#34;string\u0026#34;) return width; return width.replaceAll(\u0026#34;%\u0026#34;, \u0026#34;-percent\u0026#34;); }; const transformHeightPercent = (height: Height) =\u0026gt; { if (typeof height !== \u0026#34;string\u0026#34;) return height; return height.replaceAll(\u0026#34;%\u0026#34;, \u0026#34;-percent\u0026#34;); }; export const quickStyle = { /* color */ backgroundColor: (color: Color) =\u0026gt; `qs-background-color-${color}`, borderColor: (color: Color) =\u0026gt; `qs-border-color-${color}`, /* font */ fontSize: (fontSize: FontSize) =\u0026gt; `qs-font-size-${fontSize}`, fontWeight: (FontWeight: FontWeight) =\u0026gt; `qs-font-weight-${FontWeight}`, fontColor: (color: Color) =\u0026gt; `qs-font-color-${color}`, fontBorderColor: (color: Color) =\u0026gt; `qs-font-border-color-${color}`, /* svg */ svgSize: (svgSize: FontSize) =\u0026gt; `qs-svg-size-${svgSize}`, svgColor: (color: Color) =\u0026gt; `qs-svg-color-${color}`, /* gap */ margin: (space: Space) =\u0026gt; { if (space.length === 1) return `qs-margin-top-${space[0]} qs-margin-right-${space[0]} qs-margin-bottom-${space[0]} qs-margin-left-${space[0]}`; if (space.length === 2) return `qs-margin-top-${space[0]} qs-margin-right-${space[1]} qs-margin-bottom-${space[0]} qs-margin-left-${space[1]}`; if (space.length === 3) return `qs-margin-top-${space[0]} qs-margin-right-${space[1]} qs-margin-bottom-${space[2]} qs-margin-left-${space[1]}`; if (space.length === 4) return `qs-margin-top-${space[0]} qs-margin-right-${space[1]} qs-margin-bottom-${space[2]} qs-margin-left-${space[3]}`; }, padding: (space: Space) =\u0026gt; { if (space.length === 1) return `qs-padding-top-${space[0]} qs-padding-right-${space[0]} qs-padding-bottom-${space[0]} qs-padding-left-${space[0]}`; if (space.length === 2) return `qs-padding-top-${space[0]} qs-padding-right-${space[1]} qs-padding-bottom-${space[0]} qs-padding-left-${space[1]}`; if (space.length === 3) return `qs-padding-top-${space[0]} qs-padding-right-${space[1]} qs-padding-bottom-${space[2]} qs-padding-left-${space[1]}`; if (space.length === 4) return `qs-padding-top-${space[0]} qs-padding-right-${space[1]} qs-padding-bottom-${space[2]} qs-padding-left-${space[3]}`; }, gap: (gap: [Gap] | [Gap, Gap]) =\u0026gt; { if (gap.length === 1) return `qs-row-gap-${gap[0]} qs-column-gap-${gap[0]}`; if (gap.length === 2) return `qs-row-gap-${gap[0]} qs-column-gap-${gap[1]}`; }, /* border */ borderRadius: (radius: Radius) =\u0026gt; `qs-radius-${radius}`, borderWidth: (border: Border) =\u0026gt; `qs-border-${border}`, /* width */ width: (width: Width) =\u0026gt; `qs-normal-width-${transformWidthPercent(width)}`, minWidth: (width: Exclude\u0026lt;Width, Sizing\u0026gt;) =\u0026gt; `qs-min-width-${transformWidthPercent(width)}`, maxWidth: (width: Exclude\u0026lt;Width, Sizing\u0026gt;) =\u0026gt; `qs-max-width-${transformWidthPercent(width)}`, /* height */ height: (height: Height) =\u0026gt; `qs-normal-height-${transformHeightPercent(height)}`, minHeight: (height: Exclude\u0026lt;Height, Sizing\u0026gt;) =\u0026gt; `qs-min-height-${transformHeightPercent(height)}`, maxHeight: (height: Exclude\u0026lt;Height, Sizing\u0026gt;) =\u0026gt; `qs-max-height-${transformHeightPercent(height)}`, /* opacity */ opacity: (opacity: OpacityMultiplyTen) =\u0026gt; `qs-opacity-${opacity}`, /* backdrop-blur */ backdropBlur: (px: BackdropBlurPx) =\u0026gt; `qs-backdrop-blur-${px}`, /* z-index */ zIndex: (index: ZIndex) =\u0026gt; `qs-z-index-${index}`, /* aspect-ratio */ aspectRatio: (ratio: AspectRatioMultiplyTen) =\u0026gt; `qs-aspect-ratio-${ratio}`, } as const; next.config.js const nextConfig = { ..., sassOptions: { includePaths: [path.join(__dirname, \u0026#34;styles\u0026#34;)], }, }; 폰트 최적화 # pages/_app.tsx import localFont from \u0026#34;next/font/local\u0026#34;; import type { AppProps } from \u0026#34;next/app\u0026#34;; const fontSpoqaHanSansNeo = localFont({ src: [ { path: \u0026#34;../public/fonts/SpoqaHanSansNeo-Thin.woff\u0026#34;, weight: \u0026#34;100\u0026#34;, style: \u0026#34;normal\u0026#34;, }, { path: \u0026#34;../public/fonts/SpoqaHanSansNeo-Light.woff\u0026#34;, weight: \u0026#34;300\u0026#34;, style: \u0026#34;normal\u0026#34;, }, { path: \u0026#34;../public/fonts/SpoqaHanSansNeo-Regular.woff\u0026#34;, weight: \u0026#34;400\u0026#34;, style: \u0026#34;normal\u0026#34;, }, { path: \u0026#34;../public/fonts/SpoqaHanSansNeo-Medium.woff\u0026#34;, weight: \u0026#34;500\u0026#34;, style: \u0026#34;normal\u0026#34;, }, { path: \u0026#34;../public/fonts/SpoqaHanSansNeo-Bold.woff\u0026#34;, weight: \u0026#34;700\u0026#34;, style: \u0026#34;normal\u0026#34;, }, ], }); function MyApp({ Component, pageProps }: AppProps) { return ( \u0026lt;main className={fontSpoqaHanSansNeo.className}\u0026gt; \u0026lt;style jsx global\u0026gt;{` :root { --font-SpoqaHanSansNeo: ${fontSpoqaHanSansNeo.style.fontFamily}; } `}\u0026lt;/style\u0026gt; \u0026lt;Component {...pageProps} /\u0026gt; \u0026lt;/main\u0026gt; ); } export default MyApp; *ref. https://nextjs.org/docs/pages/building-your-application/optimizing/fonts\n스타일 초기화 # styles/_reset.scss * { margin: 0; padding: 0; color: inherit; font: inherit; } *, :after, :before { flex-shrink: 0; box-sizing: border-box; } :root { line-height: 1.5; /* 글이 상자 벗어나는 거 방지 */ overflow-wrap: break-word; -moz-tab-size: 4; tab-size: 4; cursor: default; -webkit-user-select: none; -ms-user-select: none; user-select: none; /* 모바일에서 꾹 클릭 시 색상 변경 방지 */ -webkit-tap-highlight-color: transparent; /* 내용 선택 방지 */ -webkit-touch-callout: none; /* 모바일에서 폰트 크기 조정 방지 */ -webkit-text-size-adjust: none; -moz-text-size-adjust: none; text-size-adjust: none; /* 폰트 랜더링 부드럽게 만들기 */ -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; } html, body { height: 100%; /* 최상위 부모 요소 기본 크기 설정 */ font-weight: 400; font-size: 62.5%; /* 1rem === 10px */ font-style: normal; } img { -webkit-user-drag: none; } img, picture, video, canvas, svg { /* 위치값을 가지고 상자 벗어나는거 방지 */ display: block; max-width: 100%; } /* Chrome 자동 완성 배경색 지우기 */ input:-webkit-autofill { box-shadow: 0 0 0 30px transparent inset; } input:-webkit-autofill, input:-webkit-autofill:hover, input:-webkit-autofill:focus, input:-webkit-autofill:active { transition: background-color 5000s ease-in-out 0s; } /* 선택 및 입력 스타일 초기화 */ button, input, select, progress { background-color: transparent; border: 0; -webkit-appearance: none; appearance: none; \u0026amp;:focus, \u0026amp;:active { outline: none; box-shadow: none; } } meter { border: 0; } textarea { \u0026amp;:focus, \u0026amp;:active { outline: none; box-shadow: none; } } /* 입력 대상 커서 텍스트로 변경 */ input, textarea { cursor: text; } /* 선택 대상 커서 포인터로 변경 */ a, button, select, input[type=\u0026#34;checkbox\u0026#34;], input[type=\u0026#34;radio\u0026#34;], input[type=\u0026#34;range\u0026#34;], label { cursor: pointer; } /* 링크 스타일 초기화 */ a { text-decoration: none; } /* 표 스타일 초기와 */ table { border-collapse: collapse; border-spacing: 0; } /* 목록 스타일 초기화 */ ul, ol { padding-left: 0; list-style: none; } ","date":"10 May 2023","permalink":"/posts/work/7/","section":"Posts","summary":"실제 적용 시 더 편리하게 바뀐 부분들 반영 안됨 변경 예정!","title":"[B2B/리팩토링] 스타일"},{"content":"","date":null,"permalink":"/categories/%5Cwork/","section":"Categories","summary":"","title":"\\work"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/tags/convention/","section":"Tags","summary":"","title":"convention"},{"content":"","date":null,"permalink":"/tags/eslint/","section":"Tags","summary":"","title":"eslint"},{"content":"","date":null,"permalink":"/tags/husky/","section":"Tags","summary":"","title":"husky"},{"content":"","date":null,"permalink":"/tags/i18n/","section":"Tags","summary":"","title":"i18n"},{"content":"","date":null,"permalink":"/tags/lint-staged/","section":"Tags","summary":"","title":"lint-staged"},{"content":"","date":null,"permalink":"/tags/next.js/","section":"Tags","summary":"","title":"Next.js"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/tags/prettier/","section":"Tags","summary":"","title":"prettier"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":null,"permalink":"/tags/typescript/","section":"Tags","summary":"","title":"TypeScript"},{"content":" A blog from a developer who loves \u0026ldquo;Why?\u0026rdquo; :) Previous posts are in this repository. 😊 About me #\rName Yuchan Jeong Work WithBecon(FE Developer) Languages Korean(Native), English(Intermediate) 👇 Follow me on # Mobile Number +82 10 8295 2674 E-mail yuchanjeong0923@gmail.com Blog https://yuchanjeong.github.io Github /yuchanjeong ","date":null,"permalink":"/","section":"Yuchan's hello world!","summary":"A blog from a developer who loves \u0026ldquo;Why?","title":"Yuchan's hello world!"},{"content":"개요 #BE가 기존의 Express 및 TypeORM로 구성된 서버를 Nest.js 및 TypeGraphQL로 처음부터 다시 만들 예정이라서, FE도 대규모 리팩토링을 진행하기로 했다. (각종 프로퍼티 및 로직이 많이 바뀔 예정이기 때문)\n라우팅 및 스플리팅의 편의성을 주 이유로 Next.js를 사용할 것이다. (추후 SSG나 SSR이 필요해졌을 때 쉽게 적용이 가능하다는 이유도 있음)\n기존의 컨벤션 및 폴더 구조에서 느낀 불편함을 최대한 개선해서 유지 보수성 및 협업의 용의성에 중점을 두고 리팩토링을 진행할 것이다.\n이 게시물은 미래의 나를 위한 작업 과정의 요약본으로 설명이 많이 생략된 불친절한 글이다. 프로젝트 시작 #1. CNA #npx create-next-app --typescript [project] --use-yarn 2. eslint \u0026amp; prettier 설치 #yarn add -D eslint prettier eslint-config-prettier eslint-plugin-import @typescript-eslint/parser eslint-import-resolver-typescript prettier-plugin-style-order npx eslint --init ✔ How would you like to use ESLint? · problems ✔ What type of modules does your project use? · esm ✔ Which framework does your project use? · react ✔ Does your project use TypeScript? · No / Yes ✔ Where does your code run? · browser, node ✔ What format do you want your config file to be in? · JSON The config that you\u0026#39;ve selected requires the following dependencies: eslint-plugin-react@latest @typescript-eslint/eslint-plugin@latest @typescript-eslint/parser@latest ✔ Would you like to install them now? · No / Yes ✔ Which package manager do you want to use? · yarn .eslintrc.json { \u0026#34;env\u0026#34;: { \u0026#34;browser\u0026#34;: true, \u0026#34;es2021\u0026#34;: true, \u0026#34;node\u0026#34;: true }, \u0026#34;extends\u0026#34;: [ \u0026#34;eslint:recommended\u0026#34;, \u0026#34;plugin:react/recommended\u0026#34;, \u0026#34;plugin:@typescript-eslint/recommended\u0026#34;, \u0026#34;plugin:import/typescript\u0026#34;, \u0026#34;plugin:import/recommended\u0026#34;, \u0026#34;prettier\u0026#34; ], \u0026#34;overrides\u0026#34;: [], \u0026#34;parser\u0026#34;: \u0026#34;@typescript-eslint/parser\u0026#34;, \u0026#34;parserOptions\u0026#34;: { \u0026#34;ecmaVersion\u0026#34;: \u0026#34;latest\u0026#34;, \u0026#34;sourceType\u0026#34;: \u0026#34;module\u0026#34; }, \u0026#34;plugins\u0026#34;: [\u0026#34;react\u0026#34;, \u0026#34;react-hooks\u0026#34;, \u0026#34;@typescript-eslint\u0026#34;], \u0026#34;settings\u0026#34;: { \u0026#34;import/parsers\u0026#34;: { \u0026#34;@typescript-eslint/parser\u0026#34;: [\u0026#34;.ts\u0026#34;, \u0026#34;.tsx\u0026#34;] }, \u0026#34;react\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;detect\u0026#34; } }, \u0026#34;rules\u0026#34;: { \u0026#34;react/react-in-jsx-scope\u0026#34;: 0, \u0026#34;import/no-unresolved\u0026#34;: 0, \u0026#34;react-hooks/rules-of-hooks\u0026#34;: 2, \u0026#34;react-hooks/exhaustive-deps\u0026#34;: 2, \u0026#34;import/no-named-as-default-member\u0026#34;: 0, \u0026#34;import/order\u0026#34;: [ \u0026#34;error\u0026#34;, { \u0026#34;groups\u0026#34;: [ \u0026#34;builtin\u0026#34;, \u0026#34;external\u0026#34;, \u0026#34;internal\u0026#34;, [\u0026#34;parent\u0026#34;, \u0026#34;sibling\u0026#34;, \u0026#34;index\u0026#34;], \u0026#34;type\u0026#34;, \u0026#34;unknown\u0026#34; ], \u0026#34;pathGroups\u0026#34;: [ { \u0026#34;pattern\u0026#34;: \u0026#34;./*.scss\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;type\u0026#34;, \u0026#34;position\u0026#34;: \u0026#34;after\u0026#34; } ], \u0026#34;alphabetize\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34;, \u0026#34;caseInsensitive\u0026#34;: true }, \u0026#34;newlines-between\u0026#34;: \u0026#34;always\u0026#34; } ] } } .prettierrc.json { \u0026#34;arrowParens\u0026#34;: \u0026#34;always\u0026#34;, \u0026#34;bracketSpacing\u0026#34;: true, \u0026#34;htmlWhitespaceSensitivity\u0026#34;: \u0026#34;css\u0026#34;, \u0026#34;insertPragma\u0026#34;: false, \u0026#34;jsxBracketSameLine\u0026#34;: false, \u0026#34;jsxSingleQuote\u0026#34;: false, \u0026#34;printWidth\u0026#34;: 80, \u0026#34;proseWrap\u0026#34;: \u0026#34;preserve\u0026#34;, \u0026#34;quoteProps\u0026#34;: \u0026#34;as-needed\u0026#34;, \u0026#34;requirePragma\u0026#34;: false, \u0026#34;semi\u0026#34;: true, \u0026#34;singleQuote\u0026#34;: false, \u0026#34;tabWidth\u0026#34;: 2, \u0026#34;trailingComma\u0026#34;: \u0026#34;all\u0026#34;, \u0026#34;useTabs\u0026#34;: false, \u0026#34;vueIndentScriptAndStyle\u0026#34;: false } tsconfig.json { \u0026#34;compilerOptions\u0026#34;: { ..., \u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34; }, ... } .vscode/settings.json { \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.fixAll.eslint\u0026#34;: true }, \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34;, \u0026#34;css.lint.unknownAtRules\u0026#34;: \u0026#34;ignore\u0026#34; } 3. lint-staged \u0026amp; husky 설치 #npx mrm lint-staged package.json \u0026#34;lint-staged\u0026#34;: { \u0026#34;*.{js,jsx,ts,tsx,css}\u0026#34;: [ \u0026#34;prettier --write\u0026#34;, \u0026#34;eslint --fix\u0026#34; ] } npx husky-init .husky/pre-commit #!/usr/bin/env sh . \u0026#34;$(dirname -- \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; yarn lint-staged yarn prepare react-i18next 설치 #yarn add react-i18next i18next @types/react-i18next @types/i18next i18next-scanner google-spreadsheet 등록 https://console.cloud.google.com/apis/dashboard 사용자 인증 정보(Credentials) -\u0026gt; 사용자 인증 정보 만들기(CREATE CREDENTIALS) -\u0026gt; 서비스 계정(Service account) 서비스 계정(Service Accounts)에서 방금 생성한 계정 클릭 키(KEYS) 탭에서 JSON 파일로 새 키 만들기 세부정보(DETAILS) 탭에서 이메일 복사 후 구글 스프레드 시트에서 공유 설정 .gitignore\n# i18n translate/.credentials .credentials/index.js\nmodule.exports = { CREDS: /* 키(KEYS) 탭에서 만든 JSON 파일 */, SHEET_DOC_ID: /* 공유 시트의 문서 아이디 */, SHEET_ID: /* 공유 시트의 시트 아이디 */, }; i18next-scanner.config.js /* eslint-disable import/order */ /* eslint-disable no-undef */ /* eslint-disable @typescript-eslint/no-var-requires */ const fs = require(\u0026#34;fs\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const typescript = require(\u0026#34;typescript\u0026#34;); const COMMON_EXTENSIONS = \u0026#34;/**/*.{js,jsx,ts,tsx,vue,html}\u0026#34;; module.exports = { input: [ `./pages/${COMMON_EXTENSIONS}`, `./@apis/${COMMON_EXTENSIONS}`, `./@components/${COMMON_EXTENSIONS}`, `./@hooks/${COMMON_EXTENSIONS}`, `./@recoils/${COMMON_EXTENSIONS}`, `./@utils/${COMMON_EXTENSIONS}`, ], options: { debug: true, removeUnusedKeys: true, defaultLng: \u0026#34;ko-KR\u0026#34;, //*i18n: 언어 추가 시 작성 필요 lngs: [\u0026#34;ko-KR\u0026#34;, \u0026#34;ko-KR\u0026#34;, \u0026#34;en-US\u0026#34;, \u0026#34;ja-JP\u0026#34;, \u0026#34;vi-VN\u0026#34;, \u0026#34;es-ES\u0026#34;], func: { list: [\u0026#34;i18n.t\u0026#34;, \u0026#34;$i18n.t\u0026#34;], extensions: [\u0026#34;.js\u0026#34;, \u0026#34;.jsx\u0026#34;], }, trans: { component: \u0026#34;Trans\u0026#34;, i18nKey: \u0026#34;i18nKey\u0026#34;, defaultsKey: \u0026#34;defaults\u0026#34;, extensions: [\u0026#34;.js\u0026#34;, \u0026#34;.jsx\u0026#34;], fallbackKey: function (ns, value) { return value; }, acorn: { ecmaVersion: 10, sourceType: \u0026#34;module\u0026#34;, }, }, resource: { loadPath: path.join(__dirname, \u0026#34;/i18n/locales/{{lng}}/{{ns}}.json\u0026#34;), savePath: path.join(__dirname, \u0026#34;/i18n/locales/{{lng}}/{{ns}}.json\u0026#34;), }, defaultValue(lng, ns, key) { const keyAsDefaultValue = [\u0026#34;ko-KR\u0026#34;]; if (keyAsDefaultValue.includes(lng)) { const separator = \u0026#34;html\u0026#34;; const value = key.includes(separator) ? \u0026#34;\u0026#34; : key; return value; } return \u0026#34;\u0026#34;; }, keySeparator: false, nsSeparator: false, prefix: \u0026#34;{{\u0026#34;, suffix: \u0026#34;}}\u0026#34;, }, transform: (function typescriptTransform( options = { tsOptions: { target: \u0026#34;es2018\u0026#34;, }, extensions: [\u0026#34;.ts\u0026#34;, \u0026#34;.tsx\u0026#34;], } ) { return function transform(file, enc, done) { const { base, ext } = path.parse(file.path); if ( options.extensions.includes(ext) \u0026amp;\u0026amp; !base.endsWith(\u0026#34;.d.ts\u0026#34;) \u0026amp;\u0026amp; base.indexOf(\u0026#34;reportWebVitals.ts\u0026#34;) === -1 ) { const content = fs.readFileSync(file.path, enc); const { outputText } = typescript.transpileModule(content, { compilerOptions: options.tsOptions, fileName: path.basename(file.path), }); this.parser.parseTransFromString(outputText); this.parser.parseFuncFromString(outputText); } done(); }; })({ extensions: [\u0026#34;.tsx\u0026#34;, \u0026#34;.ts\u0026#34;], tsOptions: { target: \u0026#34;es5\u0026#34;, module: \u0026#34;esnext\u0026#34;, }, }), }; input과 options.resource로 탐색 대상과 결과물 저장 위치 지정 i18n/index.tsx import i18n from \u0026#34;i18next\u0026#34;; import { initReactI18next } from \u0026#34;react-i18next\u0026#34;; import enUS from \u0026#34;./locales/en-US/translation.json\u0026#34;; import esES from \u0026#34;./locales/es-ES/translation.json\u0026#34;; import jaJP from \u0026#34;./locales/ja-JP/translation.json\u0026#34;; import koKR from \u0026#34;./locales/ko-KR/translation.json\u0026#34;; import viVN from \u0026#34;./locales/vi-VN/translation.json\u0026#34;; export const LOCAL_CURRENT_LANGUAGE = \u0026#34;LOCAL_CURRENT_LANGUAGE\u0026#34;; //*i18n: 언어 추가 시 작성 필요 export type LanguageCode = keyof typeof RESOURCES; export type LanguageName = | \u0026#34;한국어\u0026#34; | \u0026#34;English\u0026#34; | \u0026#34;日本語\u0026#34; | \u0026#34;Tiếng Việt\u0026#34; | \u0026#34;español\u0026#34;; export type LanguageInfo = [LanguageCode, LanguageName]; export const LANGUAGE_INFOS: LanguageInfo[] = [ [\u0026#34;ko\u0026#34;, \u0026#34;한국어\u0026#34;], [\u0026#34;en\u0026#34;, \u0026#34;English\u0026#34;], [\u0026#34;ja\u0026#34;, \u0026#34;日本語\u0026#34;], [\u0026#34;vi\u0026#34;, \u0026#34;Tiếng Việt\u0026#34;], [\u0026#34;es\u0026#34;, \u0026#34;español\u0026#34;], ]; const RESOURCES = { ko: { translation: koKR }, en: { translation: enUS }, ja: { translation: jaJP }, vi: { translation: viVN }, es: { translation: esES }, } as const; const browserLanguage = typeof window !== \u0026#34;undefined\u0026#34; ? window.navigator.language.split(\u0026#34;-\u0026#34;)[0] : \u0026#34;en\u0026#34;; const userLanguage = typeof localStorage !== \u0026#34;undefined\u0026#34; ? localStorage.getItem(LOCAL_CURRENT_LANGUAGE) ?? browserLanguage : \u0026#34;en\u0026#34;; // eslint-disable-next-line import/no-named-as-default-member i18n.use(initReactI18next).init({ resources: RESOURCES, lng: userLanguage, fallbackLng: \u0026#34;en\u0026#34;, debug: false, defaultNS: \u0026#34;translation\u0026#34;, ns: \u0026#34;translation\u0026#34;, keySeparator: false, interpolation: { escapeValue: true, alwaysFormat: true, format(value, format, lng) { if (format === \u0026#34;uppercase\u0026#34;) return value.toUpperCase(); if (typeof value === \u0026#34;number\u0026#34;) return value.toLocaleString(lng); return value; }, }, react: { defaultTransParent: \u0026#34;div\u0026#34;, transEmptyNodeValue: \u0026#34;\u0026#34;, transSupportBasicHtmlNodes: true, transKeepBasicHtmlNodesFor: [ \u0026#34;br\u0026#34;, \u0026#34;strong\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;button\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;span\u0026#34;, \u0026#34;div\u0026#34;, \u0026#34;input\u0026#34;, ], transWrapTextNodes: \u0026#34;\u0026#34;, }, nsSeparator: \u0026#34;=\u0026gt;\u0026#34;, // default: \u0026#34;:\u0026#34; returnNull: false, returnEmptyString: false, }); export default i18n; export interface Ii18Next { // eslint-disable-next-line @typescript-eslint/ban-types t: (str: string, option?: Object) =\u0026gt; string; } export const i18nextScanKey = (key: string): string =\u0026gt; key; translate/index.js /* eslint-disable import/order */ /* eslint-disable no-undef */ /* eslint-disable @typescript-eslint/no-var-requires */ const { GoogleSpreadsheet } = require(\u0026#34;google-spreadsheet\u0026#34;); const ENV = require(\u0026#34;./.credentials/index.js\u0026#34;); const creds = require(\u0026#34;./.credentials/\u0026#34; + ENV.CREDS); const i18nextConfig = require(\u0026#34;../i18next-scanner.config\u0026#34;); const spreadsheetDocId = ENV.SHEET_DOC_ID; const ns = \u0026#34;translation\u0026#34;; const lngs = i18nextConfig.options.lngs; const loadPath = i18nextConfig.options.resource.loadPath; const localesPath = loadPath.replace(\u0026#34;/{{lng}}/{{ns}}.json\u0026#34;, \u0026#34;\u0026#34;); const rePluralPostfix = new RegExp(/_plural|_[\\d]/g); const sheetId = ENV.SHEET_ID; const NOT_AVAILABLE_CELL = \u0026#34;_N/A\u0026#34;; //*i18n: 언어 추가 시 작성 필요 const columnKeyToHeader = { key: \u0026#34;key\u0026#34;, \u0026#34;ko-KR\u0026#34;: \u0026#34;ko-KR\u0026#34;, \u0026#34;en-US\u0026#34;: \u0026#34;en-US\u0026#34;, \u0026#34;ja-JP\u0026#34;: \u0026#34;ja-JP\u0026#34;, \u0026#34;vi-VN\u0026#34;: \u0026#34;vi-VN\u0026#34;, \u0026#34;es-ES\u0026#34;: \u0026#34;es-ES\u0026#34;, }; async function loadSpreadsheet() { // eslint-disable-next-line no-console console.info( \u0026#34;\\u001B[32m\u0026#34;, \u0026#34;=====================================================================================================================\\n\u0026#34;, \u0026#34;# i18next auto-sync using Spreadsheet\\n\\n\u0026#34;, \u0026#34; * Download translation resources from Spreadsheet and make /src/i18n/locales/{{lng}}/{{ns}}.json\\n\u0026#34;, \u0026#34; * Upload translation resources to Spreadsheet.\\n\\n\u0026#34;, `The Spreadsheet for translation is here (\\u001B[34mhttps://docs.google.com/spreadsheets/d/${spreadsheetDocId}/#gid=${sheetId}\\u001B[0m)\\n`, \u0026#34;=====================================================================================================================\u0026#34;, \u0026#34;\\u001B[0m\u0026#34; ); const doc = new GoogleSpreadsheet(spreadsheetDocId); await doc.useServiceAccountAuth(creds); await doc.loadInfo(); return doc; } function getPureKey(key = \u0026#34;\u0026#34;) { return key.replace(rePluralPostfix, \u0026#34;\u0026#34;); } module.exports = { localesPath, loadSpreadsheet, getPureKey, ns, lngs, sheetId, columnKeyToHeader, NOT_AVAILABLE_CELL, }; translate/upload.js /* eslint-disable no-undef */ /* eslint-disable @typescript-eslint/no-var-requires */ const fs = require(\u0026#34;fs\u0026#34;); const { loadSpreadsheet, localesPath, getPureKey, ns, lngs, sheetId, columnKeyToHeader, NOT_AVAILABLE_CELL, } = require(\u0026#34;./index\u0026#34;); //*i18n: 언어 추가 시 작성 필요 const headerValues = [\u0026#34;key\u0026#34;, \u0026#34;ko-KR\u0026#34;, \u0026#34;en-US\u0026#34;, \u0026#34;ja-JP\u0026#34;, \u0026#34;vi-VN\u0026#34;, \u0026#34;es-ES\u0026#34;]; async function addNewSheet(doc, title, sheetId) { const sheet = await doc.addSheet({ sheetId, title, headerValues, }); return sheet; } async function updateTranslationsFromKeyMapToSheet(doc, keyMap) { const title = \u0026#34;B2Bv2\u0026#34;; let sheet = doc.sheetsById[sheetId]; if (!sheet) { sheet = await addNewSheet(doc, title, sheetId); } const rows = await sheet.getRows(); const exsitKeys = {}; const addedRows = []; rows.forEach((row) =\u0026gt; { const key = row[columnKeyToHeader.key]; if (keyMap[key]) { exsitKeys[key] = true; } }); for (const [key, translations] of Object.entries(keyMap)) { if (!exsitKeys[key]) { const row = { [columnKeyToHeader.key]: key, ...Object.keys(translations).reduce((result, lng) =\u0026gt; { const header = columnKeyToHeader[lng]; result[header] = translations[lng]; return result; }, {}), }; addedRows.push(row); } } await sheet.addRows(addedRows); } function toJson(keyMap) { const json = {}; Object.entries(keyMap).forEach(([, keysByPlural]) =\u0026gt; { for (const [keyWithPostfix, translations] of Object.entries(keysByPlural)) { json[keyWithPostfix] = { ...translations, }; } }); return json; } function gatherKeyMap(keyMap, lng, json) { for (const [keyWithPostfix, translated] of Object.entries(json)) { const key = getPureKey(keyWithPostfix); if (!keyMap[key]) { keyMap[key] = {}; } const keyMapWithLng = keyMap[key]; if (!keyMapWithLng[keyWithPostfix]) { keyMapWithLng[keyWithPostfix] = lngs.reduce((initObj, lng) =\u0026gt; { initObj[lng] = NOT_AVAILABLE_CELL; return initObj; }, {}); } keyMapWithLng[keyWithPostfix][lng] = translated; } } async function updateSheetFromJson() { const doc = await loadSpreadsheet(); fs.readdir(localesPath, (error, lngs) =\u0026gt; { if (error) { throw error; } const keyMap = {}; lngs.forEach((lng) =\u0026gt; { const localeJsonFilePath = `${localesPath}/${lng}/${ns}.json`; // eslint-disable-next-line no-sync const json = fs.readFileSync(localeJsonFilePath, \u0026#34;utf8\u0026#34;); gatherKeyMap(keyMap, lng, JSON.parse(json)); }); updateTranslationsFromKeyMapToSheet(doc, toJson(keyMap)); }); } updateSheetFromJson(); translate/download.js /* eslint-disable no-undef */ /* eslint-disable @typescript-eslint/no-var-requires */ const fs = require(\u0026#34;fs\u0026#34;); const mkdirp = require(\u0026#34;mkdirp\u0026#34;); const { loadSpreadsheet, localesPath, ns, lngs, sheetId, columnKeyToHeader, NOT_AVAILABLE_CELL, } = require(\u0026#34;./index\u0026#34;); /** * fetch translations from google spread sheet and transform to json * @param {GoogleSpreadsheet} doc GoogleSpreadsheet document * @returns [object] translation map * { * \u0026#34;ko-KR\u0026#34;: { * \u0026#34;key\u0026#34;: \u0026#34;value\u0026#34; * }, * \u0026#34;en-US\u0026#34;: { * \u0026#34;key\u0026#34;: \u0026#34;value\u0026#34; * }, * } */ async function fetchTranslationsFromSheetToJson(doc) { const sheet = doc.sheetsById[sheetId]; if (!sheet) { return {}; } const lngsMap = {}; const rows = await sheet.getRows(); rows.forEach((row) =\u0026gt; { const key = row[columnKeyToHeader.key]; lngs.forEach((lng) =\u0026gt; { const translation = row[columnKeyToHeader[lng]]; if (translation === NOT_AVAILABLE_CELL) { return; } if (!lngsMap[lng]) { lngsMap[lng] = {}; } lngsMap[lng][key] = translation || \u0026#34;\u0026#34;; }); }); return lngsMap; } function checkAndMakeLocaleDir(dirPath, subDirs) { return new Promise((resolve) =\u0026gt; { subDirs.forEach((subDir, index) =\u0026gt; { mkdirp(`${dirPath}/${subDir}`, (err) =\u0026gt; { if (err) { throw err; } if (index === subDirs.length - 1) { resolve(); } }); }); }); } async function updateJsonFromSheet() { await checkAndMakeLocaleDir(localesPath, lngs); const doc = await loadSpreadsheet(); const lngsMap = await fetchTranslationsFromSheetToJson(doc); fs.readdir(localesPath, (error, lngs) =\u0026gt; { if (error) { throw error; } lngs.forEach((lng) =\u0026gt; { const localeJsonFilePath = `${localesPath}/${lng}/${ns}.json`; const jsonString = JSON.stringify(lngsMap[lng], null, 2); fs.writeFile(localeJsonFilePath, jsonString, \u0026#34;utf8\u0026#34;, (err) =\u0026gt; { if (err) { throw err; } }); }); }); } updateJsonFromSheet(); storybook 설치 #npx -p @storybook/cli sb init .gitignore\n# storybook build-storybook.log 컨벤션 #1. Naming # 길이가 길어져도 최대한 구체적으로 명명하기\nType Case 파일 및 폴더 snake_case*컴포넌트 파일 및 폴더는 PascalCase 클래스(스타일) kebab-case 상수 UPPER_DELIMITER_CASE 변수 camelCase[명사] 함수 camelCase[동사]*사용자 이벤트에 사용되는 함수는 \u0026ldquo;handle-\u0026rdquo; 붙히기*서버 통신 함수는 앞에 method 종류 붙히기 / e.g. getAccount 타입 PascalCase*기본적으로 interface 사용 (Tuple, Union Type, Intersection Type만 type alias 사용) 2. Branch # Branch Details deploy/prd 배포 중인 product 브랜치 deploy/stg 배포 중인 develop 브랜치 feat/\u0026hellip; 작업별 개발 브랜치 hotfix/… 긴급 수정을 위해 배포 브랜치에서 분기한 브랜치 3. Commit #[Prefix]: [Title] #[Jira Issue No.] - [Details] \u0026lt;!-- e.g. --\u0026gt; 📤 Update: README.md 업데이트 #WBA-999 - 배포 환경 추가 - 컨벤션 스타일 추가 - PR 템플릿 수정 Prefix Details ⭐️ Add: 코드, 문서, 라이브러리 등의 추가 ✨ Make: 기존 코드 변경 및 개선 ❌ Remove: 코드, 문서, 라이브러리 등의 삭제 🏗 Refactor: 리팩토링 🪛 Fix: 옳바르지 않은 동작을 고침 📤 Update: 코드가 아닌 문서, 라이브러리 등의 업데이트 🕒 Temporary: 임시 작업 🧹 Chore: 기타 작업 gitmoji \u0026#34;gitmoji.onlyUseCustomEmoji\u0026#34;: true, \u0026#34;gitmoji.outputType\u0026#34;: \u0026#34;emoji\u0026#34;, \u0026#34;gitmoji.addCustomEmoji\u0026#34;: [ { \u0026#34;emoji\u0026#34;: \u0026#34;⭐️ Add:\u0026#34;, \u0026#34;code\u0026#34;: \u0026#34;:add:\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;코드, 문서, 라이브러리 등의 추가\u0026#34; }, { \u0026#34;emoji\u0026#34;: \u0026#34;✨ Make:\u0026#34;, \u0026#34;code\u0026#34;: \u0026#34;:make:\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;기존 코드 변경 및 개선\u0026#34; }, { \u0026#34;emoji\u0026#34;: \u0026#34;❌ Remove:\u0026#34;, \u0026#34;code\u0026#34;: \u0026#34;:remove:\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;코드, 문서, 라이브러리 등의 삭제\u0026#34; }, { \u0026#34;emoji\u0026#34;: \u0026#34;🏗 Refactor:\u0026#34;, \u0026#34;code\u0026#34;: \u0026#34;:refactor:\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;리팩토링\u0026#34; }, { \u0026#34;emoji\u0026#34;: \u0026#34;🪛 Fix:\u0026#34;, \u0026#34;code\u0026#34;: \u0026#34;:fix:\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;옳바르지 않은 동작을 고침\u0026#34; }, { \u0026#34;emoji\u0026#34;: \u0026#34;📤 Update:\u0026#34;, \u0026#34;code\u0026#34;: \u0026#34;:update:\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;코드가 아닌 문서, 라이브러리 등의 업데이트\u0026#34; }, { \u0026#34;emoji\u0026#34;: \u0026#34;🕒 Temporary:\u0026#34;, \u0026#34;code\u0026#34;: \u0026#34;:Temporary:\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;임시 작업\u0026#34; }, { \u0026#34;emoji\u0026#34;: \u0026#34;🧹 Chore:\u0026#34;, \u0026#34;code\u0026#34;: \u0026#34;:chore:\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;기타 작업\u0026#34; } ], 4. PR #[Prefix]: [Title] #[Jira Issue No.] \u0026lt;!-- e.g. --\u0026gt; ✅ Implement: 비교 분석 기능 추가 #WBA-999 Prefix Details 🚀 Deploy: 정식 프로덕트 배포 🚨 Hotfix: 긴급 수정 ✅ Implement: 기능 구현 완료 💫 Enhancement: 완료된 기능의 개선 🚧 In progress: 완료하지 못한 기능 \u0026hellip; Commit의 Prefix와 동일 Assignee 및 Label 등록 Template 중 개요만 필수 작성 작성 안 할 타이틀은 지우고 작성하기 Commit이 단순 작업 단위라면 PR은 목적 단위로 PR 작성의 이유를 개요에 포함해야 함 .github/pull_request_template.md \u0026lt;!-- # [Prefix]: [Title] #[Jira Issue No.] --\u0026gt; \u0026lt;!-- # Assignee 및 Label 등록 --\u0026gt; \u0026lt;!-- # Template 중 개요만 필수 작성 (작성 안 할 타이틀은 지우기) --\u0026gt; \u0026lt;!-- # Prefix는 Label과 일치 --\u0026gt; ## 개요\\* ## 작업 내용 ## 변경 로직 ## 사용방법 ## 기타 5. 기타 # 기본적으로 named export 사용 약어는 범용적인 것만 사용 (e.g. func, btn, msg, err, res, req) 주석은 꼭 필요할 때만 사용 SOLID한 코드 지향 단일 책임 원칙(Single Responsibility Principle) ˆ 한 클래스/함수는 하나의 책임만 가져야 함 개방 폐쇄 원칙(Open Close Principle) ˆ 확장에는 열려있고, 변경에는 닫혀있어야 함 리스코프 치환 원칙 (Liskov Substitution Principle) ˆ 상위 타입의 객체를 하위 타입의 객체로 프로그램 속성(정확성, 수행하는 업무 등)의 변경 없이 교체할 수 있어야 함 인터페이스 분리 원칙 (Interface Segregation Principle) ˆ 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 나음 의존관계 역전 원칙 (Dependency Inversion Principle) ˆ 상위 계층이 하위 계층의 구현으로부터 독립되어야 함 ","date":"7 May 2023","permalink":"/posts/work/6/","section":"Posts","summary":"개요 #BE가 기존의 Express 및 TypeORM로 구성된 서버를 Nest.","title":"[B2B/리팩토링] 프로젝트 시작"},{"content":"제 3장. 노드 기능 알아보기 #1) 모듈 # CommonJS 모듈\n// 파일 하나당 하나만 가능 module.exports = 데이터; // 파일 하나당 여러개 가능 exports.변수 = 데이터; const 데이터 = require(\u0026#34;경로\u0026#34;); // require.main은 실행한 파일 // require.cache는 캐시된 모듈(한 번 이상 실행된 경우) // 순환 참조 시 자동으로 빈 객체가 됨 ECMAScript 모듈\n// 이름 필수 X, 파일 하나당 하나만 가능 export default 데이터 // 이름 필수 O, 파일 하나당 여러개 가능 export 데이터 // export default import 임의_데이터명 from \u0026#34;경로\u0026#34;; // export import { 데이터명 } from \u0026#34;경로\u0026#34;; import { 데이터명 as 임의_데이터명 } from \u0026#34;경로\u0026#34;; import * as 임의_객체명 from \u0026#34;경로\u0026#34;; CommonJS 모듈과 ES 모듈의 차이점\n차이점 CommonJS 모듈 ES 모듈 최상단 외 사용 가능 불가능 확장자 js, cjs js(package.json에 \u0026ldquo;type\u0026rdquo;: \u0026ldquo;module\u0026rdquo; 필요), mjs 확장자 생략 가능 불가능 인덱스 생략 가능 불가능 top level await[1] 불가능 가능 dynamic import[2] 가능 불가능 __filename,__dirname 사용 가능 사용 불가능(__filename 대신 import.meta.url 사용) [1] top level await: 최상위 스코프에서 await 바로 사용 가능\n[2] dynamic import\nconst a = true; if (a) require(\u0026#34;...\u0026#34;); const a = true if (a) const b = await import(\u0026#34;...\u0026#34;) *CommonJS 모듈과 ES 모듈 간의 호출은 대부분 가능\n*최상위 스코프의 this는 module.exports\nconsole.log(this); // -\u0026gt; {} 2) 노드 내장 객체 # global\n노드의 전역 객체 브라우저의 window(globalThis)와 같은 역할 global에 값을 넣을 경우 다른 파일에서도 사용 가능하지만 지양해야함 console\nMethods Details console.time(로그),console.timeEnd(로그) 시간 로깅 console.log(로그) 시간 로깅 console.table(로그) 테이블로 표시되는 로깅 console.error(로그) 에러 로깅 console.dir(로그) 객체 로깅 console.trace(로그) 호출스택 로깅*함수 내부에서 사용 example const string = \u0026#34;abc\u0026#34;; const number = 1; const boolean = true; const obj = { outside: { inside: { key: \u0026#34;value\u0026#34;, }, }, }; console.time(\u0026#34;전체시간\u0026#34;); console.log(\u0026#34;평범한 로그입니다 쉼표로 구분해 여러 값을 찍을 수 있습니다\u0026#34;); console.log(string, number, boolean); console.error(\u0026#34;에러 메시지는 console.error에 담아주세요\u0026#34;); console.table([ { name: \u0026#34;제로\u0026#34;, birth: 1994 }, { name: \u0026#34;hero\u0026#34;, birth: 1988 }, ]); console.dir(obj, { colors: true, depth: 2 }); console.dir(obj, { colors: false, depth: 1 }); console.time(\u0026#34;시간측정\u0026#34;); for (let i = 0; i \u0026lt; 100000; i++) {} console.timeEnd(\u0026#34;시간측정\u0026#34;); function b() { console.trace(\u0026#34;에러 위치 추적\u0026#34;); } function a() { b(); } a(); console.timeEnd(\u0026#34;전체시간\u0026#34;); 평범한 로그입니다 쉼표로 구분해 여러 값을 찍을 수 있습니다 abc 1 true 에러 메시지는 console.error에 담아주세요 ┌─────────┬────────┬───────┐ │ (index) │ name │ birth │ ├─────────┼────────┼───────┤ │ 0 │ \u0026#39;제로\u0026#39; │ 1994 │ │ 1 │ \u0026#39;hero\u0026#39; │ 1988 │ └─────────┴────────┴───────┘ { outside: { inside: { key: \u0026#39;value\u0026#39; } } } { outside: { inside: [Object] } } 시간측정: 21.228ms Trace: 에러 위치 추적 at b (/Users/yuchanjeong/Desktop/nodejs-book-master/ch3/3.4/console.js:29:11) at Object.\u0026lt;anonymous\u0026gt; (/Users/yuchanjeong/Desktop/nodejs-book-master/ch3/3.4/console.js:32:1) at Module._compile (node:internal/modules/cjs/loader:1155:14) at Object.Module._extensions..js (node:internal/modules/cjs/loader:1209:10) at Module.load (node:internal/modules/cjs/loader:1033:32) at Function.Module._load (node:internal/modules/cjs/loader:868:12) at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12) at node:internal/main/run_main_module:22:47 전체시간: 34.557ms process\n현재 실행중인 노드 프로세스에 대한 정보를 담고있음 Properties \u0026amp; Methods Details process.cwd() 실행중인 노드 프로세스 경로 process.env 시스템 환경 변수*노드에 직접 영향을 미치는 변수도 있음ㅤNODE_OPTIONS=\u0026ndash;max-old-space-size=8192 (노드 옵션: 메모리 사이즈)ㅤUV_THREADPOOL_SIZE=8 (스레드 갯수) process.nextTick(콜백) 이벤트 루프가 다른 콜백함수 보다 우선적으로 처리 process.exit(코드) 코드가 없거나 0이면 정상 종료\n*그 외는 비정상 종료 example $ node \u0026gt; process.version v18.7.0 // 설치된 노드의 버전입니다 \u0026gt; process.arch x64 // 프로세서 아키텍처 정보입니다. arm, ia32 등의 값일 수도 있습니다 \u0026gt; process.platform win32 // 운영체제 플랫폼 정보입니다. linux나 darwin, freebsd 등의 값일 수도 있습니다 \u0026gt; process.pid 14736 // 현재 프로세스의 아이디입니다. 프로세스를 여러 개 가질 때 구분할 수 있습니다 \u0026gt; process.uptime() 199.36 // 프로세스가 시작된 후 흐른 시간입니다. 단위는 초입니다 \u0026gt; process.execPath C:\\Program Files\\nodejs\\node.exe // 노드의 경로입니다 \u0026gt; process.cwd() C:\\Users\\zerocho // 현재 프로세스가 실행되는 위치입니다 \u0026gt; process.cpuUsage() { user: 390000, system: 203000 } // 현재 cpu 사용량입니다 기타 내장 객체\nURL, URLSearchParams TextDecoder: Buffer를 문자열로 바꿈 TextEncoder: 문자열을 Buffer로 바꿈 WebAssembly: 웹어셈블리 처리 담당 AbortController, FormData, fetch, Headers, Request, Response, Event, EventTarget: 브라우저에서 사용하던 API들 3) 노드 내장 모듈 #1. os (●○○) # 운영체제의 정보를 담고있는 모듈\nlist os.arch(): process.arch와 동일합니다.\nos.platform(): process.platform과 동일합니다.\nos.type(): 운영체제의 종류를 보여줍니다.\nos.uptime(): 운영체제 부팅 이후 흐른 시간(초)을 보여줍니다.\nos.hostname(): 컴퓨터의 이름을 보여줍니다.\nos.release(): 운영체제의 버전을 보여줍니다.\nos.homedir(): 홈 디렉터리 경로를 보여줍니다.\nos.tmpdir(): 임시 파일 저장 경로를 보여줍니다.\nos.cpus(): 컴퓨터의 코어 정보를 보여줍니다.\nos.freemem(): 사용 가능한 메모리(RAM)를 보여줍니다.\nos.totalmem(): 전체 메모리 용량을 보여줍니다.\n2. path (●●○) # 폴더와 파일의 경로를 쉽게 조작하도록 도와주는 모듈\n./(상대 경로) vs /(절대 경로)\npath.join(경로, …) vs path.resolve(경로, …)\npath.join(\u0026#34;/a\u0026#34;, \u0026#34;/b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;..\u0026#34;); // /a/b path.resolve(\u0026#34;/a\u0026#34;, \u0026#34;/b\u0026#34;, \u0026#34;c\u0026#34;); // /b/c -\u0026gt; 상대경로와 절대경로를 구분 Properties \u0026amp; Methods Return path.sep 경로의 구분자*WINDOW는 \u0026ldquo;\\\u0026rdquo;, POSIX(LINUX \u0026amp; MAC)는 \u0026ldquo;/\u0026rdquo; path.delimiter 환경 변수의 구분자 (process.env.PATH를 입력하면 여러 개의 경로가 이 구분자로 구분되어 있음)*WINDOW는 \u0026ldquo;;\u0026rdquo;, POSIX는 \u0026ldquo;:\u0026rdquo; path.dirname(경로) 파일이 위치한 폴더 경로 path.extname(경로) 파일의 확장자 path.basename(경로, [확장자]) 파일의 이름*두 번째 인수를 넣을 경우 파일의 이름만 표시 path.parse(경로) 파일 경로를 root, dir, base, ext, name으로 구분한 객체 path.format(객체) path.parse()의 반환값을 합친 경로 path.normalize(경로) \u0026ldquo;/\u0026ldquo;나 \u0026ldquo;\\\u0026ldquo;를 잘못 사용했을 때 올바르게 변환한 경로 path.isAbsolute(경로) 절대경로인지 여부 path.relative(기준경로, 목표경로) 기준경로에서 목표경로로 가는 경로 example const path = require(\u0026#39;path\u0026#39;); const string = __filename; console.log(\u0026#39;path.sep:\u0026#39;, path.sep); console.log(\u0026#39;path.delimiter:\u0026#39;, path.delimiter); console.log(\u0026#39;------------------------------\u0026#39;); console.log(\u0026#39;path.dirname():\u0026#39;, path.dirname(string)); console.log(\u0026#39;path.extname():\u0026#39;, path.extname(string)); console.log(\u0026#39;path.basename():\u0026#39;, path.basename(string)); console.log(\u0026#39;path.basename - extname:\u0026#39;, path.basename(string, path.extname(string))); console.log(\u0026#39;------------------------------\u0026#39;); console.log(\u0026#39;path.parse()\u0026#39;, path.parse(string)); console.log(\u0026#39;path.format():\u0026#39;, path.format({ dir: \u0026#39;C:\\users\\zerocho\u0026#39;, name: \u0026#39;path\u0026#39;, ext: \u0026#39;.js\u0026#39;, })); console.log(\u0026#39;path.normalize():\u0026#39;, path.normalize(\u0026#39;C://users\\\\zerocho\\\\path.js\u0026#39;)); console.log(\u0026#39;------------------------------\u0026#39;); console.log(\u0026#39;path.isAbsolute(C:\\):\u0026#39;, path.isAbsolute(\u0026#39;C:\\\u0026#39;)); console.log(\u0026#39;path.isAbsolute(./home):\u0026#39;, path.isAbsolute(\u0026#39;./home\u0026#39;)); console.log(\u0026#39;------------------------------\u0026#39;); console.log(\u0026#39;path.relative():\u0026#39;, path.relative(\u0026#39;C:\\users\\zerocho\\path.js\u0026#39;, \u0026#39;C:\\\u0026#39;)); console.log(\u0026#39;path.join():\u0026#39;, path.join(__dirname, \u0026#39;..\u0026#39;, \u0026#39;..\u0026#39;, \u0026#39;/users\u0026#39;, \u0026#39;.\u0026#39;, \u0026#39;/zerocho\u0026#39;)); console.log(\u0026#39;path.resolve():\u0026#39;, path.resolve(__dirname, \u0026#39;..\u0026#39;, \u0026#39;users\u0026#39;, \u0026#39;.\u0026#39;, \u0026#39;/zerocho\u0026#39;)); path.sep: \\ path.delimiter: ; ------------------------------ path.dirname(): C:\\Users\\zerocho path.extname(): .js path.basename(): path.js path.basename - extname: path ------------------------------ path.parse() { root: \u0026#39;C:\\\u0026#39;, dir: \u0026#39;C:\\Users\\zerocho\u0026#39;, base: \u0026#39;path.js\u0026#39;, ext: \u0026#39;.js\u0026#39;, name: \u0026#39;path\u0026#39; } path.format(): C:\\users\\zerocho\\path.js path.normalize(): C:\\users\\zerocho\\path.js ------------------------------ path.isAbsolute(C:\\): true path.isAbsolute(./home): false ------------------------------ path.relative(): ..\\..\\.. path.join(): C:\\Users\\zerocho path.resolve(): C:\\zerocho 3. url (●●○) # 인터넷 주소를 쉽게 조작하도록 도와주는 모듈 pathname만 있는 주소는 new URL(pathname, host)로 host를 두 번째 인수로 적어줘야 함 .searchParams로 쿼리 스트링을 다룸 Methods Return or Details .searchParams.getAll(키) 키에 해당하는 모든 값 .searchParams.get(키) 키에 해당하는 첫 번째 값 .searchParams.has(키) 해당 키의 존재 여부 .searchParams.keys() 모든 키를 포함한 iterator(반복자 객체) .searchParams.values() 모든 값를 포함한 iterator(반복자 객체) .searchParams.append(키, 값) 해당 키를 추가, 같은 키의 값이 있다면 유지하면서 하나 더 추가 .searchParams.set(키, 값) 해당 키를 추가, 같은 키의 값이 있다면 제거하면서 추가 .searchParams.delete(키) 해당 키를 제거 .searchParams.toString() searchParams 객체를 다시 문자열로 만듦 example const myURL = new URL( \u0026#34;http://www.gilbut.co.kr/book/bookList.aspx?sercate1=001001000#anchor\u0026#34; ); console.log(\u0026#34;new URL():\u0026#34;, myURL); console.log(\u0026#34;url.format():\u0026#34;, url.format(myURL)); new URL(): URL { href: \u0026#39;http://www.gilbut.co.kr/book/bookList.aspx?sercate1=001001000#anchor\u0026#39;, origin: \u0026#39;http://www.gilbut.co.kr\u0026#39;, protocol: \u0026#39;http:\u0026#39;, username: \u0026#39;\u0026#39;, password: \u0026#39;\u0026#39;, host: \u0026#39;www.gilbut.co.kr\u0026#39;, hostname: \u0026#39;www.gilbut.co.kr\u0026#39;, port: \u0026#39;\u0026#39;, pathname: \u0026#39;/book/bookList.aspx\u0026#39;, search: \u0026#39;?sercate1=001001000\u0026#39;, searchParams: URLSearchParams { \u0026#39;sercate1\u0026#39; =\u0026gt; \u0026#39;001001000\u0026#39; }, hash: \u0026#39;#anchor\u0026#39; } url.format(): http://www.gilbut.co.kr/book/bookList.aspx?sercate1=001001000#anchor const myURL = new URL( \u0026#34;http://www.gilbut.co.kr/?page=3\u0026amp;limit=10\u0026amp;category=nodejs\u0026amp;category=javascript\u0026#34; ); console.log(\u0026#34;searchParams:\u0026#34;, myURL.searchParams); console.log(\u0026#34;searchParams.getAll():\u0026#34;, myURL.searchParams.getAll(\u0026#34;category\u0026#34;)); console.log(\u0026#34;searchParams.get():\u0026#34;, myURL.searchParams.get(\u0026#34;limit\u0026#34;)); console.log(\u0026#34;searchParams.has():\u0026#34;, myURL.searchParams.has(\u0026#34;page\u0026#34;)); console.log(\u0026#34;searchParams.keys():\u0026#34;, myURL.searchParams.keys()); console.log(\u0026#34;searchParams.values():\u0026#34;, myURL.searchParams.values()); myURL.searchParams.append(\u0026#34;filter\u0026#34;, \u0026#34;es3\u0026#34;); myURL.searchParams.append(\u0026#34;filter\u0026#34;, \u0026#34;es5\u0026#34;); console.log(myURL.searchParams.getAll(\u0026#34;filter\u0026#34;)); myURL.searchParams.set(\u0026#34;filter\u0026#34;, \u0026#34;es6\u0026#34;); console.log(myURL.searchParams.getAll(\u0026#34;filter\u0026#34;)); myURL.searchParams.delete(\u0026#34;filter\u0026#34;); console.log(myURL.searchParams.getAll(\u0026#34;filter\u0026#34;)); console.log(\u0026#34;searchParams.toString():\u0026#34;, myURL.searchParams.toString()); myURL.search = myURL.searchParams.toString(); searchParams: URLSearchParams { \u0026#39;page\u0026#39; =\u0026gt; \u0026#39; 3 \u0026#39;, \u0026#39;limit\u0026#39; =\u0026gt; \u0026#39; 10 \u0026#39;, \u0026#39;category\u0026#39; =\u0026gt; \u0026#39;nodejs\u0026#39;, \u0026#39;category\u0026#39; =\u0026gt; \u0026#39;javascript\u0026#39; } searchParams.getAll(): [ \u0026#39;nodejs\u0026#39;, \u0026#39;javascript\u0026#39; ] searchParams.get(): 10 searchParams.has(): true searchParams.keys(): URLSearchParams Iterator { \u0026#39;page\u0026#39;, \u0026#39;limit\u0026#39;, \u0026#39;category\u0026#39;, \u0026#39;category\u0026#39; } searchParams.values(): URLSearchParams Iterator { \u0026#39; 3 \u0026#39;, \u0026#39; 10 \u0026#39;, \u0026#39;nodejs\u0026#39;, \u0026#39;javascript\u0026#39; } [ \u0026#39;es 3 \u0026#39;, \u0026#39;es 5 \u0026#39; ] [ \u0026#39;es 6 \u0026#39; ] [] searchParams.toString(): page=3\u0026amp;limit=10\u0026amp;category=nodejs\u0026amp;category=javascript 4. dns (●○○) # DNS를 다룰 때 사용하는 모듈 도메인을 통해 IP나 DNS 레코드를 얻고자 할 때 사용 레코드 A(ipv4 주소), AAAA(ipv6 주소), NS(네임서버), SOA(도메인 정보), CNAME(별칭, 주로 www가 붙은 주소), MX(메일 서버) example import dns from \u0026#34;dns/promises\u0026#34;; const ip = await dns.lookup(\u0026#34;gilbut.co.kr\u0026#34;); console.log(\u0026#34;IP\u0026#34;, ip); const a = await dns.resolve(\u0026#34;gilbut.co.kr\u0026#34;, \u0026#34;A\u0026#34;); console.log(\u0026#34;A\u0026#34;, a); const mx = await dns.resolve(\u0026#34;gilbut.co.kr\u0026#34;, \u0026#34;MX\u0026#34;); console.log(\u0026#34;MX\u0026#34;, mx); const cname = await dns.resolve(\u0026#34;www.gilbut.co.kr\u0026#34;, \u0026#34;CNAME\u0026#34;); console.log(\u0026#34;CNAME\u0026#34;, cname); const any = await dns.resolve(\u0026#34;gilbut.co.kr\u0026#34;, \u0026#34;ANY\u0026#34;); console.log(\u0026#34;ANY\u0026#34;, any); IP { address: \u0026#39; 49 . 236 . 151 . 220 \u0026#39;, family: 4 } A [ \u0026#39; 49 . 236 . 151 . 220 \u0026#39; ] MX [ { exchange: \u0026#39;alt 2 .aspmx.l.google.com\u0026#39;, priority: 5 }, { exchange: \u0026#39;aspmx 3 .googlemail.com\u0026#39;, priority: 10 }, { exchange: \u0026#39;aspmx 2 .googlemail.com\u0026#39;, priority: 10 }, { exchange: \u0026#39;aspmx.l.google.com\u0026#39;, priority: 1 }, { exchange: \u0026#39;alt 1 .aspmx.l.google.com\u0026#39;, priority: 5 } ] CNAME [ \u0026#39;slb- 1088813 .ncloudslb.com\u0026#39; ] ANY [ { address: \u0026#39; 49 . 236 . 151 . 220 \u0026#39;, ttl: 14235, type: \u0026#39;A\u0026#39; }, { value: \u0026#39;ns 1 - 2 .ns-ncloud.com\u0026#39;, type: \u0026#39;NS\u0026#39; }, { value: \u0026#39;ns 1 - 1 .ns-ncloud.com\u0026#39;, type: \u0026#39;NS\u0026#39; }, { nsname: \u0026#39;ns 1 - 1 .ns-ncloud.com\u0026#39;, hostmaster: \u0026#39;ns 1 - 2 .ns-ncloud.com\u0026#39;, serial: 32, refresh: 21600, retry: 1800, expire: 1209600, minttl: 300, type: \u0026#39;SOA\u0026#39; } ] 5. crypto (●○○) # 다양한 방식의 암호화를 도와주는 모듈 단방향 암호 - 암호화는 가능하지만 복호화는 불가능, Hash\n문자열을 고정된 길이의 다른 문자열로 바꾸는 방식\n출력 문자열이 같은 경우 충돌이 발생했다고 함\nMethods Details crypto.createHash(해시 알고리즘) md5, sha1, sha256, sha512등의 사용할 해시 알고리즘을 넣음*보안 취약점이 많이 발견 되면서 현재는 pbkdf2, bcrypt, scrypt등의 방식을 사용*이 중 노드는 pbkdf2와 scrypt만 지원 .update(문자열) 변환할 문자열을 넣음 .digest(인코딩) base6, hex, latin1등의 인코딩할 알고리즘을 넣음 pbkdf2\n기존 문자열에 salt(문자열)를 붙인 후 해시 알고리즘을 반복해서 적용하는 방식 params: 비밀번호, salt, 반복 횟수, 출력 바이트, 해시 알고리즘 example const crypto = require(\u0026#34;crypto\u0026#34;); console.log( \u0026#34;base64:\u0026#34;, crypto.createHash(\u0026#34;sha512\u0026#34;).update(\u0026#34;비밀번호\u0026#34;).digest(\u0026#34;base64\u0026#34;) ); // 가장 짧음 console.log( \u0026#34;hex:\u0026#34;, crypto.createHash(\u0026#34;sha512\u0026#34;).update(\u0026#34;비밀번호\u0026#34;).digest(\u0026#34;hex\u0026#34;) ); console.log( \u0026#34;base64:\u0026#34;, crypto.createHash(\u0026#34;sha512\u0026#34;).update(\u0026#34;비밀번호\u0026#34;).digest(\u0026#34;base64\u0026#34;) ); const crypto = require(\u0026#34;crypto\u0026#34;); // randomBytes이므로 매번 실행할 때마다 결과가 달라져서 salt를 잘 보관하고 있어야 비밀번호도 찾을 수 있음 crypto.randomBytes(64, (err, buf) =\u0026gt; { const salt = buf.toString(\u0026#34;base64\u0026#34;); console.log(\u0026#34;salt:\u0026#34;, salt); crypto.pbkdf2(\u0026#34;비밀번호\u0026#34;, salt, 100000, 64, \u0026#34;sha512\u0026#34;, (err, key) =\u0026gt; { console.log(\u0026#34;password:\u0026#34;, key.toString(\u0026#34;base64\u0026#34;)); }); }); 양방향 암호 - 암호화된 문자열을 키로 복호화할 수 있음\n대칭형 암호 - 같은 키 비대칭 암호 - 다른 키 (e.g. https) example const crypto = require(\u0026#34;crypto\u0026#34;); const algorithm = \u0026#34;aes-256-cbc\u0026#34;; const key = \u0026#34;abcdefghijklmnopqrstuvwxyz123456\u0026#34;; const iv = \u0026#34;1234567890123456\u0026#34;; const cipher = crypto.createCipheriv(algorithm, key, iv); let result = cipher.update(\u0026#34;암호화할 문장\u0026#34;, \u0026#34;utf8\u0026#34;, \u0026#34;base64\u0026#34;); result += cipher.final(\u0026#34;base64\u0026#34;); console.log(\u0026#34;암호화:\u0026#34;, result); const decipher = crypto.createDecipheriv(algorithm, key, iv); let result2 = decipher.update(result, \u0026#34;base64\u0026#34;, \u0026#34;utf8\u0026#34;); result2 += decipher.final(\u0026#34;utf8\u0026#34;); console.log(\u0026#34;복호화:\u0026#34;, result2); *키는 AWS kms등으로 잘 관리해 줘야 함\n6. util (●○○) # 각종 편의 기능을 모아둔 모듈 Methods Details util.deprecate(콜백, 메시지) 함수가 deprecated 처리되었음을 알림 util.promisify(콜백) 콜백 패턴을 프로미스 패턴으로 변경(but 콜백이 \u0026ldquo;(err, data) =\u0026gt; {}\u0026rdquo; 여야 함) example const util = require(\u0026#34;util\u0026#34;); const crypto = require(\u0026#34;crypto\u0026#34;); const dontUseMe = util.deprecate((x, y) =\u0026gt; { console.log(x + y); }, \u0026#34;dontUseMe 함수는 deprecated되었으니 더 이상 사용하지 마세요!\u0026#34;); dontUseMe(1, 2); const randomBytesPromise = util.promisify(crypto.randomBytes); randomBytesPromise(64) .then((buf) =\u0026gt; { console.log(buf.toString(\u0026#34;base64\u0026#34;)); }) .catch((error) =\u0026gt; { console.error(error); }); 3 (node:7264) DeprecationWarning: dontUseMe 함수는 deprecated되었으니 더 이상 사용하지 마세요! (Use `node --trace-deprecation ...` to show where the warning was created) 60b4RQbrx1j130x4r95fpZac9lmcHyitqwAm8gKsHQKF8tcNhvcTfW031XaQqHlRKzaVkcENmIV25fDVs3SB7g== 7. worker_threads (●○○) # 노드에서 멀티 스레드를 다루기 위해 사용하는 모듈 스레드를 생성하고 스레드 사이에서 통신하는 데 상당한 비용이 발생하기 때문에 주의가 필요 example 동작 예제\nconst { Worker, isMainThread, parentPort, workerData, } = require(\u0026#34;worker_threads\u0026#34;); if (isMainThread) { // 부모일 때 const threads = new Set(); threads.add( new Worker(__filename, { workerData: { start: 1 }, }) ); threads.add( new Worker(__filename, { workerData: { start: 2 }, }) ); for (let worker of threads) { worker.on(\u0026#34;message\u0026#34;, (message) =\u0026gt; console.log(\u0026#34;from worker\u0026#34;, message)); worker.on(\u0026#34;exit\u0026#34;, () =\u0026gt; { threads.delete(worker); if (threads.size === 0) { console.log(\u0026#34;job done\u0026#34;); } }); } } else { // 워커일 때 const data = workerData; parentPort.postMessage(data.start + 100); } from worker 101 from worker 102 job done 소수 찾기 예제\nconst { Worker, isMainThread, parentPort, workerData, } = require(\u0026#34;worker_threads\u0026#34;); const min = 2; let primes = []; function findPrimes(start, range) { let isPrime = true; const end = start + range; for (let i = start; i \u0026lt; end; i++) { for (let j = min; j \u0026lt; Math.sqrt(end); j++) { if (i !== j \u0026amp;\u0026amp; i % j === 0) { isPrime = false; break; } } if (isPrime) { primes.push(i); } isPrime = true; } } if (isMainThread) { const max = 10000000; const threadCount = 8; const threads = new Set(); const range = Math.floor((max - min) / threadCount); let start = min; console.time(\u0026#34;prime\u0026#34;); for (let i = 0; i \u0026lt; threadCount - 1; i++) { const wStart = start; threads.add( new Worker(__filename, { workerData: { start: wStart, range } }) ); start += range; } threads.add( new Worker(__filename, { workerData: { start, range: max - start } }) ); for (let worker of threads) { worker.on(\u0026#34;error\u0026#34;, (err) =\u0026gt; { throw err; }); worker.on(\u0026#34;exit\u0026#34;, () =\u0026gt; { threads.delete(worker); if (threads.size === 0) { console.timeEnd(\u0026#34;prime\u0026#34;); console.log(primes.length); } }); worker.on(\u0026#34;message\u0026#34;, (msg) =\u0026gt; { primes = primes.concat(msg); }); } } else { findPrimes(workerData.start, workerData.range); parentPort.postMessage(primes); } 8. child_process (●○○) # 노드에서 다른 프로그램을 실행하고 싶거나 명령어를 수행하고 싶을 때 사용하는 모듈 exec 셸을 실행해서 명령어를 수행 stdout을 버퍼로 리턴(정확히는 콜백을 호출) spawn 새로운 프로세스를 띄우면서 명령어를 실행 stdout을 스트림으로 리턴 중간에 출력에 맞춰서 입력을 바꿔 넣을 수 있음 첫 번째 인수로 명령어, 두 번째 인수로 옵션 배열 세 번째 인수로 { shell: true }를 제공하면 exec처럼 셸을 실행해서 명령어를 수행 example exec\nconst exec = require(\u0026#34;child_process\u0026#34;).exec; const process = exec(\u0026#34;ls\u0026#34;); process.stdout.on(\u0026#34;data\u0026#34;, function (data) { console.log(\u0026#34;data:\u0026#34;, data.toString()); }); // 실행 결과 process.stderr.on(\u0026#34;data\u0026#34;, function (data) { console.error(\u0026#34;error: \u0026#34;, data.toString()); }); // 실행 에러 spawn\nconst spawn = require(\u0026#34;child_process\u0026#34;).spawn; const process = spawn(\u0026#34;python\u0026#34;, [\u0026#34;test.py\u0026#34;]); process.stdout.on(\u0026#34;data\u0026#34;, function (data) { console.log(data.toString()); }); // 실행 결과 process.stderr.on(\u0026#34;data\u0026#34;, function (data) { console.error(data.toString()); }); // 실행 에러 9. 기타 모듈 # async_hooks: 비동기 코드의 흐름을 추적할 수 있는 실험적인 모듈입니다. dgram: UDP와 관련된 작업을 할 때 사용합니다. net: HTTP보다 로우 레벨인 TCP나 IPC 통신을 할 때 사용합니다. perf_hooks: 성능 측정을 할 때 console.time보다 더 정교하게 측정합니다. querystring: URLSearchParams가 나오기 이전에 쿼리스트링을 다루기 위해 사용했던 모듈입니다. 요즘은 URLSearchParams를 사용하는 것을 권장합니다. string_decoder: 버퍼 데이터를 문자열로 바꾸는 데 사용합니다. tls: TLS와 SSL에 관련된 작업을 할 때 사용합니다. tty: 터미널과 관련된 작업을 할 때 사용합니다. v8: v8 엔진에 직접 접근할 때 사용합니다. vm: 가상 머신에 직접 접근할 때 사용합니다. wasi: 웹어셈블리를 실행할 때 사용하는 실험적인 모듈입니다. 4) fs (●●●) # 파일 시스템에 접근하는 모듈 웹 브라우저에서는 제한적이나 노드는 권한을 지니고 있음 파일의 경로는 현재 파일 기준이 아니라 node 명령어를 실행하는 콘솔 기준 1. 비동기 메서드 # fs.readFile(경로, 콜백) \u0026amp; fs.writeFile(경로, 내용, 콜백) const fs = require(\u0026#34;fs\u0026#34;); fs.writeFile(\u0026#34;./writeme.txt\u0026#34;, \u0026#34;글이 입력됩니다\u0026#34;, (err) =\u0026gt; { if (err) { throw err; } fs.readFile(\u0026#34;./writeme.txt\u0026#34;, (err, data) =\u0026gt; { if (err) { throw err; } console.log(data.toString()); }); }); 2. 동기 메서드 # fs.readFileSync(경로, 콜백) \u0026amp; writeFileSync(경로, 내용, 콜백) const fs = require(\u0026#34;fs\u0026#34;); console.log(\u0026#34;시작\u0026#34;); let data = fs.readFileSync(\u0026#34;./readme2.txt\u0026#34;); console.log(\u0026#34;1번\u0026#34;, data.toString()); data = fs.readFileSync(\u0026#34;./readme2.txt\u0026#34;); console.log(\u0026#34;2번\u0026#34;, data.toString()); data = fs.readFileSync(\u0026#34;./readme2.txt\u0026#34;); console.log(\u0026#34;3번\u0026#34;, data.toString()); console.log(\u0026#34;끝\u0026#34;); 요청이 많을 때 비효율적임 프로그램을 처음 실행할 때 초기화 용도로만 사용하는 것을 권장 3. 비동기 메서드로 순서 유지 # .promises const fs = require(\u0026#34;fs\u0026#34;).promises; console.log(\u0026#34;시작\u0026#34;); fs.readFile(\u0026#34;./readme2.txt\u0026#34;) .then((data) =\u0026gt; { console.log(\u0026#34;1번\u0026#34;, data.toString()); return fs.readFile(\u0026#34;./readme2.txt\u0026#34;); }) .then((data) =\u0026gt; { console.log(\u0026#34;2번\u0026#34;, data.toString()); return fs.readFile(\u0026#34;./readme2.txt\u0026#34;); }) .then((data) =\u0026gt; { console.log(\u0026#34;3번\u0026#34;, data.toString()); console.log(\u0026#34;끝\u0026#34;); }) .catch((err) =\u0026gt; { console.error(err); }); 4. 버퍼 # 일정한 크기로 모아두는 데이터 일정한 크기가 되면 한 번에 처리 메모리 문제가 생길 수 있음 버퍼에 데이터가 찰 때까지 모으는 작업을 버퍼링이라고 함 Properties \u0026amp; Methods Return Buffer.length 버퍼의 크기(byte) Buffer.from(문자열) 문자열로 만든 버퍼 Buffer.toString() 버퍼로 만든 문자열 Buffer.concat(배열) 배열안의 버퍼를 합쳐서 만든 버퍼 Buffer.alloc(바이트) 해당 바이트의 크기를 지니는 빈 버퍼 const buffer = Buffer.from(\u0026#34;저를 버퍼로 바꿔보세요\u0026#34;); console.log(\u0026#34;from():\u0026#34;, buffer); console.log(\u0026#34;length:\u0026#34;, buffer.length); console.log(\u0026#34;toString():\u0026#34;, buffer.toString()); const array = [ Buffer.from(\u0026#34;띄엄 \u0026#34;), Buffer.from(\u0026#34;띄엄 \u0026#34;), Buffer.from(\u0026#34;띄어쓰기\u0026#34;), ]; const buffer2 = Buffer.concat(array); console.log(\u0026#34;concat():\u0026#34;, buffer2.toString()); const buffer3 = Buffer.alloc(5); console.log(\u0026#34;alloc():\u0026#34;, buffer3); from(): \u0026lt;Buffer ec a0 80 eb a5 bc 20 eb b2 84 ed 8d bc eb a1 9c 20 eb b0 94 ea bf 94 eb b3 b4 ec 84 b8 ec 9a 94\u0026gt; length: 32 toString(): 저를 버퍼로 바꿔보세요 concat(): 띄엄 띄엄 띄어쓰기length alloc(): \u0026lt;Buffer 00 00 00 00 00\u0026gt; 5. 스트림 # 데이터의 흐름\n일정한 크기로 나눠서 여러 번에 걸쳐서 처리\n버퍼(청크)의 크기를 작게 만들어서 주기적으로 데이터를 전달\n일정한 크기의 데이터를 지속적으로 전달하는 작업을 스트림이라고 함\nfs.createReadStream(경로, 옵션)\nhighWaterMark 옵션은 버퍼의 크기(바이트 단위, 기본값 64KB) data[chunk 전달], end[전달 완료], error[에러 발생] 이벤트 리스너와 같이 사용 저는 조금씩 조금씩 나눠서 전달됩니다. 나눠진 조각을 chunk라고 부릅니다. const fs = require(\u0026#34;fs\u0026#34;); const readStream = fs.createReadStream(\u0026#34;./readme3.txt\u0026#34;, { highWaterMark: 16, }); const data = []; readStream.on(\u0026#34;data\u0026#34;, (chunk) =\u0026gt; { data.push(chunk); console.log(\u0026#34;data :\u0026#34;, chunk, chunk.length); }); readStream.on(\u0026#34;end\u0026#34;, () =\u0026gt; { console.log(\u0026#34;end :\u0026#34;, Buffer.concat(data).toString()); }); readStream.on(\u0026#34;error\u0026#34;, (err) =\u0026gt; { console.log(\u0026#34;error :\u0026#34;, err); }); data : \u0026lt;Buffer ec a0 80 eb 8a 94 20 ec a1 b0 ea b8 88 ec 94 a9\u0026gt; 16 data : \u0026lt;Buffer 20 ec a1 b0 ea b8 88 ec 94 a9 20 eb 82 98 eb 88\u0026gt; 16 data : \u0026lt;Buffer a0 ec 84 9c 20 ec a0 84 eb 8b ac eb 90 a9 eb 8b\u0026gt; 16 data : \u0026lt;Buffer 88 eb 8b a4 2e 20 eb 82 98 eb 88 a0 ec a7 84 20\u0026gt; 16 data : \u0026lt;Buffer ec a1 b0 ea b0 81 ec 9d 84 20 63 68 75 6e 6b eb\u0026gt; 16 data : \u0026lt;Buffer 9d bc ea b3 a0 20 eb b6 80 eb a6 85 eb 8b 88 eb\u0026gt; 16 data : \u0026lt;Buffer 8b a4 2e\u0026gt; 3 end : 저는 조금씩 조금씩 나눠서 전달됩니다. 나눠진 조각을 chunk라고 부릅니다. fs.createWriteStream(경로)\n.write(chunk)로 쓰고 .end()로 종료 finish[종료] 이벤트 리스너와 같이 사용 const fs = require(\u0026#34;fs\u0026#34;); const writeStream = fs.createWriteStream(\u0026#34;./writeme2.txt\u0026#34;); writeStream.on(\u0026#34;finish\u0026#34;, () =\u0026gt; { console.log(\u0026#34;파일 쓰기 완료\u0026#34;); }); writeStream.write(\u0026#34;이 글을 씁니다.\u0026#34;); writeStream.write(\u0026#34;한 번 더 씁니다.\u0026#34;); writeStream.end(); 파일 쓰기 완료 이 글을 씁니다. 한 번 더 씁니다. 6. 파이프 # 스트림.pipe(스트림)\nconst fs = require(\u0026#34;fs\u0026#34;); const readStream = fs.createReadStream(\u0026#34;readme4.txt\u0026#34;); const writeStream = fs.createWriteStream(\u0026#34;writeme3.txt\u0026#34;); readStream.pipe(writeStream); const zlib = require(\u0026#34;zlib\u0026#34;); const fs = require(\u0026#34;fs\u0026#34;); const readStream = fs.createReadStream(\u0026#34;./readme4.txt\u0026#34;); const zlibStream = zlib.createGzip(); const writeStream = fs.createWriteStream(\u0026#34;./readme4.txt.gz\u0026#34;); readStream.pipe(zlibStream).pipe(writeStream); await pipeline(스트림, ..., { signal })\nAbortController를 사용해 원할 때 파이프를 중단할 수 있음 import { pipeline } from \u0026#34;stream/promises\u0026#34;; import zlib from \u0026#34;zlib\u0026#34;; import fs from \u0026#34;fs\u0026#34;; const ac = new AbortController(); const signal = ac.signal; setTimeout(() =\u0026gt; ac.abort(), 1); // 1ms 뒤에 중단 await pipeline( fs.createReadStream(\u0026#34;./readme4.txt\u0026#34;), zlib.createGzip(), fs.createWriteStream(\u0026#34;./readme4.txt.gz\u0026#34;), { signal } ); 7. 기타 fs 메서드 # Methods Details fs.access(경로, 옵션, 콜백) 파일/폴더에 접근할 수 있는지 여부 체크*옵션은 constants로 가져옴(F_OK는 파일 존재 여부, R_OK는 읽기 권한 여부, W_OK는 쓰기 권한 여부)*파일/폴더가 없을 때의 에러 코드는 ENOENT fs.mkdir(경로, 콜백) 폴더를 만듦*이미 폴더가 있으면 에러가 발생하므로 먼저 access 메서드를 호출해서 확인하는 것이 중요 fs.open(경로, 옵션, 콜백) 파일의 아이디(fd 변수)를 가져옴*파일이 없으면 파일을 생성한 뒤 그 아이디를 가져옴*가져온 아이디를 사용해 fs.read 또는 fs.write 사용 가능*옵션으로 어떤 동작을 할 것인지를 설정할 수 있음(쓰려면 w, 읽으려면 r, 기존 파일에 추가하려면 a) fs.rename(기존 경로, 새 경로, 콜백) 파일의 위치 or 이름 변경 fs.readdir(경로, 콜백) 폴더 안의 내용물 확인, 배열 안에 내부의 파일명과 폴더명이 담김 fs.unlink(경로, 콜백) 파일을 지움*파일이 없으면 에러 발생 fs.rmdir(경로, 콜백) 폴더를 지움*폴더 안에 파일들이 있으면 에러가 발생하므로 먼저 내부 파일을 모두 지우고 호출해야 함 fs.copyFile(복사할 경로, 복사될 경로, 콜백) 파일 복사 fs.watch(감시할 경로, 콜백(eventType, filename)) 파일/폴더의 변경 사항 감지 fs.exists(경로, 콜백) 파일/폴더 존재 여부 체크 fs.stat(경로, 콜백) 파일/폴더 정보 확인 const fs = require(\u0026#34;fs\u0026#34;).promises; const constants = require(\u0026#34;fs\u0026#34;).constants; fs.access( \u0026#34;./folder/file.txt\u0026#34;, constants.F_OK | constants.W_OK | constants.R_OK ) .then(() =\u0026gt; { console.log(\u0026#34;파일 있음\u0026#34;); return fs.unlink(\u0026#34;./folder/file.txt\u0026#34;); }) .catch((err) =\u0026gt; { if (err.code === \u0026#34;ENOENT\u0026#34;) { console.log(\u0026#34;파일 없음\u0026#34;); return fs.writeFile(\u0026#34;./folder/file.txt\u0026#34;, \u0026#34;asdasd\u0026#34;); } }); const fs = require(\u0026#34;fs\u0026#34;).promises; const constants = require(\u0026#34;fs\u0026#34;).constants; fs.access(\u0026#34;./folder\u0026#34;, constants.F_OK | constants.W_OK | constants.R_OK) .then(() =\u0026gt; { return Promise.reject(\u0026#34;이미 폴더 있음\u0026#34;); }) .catch((err) =\u0026gt; { if (err.code === \u0026#34;ENOENT\u0026#34;) { console.log(\u0026#34;폴더 없음\u0026#34;); return fs.mkdir(\u0026#34;./folder\u0026#34;); } return Promise.reject(err); }) .then(() =\u0026gt; { console.log(\u0026#34;폴더 만들기 성공\u0026#34;); return fs.open(\u0026#34;./folder/file.js\u0026#34;, \u0026#34;w\u0026#34;); // r이나 a를 사용했으면 에러 발생 }) .then((fd) =\u0026gt; { console.log(\u0026#34;빈 파일 만들기 성공\u0026#34;, fd); return fs.rename(\u0026#34;./folder/file.js\u0026#34;, \u0026#34;./folder/newfile.js\u0026#34;); }) .then(() =\u0026gt; { console.log(\u0026#34;이름 바꾸기 성공\u0026#34;); }) .catch((err) =\u0026gt; { console.error(err); }); $ node fsCreate 폴더 없음 폴더 만들기 성공 빈 파일 만들기 성공 3 이름 바꾸기 성공 $ node fsCreate 이미 폴더 있음 const fs = require(\u0026#34;fs\u0026#34;).promises; fs.readdir(\u0026#34;./folder\u0026#34;) .then((dir) =\u0026gt; { console.log(\u0026#34;폴더 내용 확인\u0026#34;, dir); return fs.unlink(\u0026#34;./folder/newfile.js\u0026#34;); }) .then(() =\u0026gt; { console.log(\u0026#34;파일 삭제 성공\u0026#34;); return fs.rmdir(\u0026#34;./folder\u0026#34;); }) .then(() =\u0026gt; { console.log(\u0026#34;폴더 삭제 성공\u0026#34;); }) .catch((err) =\u0026gt; { console.error(err); }); 폴더 내용 확인 [ \u0026#39;newfile.js\u0026#39; ] 파일 삭제 성공 폴더 삭제 성공 const fs = require(\u0026#34;fs\u0026#34;); fs.watch(\u0026#34;./target.txt\u0026#34;, (eventType, filename) =\u0026gt; { console.log(eventType, filename); }); // 내용물 수정 후 change target.txt change target.txt // 파일명 변경 또는 파일 삭제 후 rename target.txt // rename 이벤트가 발생한 후에는 더 이상 watch가 수행되지 않음 // change 이벤트가 두 번씩 발생하기도 하므로 실무에서 사용할 때는 주의가 필요 const fs = require(\u0026#34;fs\u0026#34;).promises; async function example() { try { const stats = await fs.stat(\u0026#34;/Users/joe/test.txt\u0026#34;); stats.isFile(); // true stats.isDirectory(); // false stats.isSymbolicLink(); // false stats.size; // 1024000 //= 1MB } catch (err) { console.log(err); } } example(); 5) 기타 #1. events (●○○) # Methods Details on(이벤트명, 콜백) 이벤트명과 이벤트 발생 시의 콜백 연결 addListener(이벤트명, 콜백) on과 동일 emit(이벤트명) 이벤트 호출 once(이벤트명, 콜백) 한 번만 실행되는 이벤트 등록 removeAllListeners(이벤트명) 이벤트명에 연결된 모든 이벤트 리스너 제거 removeListener(이벤트명) 이벤트에 연결된 리스너를 하나씩 제거 off(이벤트명, 콜백) removeListener와 동일 listenerCount(이벤트명) 현재 연결된 리스너 개수 확인 const EventEmitter = require(\u0026#34;events\u0026#34;); const myEvent = new EventEmitter(); myEvent.addListener(\u0026#34;event1\u0026#34;, () =\u0026gt; { console.log(\u0026#34;이벤트 1\u0026#34;); }); myEvent.on(\u0026#34;event2\u0026#34;, () =\u0026gt; { console.log(\u0026#34;이벤트 2\u0026#34;); }); myEvent.on(\u0026#34;event2\u0026#34;, () =\u0026gt; { console.log(\u0026#34;이벤트 2 추가\u0026#34;); }); myEvent.once(\u0026#34;event3\u0026#34;, () =\u0026gt; { console.log(\u0026#34;이벤트 3\u0026#34;); }); // 한 번만 실행됨 myEvent.emit(\u0026#34;event1\u0026#34;); // 이벤트 호출 myEvent.emit(\u0026#34;event2\u0026#34;); // 이벤트 호출 myEvent.emit(\u0026#34;event3\u0026#34;); myEvent.emit(\u0026#34;event3\u0026#34;); // 실행 안 됨 myEvent.on(\u0026#34;event4\u0026#34;, () =\u0026gt; { console.log(\u0026#34;이벤트 4\u0026#34;); }); myEvent.removeAllListeners(\u0026#34;event4\u0026#34;); myEvent.emit(\u0026#34;event4\u0026#34;); // 실행 안 됨 const listener = () =\u0026gt; { console.log(\u0026#34;이벤트 5\u0026#34;); }; myEvent.on(\u0026#34;event5\u0026#34;, listener); myEvent.removeListener(\u0026#34;event5\u0026#34;, listener); myEvent.emit(\u0026#34;event5\u0026#34;); // 실행 안 됨 console.log(myEvent.listenerCount(\u0026#34;event2\u0026#34;)); 이벤트 1 이벤트 2 이벤트 2 추가 이벤트 3 2 2. 에러 핸들링 # 기본적으로 try catch 문으로 예외를 처리\n노드 내장 모듈의 에러는 실행 중인 프로세스를 멈추지 않음\n프로미스의 에러와 throw 된 에러는 반드시 catch 해야 함\nuncaughtException\n노드 공식 문서에서는 uncaughtException 이벤트를 최후의 수단으로 사용할 것을 명시 노드는 uncaughtException 이벤트 발생 후 다음 동작이 제대로 동작하는지를 보증하지 않음 uncaughtException은 단순히 에러 내용을 기록하는 정도로 사용하고, 에러를 기록한 후 process.exit()으로 프로세스를 종료하는 것이 좋음 process.on(\u0026#34;uncaughtException\u0026#34;, (err) =\u0026gt; { console.error(\u0026#34;예기치 못한 에러\u0026#34;, err); }); setInterval(() =\u0026gt; { throw new Error(\u0026#34;서버를 고장내주마!\u0026#34;); }, 1000); setTimeout(() =\u0026gt; { console.log(\u0026#34;실행됩니다\u0026#34;); }, 2000); 자주 발생하는 에러들\nError Code Details node: command not found 노드를 설치했지만 이 에러가 발생하는 경우는 환경 변수가 제대로 설정되어 있지 않은 것환경 변수에는 노드가 설치된 경로가 포함되어야 함 ReferenceError: [모듈] is not defined 모듈을 require하지 않음 Error: Cannot find module [모듈명] 해당 모듈을 require했지만 설치하지 않음 Error [ERR_MODULE_NOT_FOUND] 존재하지 않는 모듈을 불러오려 함 Error: Can\u0026rsquo;t set headers after they are sent 응답을 두 번 이상 보냄 FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed- JavaScript heap out of memory 메모리가 부족해서 스크립트가 정상적으로 작동하지 않음1. 코드 점검2. node --max-old-space-size=4096 파일명과 같은 명령어로 노드 메모리를 늘림 UnhandledPromiseRejectionWarning: Unhandled promise rejection 프로미스 사용 시 catch 메서드를 붙이지 않음 EADDRINUSE [포트 번호] 해당 포트 번호에 이미 다른 프로세스가 연결되어 있음 EACCES 또는 EPERM 노드가 작업을 수행하는 데 권한이 충분하지 않음 EJSONPARSE package.json 등의 JSON 파일에 문법 오류가 있을 때 발생 ECONNREFUSED 요청을 보냈으나 연결이 성립하지 않을 때 발생 ETARGET package.json에 기록한 패키지 버전이 존재하지 않을 때 발생 ETIMEOUT 요청을 보냈으나 응답이 시간 내에 오지 않을 때 발생 ENOENT: no such file or directory 지정한 폴더나 파일이 존재하지 않는 경우 맥/리눅스에서 프로세스 종료하기\nlsof -i tcp:[포트] kill -9 [프로세스아이디] Reference.\nhttps://nodejs.org/en/docs https://nodejs.org/dist/latest-v18.x/docs/api/cli.html#cli_node_options_options https://nodejs.org/dist/latest-v18.x/docs/api/cli.html#cli_uv_threadpool_size_size https://nodejs.org/dist/latest-v18.x/docs/api/errors.html#errors_node_js_error_codes https://nodejs.org/dist/latest-v18.x/docs/api/process.html#process_event_uncaughtexception https://thebook.io/080334/0122/ https://nodejs.org/api/crypto.html https://www.npmjs.com/package/crypto-js (SHA512(단반향), AES(대칭), RSA(비대칭) 사용 추천) https://stackoverflow.com/questions/48698234/node-js-spawn-vs-execute ","date":"5 April 2023","permalink":"/posts/lectures/node.js-%EA%B5%90%EA%B3%BC%EC%84%9C/2/","section":"Posts","summary":"제 3장.","title":"[Node.js 교과서] Node.js의 기능"},{"content":"","date":null,"permalink":"/categories/%5Clectures/","section":"Categories","summary":"","title":"\\lectures"},{"content":"","date":null,"permalink":"/tags/node.js/","section":"Tags","summary":"","title":"node.js"},{"content":"","date":null,"permalink":"/tags/node.js-%EA%B5%90%EA%B3%BC%EC%84%9C/","section":"Tags","summary":"","title":"Node.js 교과서"},{"content":"","date":null,"permalink":"/tags/%EC%A1%B0%ED%98%84%EC%98%81zerocho/","section":"Tags","summary":"","title":"조현영(zerocho)"},{"content":"제 1장. Node.js란 #1) 노드의 정의 # Chrome V8 엔진[1]으로 빌드된 자바스크립트 런타임 환경[2] libuv[3]를 내장 [1] Chrome V8 엔진: C++로 작성된 오픈소스 자바스크립트 엔진, 자바스크립트 코드를 기계어로 변환하여 실행시키는 JIT 컴파일러를 내장, 가비지 컬렉터를 내장하고 있어 메모리 관리에 대한 개발자의 부담을 덜어줌\n[2] 런타임 환경: 응용 프로그램이 운영체제(OS)의 시스템 리소스(e.g. RAM, 시스템 변수, 환경 변수)에 엑세스 할 수 있도록 해주는 실행 환경\n[3] libuv: 이벤트 기반의 비동기 I/O 라이브러리, 이벤트 루프 제공\n2) 노드의 특성 # 이벤트 기반 이벤트 리스너에 콜백 함수를 등록해서 이벤트(e.g. 클릭, 네트워크 요청, 타이머) 발생 시 미리 지정해둔 작업 수행 None-Blocking I/O 일부 코드(e.g. I/O 작업(파일 시스템 접근, 네트워크 요청), 압축, 암호화)는 백그라운드(다른 프로세스)에서 논-블로킹으로 실행 나머지 코드는 블로킹으로 실행 즉, I/O 작업이 많을 때 노드 활용성이 극대화 Single Tread 노드 프로세스는 멀티 스레드지만 직접 다룰 수 있는 스레드는 하나라서 싱글 스레드라고 표현 노드 14 버전부터 worker threads 모듈로 멀티 스레드 사용 가능 *프로세스 vs 스레드\n프로세스: 운영체제에서 할당하는 작업의 단위, 프로세스 간 리소스 공유 X 스레드: 프로세스 내에서 실행되는 작업의 단위, 부모 프로세스의 리소스 공유 O *멀티 프로세싱 vs 멀티 스레딩\n멀티 프로세싱: 여러 개의 프로세스 사용, I/O 요청이 많을 때 사용, 프로그래밍이 쉬움, 리소스를 적게 사용 멀티 스레딩: 하나의 프로세스 안에서 여러개의 스레드 사용, CPU 작업이 많을 때 사용, 프로그래밍이 어려움, 리소스를 많이 사용 3) 노드로 만든 서버 # 장점 단점 I/O 작업이 많은 서버에 적합 CPU 작업이 많은 서버에 부적합 리소스를 적게 사용 하나뿐인 스레드가 멈추지 않도록 관리 필요 프로그래밍이 쉬움 어중간한 성능 웹 서버 내장 JSON 형식과 호환이 쉬움 *CPU 작업을 위해 AWS Lamda, Google Cloud Functions 같은 별도 서비스 사용 권장\n4) 콜 스택과 이벤트 루프 # 콜 스택\n가장 먼저 anonymous[1]가 쌓임 호출 순서대로 쌓이고, 역순으로 실행 이벤트 루프\n콜 스택에 쌓인 함수 중 논-블로킹으로 실행되는 함수들[2]을 백그라운드로 보냄 백그라운드에서 해당 함수가 완료되면 태스크 큐로 이동해서 대기 콜 스택이 비는 순간 이벤트 루프가 콜 스택으로 태스크를 이동 시켜서 실행 매크로 태스크[3] 큐(이벤트 큐, 콜백 큐)에서 가장 오래된 태스크를 실행 마이크로 태스크[4] 큐(잡 큐)의 모든 태스크를 오래된 순으로 실행 랜더링 매크로 태스크 큐 확인 및 대기 console.log(\u0026#34;script start\u0026#34;); setTimeout(function () { console.log(\u0026#34;setTimeout\u0026#34;); }, 0); Promise.resolve() .then(function () { console.log(\u0026#34;promise1\u0026#34;); }) .then(function () { console.log(\u0026#34;promise2\u0026#34;); }); console.log(\u0026#34;script end\u0026#34;); # console.log script start script end promise1 promise2 setTimeout *여기서 setTimeout이 첫 번째 매크로 태스크가 아니라 실행중인 스크립트(이벤트)가 첫 번째 매크로 태스크 (JS에서는 이벤트가 발생하지 않으면 코드가 실행되지 않기 때문)\n[1] anonymous: 모듈 스코프 외부에서 선언된 변수, 전역 변수로 취급\n[2] 논-블로킹으로 실행되는 함수들: 타이머 함수, 파일 시스템 접근(fs), 네트워크 요청, 압축(zlib), 암호화(crypto)\n[3] 매크로 태스크: requestAnimationFrame, I/O, UI rendering, setTimeout, setInterval, setImmediate\n[4] 마이크로 태스크: process.nextTick, Promises, queueMicrotask(f), MutationObserver\n*백그라운드와 태스크 큐는 자바스크립트가 아님\n*프로미스 내부는 동기, then/catch/finally는 비동기\n제 2장. Javascript 기초 # JS 기본 문법은 다음 포스팅에 정리. \u0026ldquo;Javascript\u0026rdquo; 부록 #CLI # Command Details node -v node 버전 nvm -v nvm 버전 nvm install [version] 특정 버전 node 설치 nvm uninstall [version] 특정 버전 node 삭제 nvm ls node 목록 nvm use [version] 특정 버전 node 사용 sudo npm i -g npm npm 업데이트 강사 어록 # 생각의 비중이 높아야 한다. 그렇지 않다면 가치가 크지 않은 일을 하고 있을 가능성이 크다.\nReference.\nhttps://blog.bitsrc.io/microtask-and-macrotask-a-hands-on-approach-5d77050e2168 https://ko.javascript.info/ ","date":"2 April 2023","permalink":"/posts/lectures/node.js-%EA%B5%90%EA%B3%BC%EC%84%9C/1/","section":"Posts","summary":"제 1장.","title":"[Node.js 교과서] Node.js란"},{"content":"","date":null,"permalink":"/tags/react/","section":"Tags","summary":"","title":"React"},{"content":"배경 #새로 진행하고 있는 B2B 프로젝트에 글로벌 진출 기회가 생겨서 다국어 처리를 할 필요가 생겼다.\n검색 결과 리액트에서 다국어 처리를 할 때는 보통 react-i18next나 react-intl을 사용하고 있었다. react-i18next는 번역에만 충실하나 후에 SSR이 필요할 때 next-i18next로 쉽게 전환할 수 있는 장점이 있었고, react-intl은 날짜, 시간, 숫자 등의 포멧팅을 지원하는 장점이 있었다.\n둘 다 이미 많은 사용자를 지니고 있어서 안정성은 확보되었다고 판단했고, 특별한 차이점도 없었기 때문에 npm trends와 npm compare에서 최근 결과가 더 좋은 react-i18next를 도입하기로 결정했다.\n도입 #구글 스프레드 시트 연동\nhttps://console.cloud.google.com/apis/dashboard 사용자 인증 정보(Credentials) -\u0026gt; 사용자 인증 정보 만들기(CREATE CREDENTIALS) -\u0026gt; 서비스 계정(Service account) 서비스 계정(Service Accounts)에서 방금 생성한 계정 클릭 키(KEYS) 탭에서 JSON 파일로 새 키 만들기 세부정보(DETAILS) 탭에서 이메일 복사 후 구글 스프레드 시트에서 공유 설정 설치\nyarn add react-i18next i18next @types/react-i18next @types/i18next i18next-scanner google-spreadsheet 설정\nsrc/i18n/index.ts\rimport i18n from \u0026#34;i18next\u0026#34;; import { initReactI18next } from \u0026#34;react-i18next\u0026#34;; import { platform } from \u0026#34;modules/native\u0026#34;; import enUS from \u0026#34;./locales/en-US/translation.json\u0026#34;; import esES from \u0026#34;./locales/es-ES/translation.json\u0026#34;; import jaJP from \u0026#34;./locales/ja-JP/translation.json\u0026#34;; import koKR from \u0026#34;./locales/ko-KR/translation.json\u0026#34;; import viVN from \u0026#34;./locales/vi-VN/translation.json\u0026#34;; //*i18next: 언어 추가 시 작성 필요 const RESOURCES = { ko: { translation: koKR }, en: { translation: enUS }, ja: { translation: jaJP }, vi: { translation: viVN }, es: { translation: esES }, } as const; export type TLanguageCode = keyof typeof RESOURCES; export type TLanguageName = | \u0026#34;한국어\u0026#34; | \u0026#34;English\u0026#34; | \u0026#34;日本語\u0026#34; | \u0026#34;Tiếng Việt\u0026#34; | \u0026#34;español\u0026#34;; export type TLanguage = [TLanguageCode, TLanguageName]; export const LANGUAGES: TLanguage[] = [ [\u0026#34;ko\u0026#34;, \u0026#34;한국어\u0026#34;], [\u0026#34;en\u0026#34;, \u0026#34;English\u0026#34;], [\u0026#34;ja\u0026#34;, \u0026#34;日本語\u0026#34;], [\u0026#34;vi\u0026#34;, \u0026#34;Tiếng Việt\u0026#34;], [\u0026#34;es\u0026#34;, \u0026#34;español\u0026#34;], ]; const browserLang = window.navigator.language.split(\u0026#34;-\u0026#34;)[0]; export const CURRENT_LANGUAGE = \u0026#34;withbecon_language\u0026#34;; const userLanguage = platform !== \u0026#34;web\u0026#34; ? browserLang : localStorage.getItem(CURRENT_LANGUAGE) || browserLang; i18n.use(initReactI18next).init({ resources: RESOURCES, lng: userLanguage, fallbackLng: \u0026#34;en\u0026#34;, debug: false, defaultNS: \u0026#34;translation\u0026#34;, ns: \u0026#34;translation\u0026#34;, keySeparator: false, interpolation: { escapeValue: true, alwaysFormat: true, format(value, format, lng) { if (format === \u0026#34;uppercase\u0026#34;) return value.toUpperCase(); if (typeof value === \u0026#34;number\u0026#34;) return value.toLocaleString(lng); return value; }, }, react: { defaultTransParent: \u0026#34;div\u0026#34;, transEmptyNodeValue: \u0026#34;\u0026#34;, transSupportBasicHtmlNodes: true, transKeepBasicHtmlNodesFor: [ \u0026#34;br\u0026#34;, \u0026#34;strong\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;button\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;span\u0026#34;, \u0026#34;div\u0026#34;, \u0026#34;input\u0026#34;, ], transWrapTextNodes: \u0026#34;\u0026#34;, }, nsSeparator: \u0026#34;=\u0026gt;\u0026#34;, // default: \u0026#34;:\u0026#34; returnNull: false, returnEmptyString: false, }); export default i18n; export interface Ii18Next { // eslint-disable-next-line @typescript-eslint/ban-types t: (str: string, option?: Object) =\u0026gt; string; } export const i18nextScanKey = (key: string): string =\u0026gt; key; i18next-scanner.config.js\r/* eslint-disable import/order */ /* eslint-disable no-undef */ /* eslint-disable @typescript-eslint/no-var-requires */ const fs = require(\u0026#34;fs\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const typescript = require(\u0026#34;typescript\u0026#34;); const COMMON_EXTENSIONS = \u0026#34;/**/*.{js,jsx,ts,tsx,vue,html}\u0026#34;; module.exports = { input: [`./src/${COMMON_EXTENSIONS}`], options: { debug: true, removeUnusedKeys: true, defaultLng: \u0026#34;ko-KR\u0026#34;, //*i18next: 언어 추가 시 작성 필요 lngs: [\u0026#34;ko-KR\u0026#34;, \u0026#34;ko-KR\u0026#34;, \u0026#34;en-US\u0026#34;, \u0026#34;ja-JP\u0026#34;, \u0026#34;vi-VN\u0026#34;, \u0026#34;es-ES\u0026#34;], func: { list: [\u0026#34;i18next.t\u0026#34;, \u0026#34;i18n.t\u0026#34;, \u0026#34;$i18n.t\u0026#34;, \u0026#34;$i18next.t\u0026#34;, \u0026#34;i18nextScanKey\u0026#34;], extensions: [\u0026#34;.js\u0026#34;, \u0026#34;.jsx\u0026#34;], }, trans: { component: \u0026#34;Trans\u0026#34;, i18nKey: \u0026#34;i18nKey\u0026#34;, defaultsKey: \u0026#34;defaults\u0026#34;, extensions: [\u0026#34;.js\u0026#34;, \u0026#34;.jsx\u0026#34;], fallbackKey: function (ns, value) { return value; }, acorn: { ecmaVersion: 10, sourceType: \u0026#34;module\u0026#34;, }, }, resource: { loadPath: path.join(__dirname, \u0026#34;/src/i18n/locales/{{lng}}/{{ns}}.json\u0026#34;), savePath: path.join(__dirname, \u0026#34;/src/i18n/locales/{{lng}}/{{ns}}.json\u0026#34;), }, defaultValue(lng, ns, key) { const keyAsDefaultValue = [\u0026#34;ko-KR\u0026#34;]; if (keyAsDefaultValue.includes(lng)) { const separator = \u0026#34;html\u0026#34;; const value = key.includes(separator) ? \u0026#34;\u0026#34; : key; return value; } return \u0026#34;\u0026#34;; }, keySeparator: false, nsSeparator: false, prefix: \u0026#34;{{\u0026#34;, suffix: \u0026#34;}}\u0026#34;, }, transform: (function typescriptTransform( options = { tsOptions: { target: \u0026#34;es2018\u0026#34;, }, extensions: [\u0026#34;.ts\u0026#34;, \u0026#34;.tsx\u0026#34;], } ) { return function transform(file, enc, done) { const { base, ext } = path.parse(file.path); if ( options.extensions.includes(ext) \u0026amp;\u0026amp; !base.endsWith(\u0026#34;.d.ts\u0026#34;) \u0026amp;\u0026amp; base.indexOf(\u0026#34;reportWebVitals.ts\u0026#34;) === -1 ) { const content = fs.readFileSync(file.path, enc); const { outputText } = typescript.transpileModule(content, { compilerOptions: options.tsOptions, fileName: path.basename(file.path), }); this.parser.parseTransFromString(outputText); this.parser.parseFuncFromString(outputText); } done(); }; })({ extensions: [\u0026#34;.tsx\u0026#34;, \u0026#34;.ts\u0026#34;], tsOptions: { target: \u0026#34;es5\u0026#34;, module: \u0026#34;esnext\u0026#34;, }, }), }; translate/.credentials/...\r.gitignore에 translate/.credentials 추가 서비스 계정에서 받은 JSON 키 파일을 translate/.credentials에 저장 translate/.credentials/index.js module.exports = { CREDS: \u0026#34;서비스 계정에서 받은 JSON 키 파일 이름\u0026#34;, // 구글 스프레드 시트 주소에 나와 있음 SHEET_DOC_ID: \u0026#34;...\u0026#34;, SHEET_ID: \u0026#34;...\u0026#34;, }; translate/index.js\r/* eslint-disable import/order */ /* eslint-disable no-undef */ /* eslint-disable @typescript-eslint/no-var-requires */ const { GoogleSpreadsheet } = require(\u0026#34;google-spreadsheet\u0026#34;); const ENV = require(\u0026#34;./.credentials/index.js\u0026#34;); const creds = require(\u0026#34;./.credentials/\u0026#34; + ENV.CREDS); const i18nextConfig = require(\u0026#34;../i18next-scanner.config\u0026#34;); const spreadsheetDocId = ENV.SHEET_DOC_ID; const ns = \u0026#34;translation\u0026#34;; const lngs = i18nextConfig.options.lngs; const loadPath = i18nextConfig.options.resource.loadPath; const localesPath = loadPath.replace(\u0026#34;/{{lng}}/{{ns}}.json\u0026#34;, \u0026#34;\u0026#34;); const rePluralPostfix = new RegExp(/_plural|_[\\d]/g); const sheetId = ENV.SHEET_ID; const NOT_AVAILABLE_CELL = \u0026#34;_N/A\u0026#34;; //*i18next: 언어 추가 시 작성 필요 const columnKeyToHeader = { key: \u0026#34;key\u0026#34;, \u0026#34;ko-KR\u0026#34;: \u0026#34;ko-KR\u0026#34;, \u0026#34;en-US\u0026#34;: \u0026#34;en-US\u0026#34;, \u0026#34;ja-JP\u0026#34;: \u0026#34;ja-JP\u0026#34;, \u0026#34;vi-VN\u0026#34;: \u0026#34;vi-VN\u0026#34;, \u0026#34;es-ES\u0026#34;: \u0026#34;es-ES\u0026#34;, }; async function loadSpreadsheet() { // eslint-disable-next-line no-console console.info( \u0026#34;\\u001B[32m\u0026#34;, \u0026#34;=====================================================================================================================\\n\u0026#34;, \u0026#34;# i18next auto-sync using Spreadsheet\\n\\n\u0026#34;, \u0026#34; * Download translation resources from Spreadsheet and make /src/i18n/locales/{{lng}}/{{ns}}.json\\n\u0026#34;, \u0026#34; * Upload translation resources to Spreadsheet.\\n\\n\u0026#34;, `The Spreadsheet for translation is here (\\u001B[34mhttps://docs.google.com/spreadsheets/d/${spreadsheetDocId}/#gid=${sheetId}\\u001B[0m)\\n`, \u0026#34;=====================================================================================================================\u0026#34;, \u0026#34;\\u001B[0m\u0026#34; ); const doc = new GoogleSpreadsheet(spreadsheetDocId); await doc.useServiceAccountAuth(creds); await doc.loadInfo(); return doc; } function getPureKey(key = \u0026#34;\u0026#34;) { return key.replace(rePluralPostfix, \u0026#34;\u0026#34;); } module.exports = { localesPath, loadSpreadsheet, getPureKey, ns, lngs, sheetId, columnKeyToHeader, NOT_AVAILABLE_CELL, }; translate/upload.js\r/* eslint-disable no-undef */ /* eslint-disable @typescript-eslint/no-var-requires */ const fs = require(\u0026#34;fs\u0026#34;); const { loadSpreadsheet, localesPath, getPureKey, ns, lngs, sheetId, columnKeyToHeader, NOT_AVAILABLE_CELL, } = require(\u0026#34;./index\u0026#34;); //TODO-i18next: 언어 추가 시 작성 필요 const headerValues = [\u0026#34;key\u0026#34;, \u0026#34;ko-KR\u0026#34;, \u0026#34;en-US\u0026#34;, \u0026#34;ja-JP\u0026#34;, \u0026#34;vi-VN\u0026#34;, \u0026#34;es-ES\u0026#34;]; async function addNewSheet(doc, title, sheetId) { const sheet = await doc.addSheet({ sheetId, title, headerValues, }); return sheet; } async function updateTranslationsFromKeyMapToSheet(doc, keyMap) { const title = \u0026#34;시트 제목\u0026#34;; let sheet = doc.sheetsById[sheetId]; if (!sheet) { sheet = await addNewSheet(doc, title, sheetId); } const rows = await sheet.getRows(); const exsitKeys = {}; const addedRows = []; rows.forEach((row) =\u0026gt; { const key = row[columnKeyToHeader.key]; if (keyMap[key]) { exsitKeys[key] = true; } }); for (const [key, translations] of Object.entries(keyMap)) { if (!exsitKeys[key]) { const row = { [columnKeyToHeader.key]: key, ...Object.keys(translations).reduce((result, lng) =\u0026gt; { const header = columnKeyToHeader[lng]; result[header] = translations[lng]; return result; }, {}), }; addedRows.push(row); } } await sheet.addRows(addedRows); } function toJson(keyMap) { const json = {}; Object.entries(keyMap).forEach(([, keysByPlural]) =\u0026gt; { for (const [keyWithPostfix, translations] of Object.entries(keysByPlural)) { json[keyWithPostfix] = { ...translations, }; } }); return json; } function gatherKeyMap(keyMap, lng, json) { for (const [keyWithPostfix, translated] of Object.entries(json)) { const key = getPureKey(keyWithPostfix); if (!keyMap[key]) { keyMap[key] = {}; } const keyMapWithLng = keyMap[key]; if (!keyMapWithLng[keyWithPostfix]) { keyMapWithLng[keyWithPostfix] = lngs.reduce((initObj, lng) =\u0026gt; { initObj[lng] = NOT_AVAILABLE_CELL; return initObj; }, {}); } keyMapWithLng[keyWithPostfix][lng] = translated; } } async function updateSheetFromJson() { const doc = await loadSpreadsheet(); fs.readdir(localesPath, (error, lngs) =\u0026gt; { if (error) { throw error; } const keyMap = {}; lngs.forEach((lng) =\u0026gt; { const localeJsonFilePath = `${localesPath}/${lng}/${ns}.json`; // eslint-disable-next-line no-sync const json = fs.readFileSync(localeJsonFilePath, \u0026#34;utf8\u0026#34;); gatherKeyMap(keyMap, lng, JSON.parse(json)); }); updateTranslationsFromKeyMapToSheet(doc, toJson(keyMap)); }); } updateSheetFromJson(); /* eslint-disable no-undef */ /* eslint-disable @typescript-eslint/no-var-requires */ const fs = require(\u0026#34;fs\u0026#34;); const { loadSpreadsheet, localesPath, getPureKey, ns, lngs, sheetId, columnKeyToHeader, NOT_AVAILABLE_CELL, } = require(\u0026#34;./index\u0026#34;); //*i18next: 언어 추가 시 작성 필요 const headerValues = [\u0026#34;key\u0026#34;, \u0026#34;ko-KR\u0026#34;, \u0026#34;en-US\u0026#34;, \u0026#34;ja-JP\u0026#34;, \u0026#34;vi-VN\u0026#34;, \u0026#34;es-ES\u0026#34;]; async function addNewSheet(doc, title, sheetId) { const sheet = await doc.addSheet({ sheetId, title, headerValues, }); return sheet; } async function updateTranslationsFromKeyMapToSheet(doc, keyMap) { const title = \u0026#34;B2B\u0026#34;; let sheet = doc.sheetsById[sheetId]; if (!sheet) { sheet = await addNewSheet(doc, title, sheetId); } const rows = await sheet.getRows(); const exsitKeys = {}; const addedRows = []; rows.forEach((row) =\u0026gt; { const key = row[columnKeyToHeader.key]; if (keyMap[key]) { exsitKeys[key] = true; } }); for (const [key, translations] of Object.entries(keyMap)) { if (!exsitKeys[key]) { const row = { [columnKeyToHeader.key]: key, ...Object.keys(translations).reduce((result, lng) =\u0026gt; { const header = columnKeyToHeader[lng]; result[header] = translations[lng]; return result; }, {}), }; addedRows.push(row); } } await sheet.addRows(addedRows); } function toJson(keyMap) { const json = {}; Object.entries(keyMap).forEach(([, keysByPlural]) =\u0026gt; { for (const [keyWithPostfix, translations] of Object.entries(keysByPlural)) { json[keyWithPostfix] = { ...translations, }; } }); return json; } function gatherKeyMap(keyMap, lng, json) { for (const [keyWithPostfix, translated] of Object.entries(json)) { const key = getPureKey(keyWithPostfix); if (!keyMap[key]) { keyMap[key] = {}; } const keyMapWithLng = keyMap[key]; if (!keyMapWithLng[keyWithPostfix]) { keyMapWithLng[keyWithPostfix] = lngs.reduce((initObj, lng) =\u0026gt; { initObj[lng] = NOT_AVAILABLE_CELL; return initObj; }, {}); } keyMapWithLng[keyWithPostfix][lng] = translated; } } async function updateSheetFromJson() { const doc = await loadSpreadsheet(); fs.readdir(localesPath, (error, lngs) =\u0026gt; { if (error) { throw error; } const keyMap = {}; lngs.forEach((lng) =\u0026gt; { const localeJsonFilePath = `${localesPath}/${lng}/${ns}.json`; // eslint-disable-next-line no-sync const json = fs.readFileSync(localeJsonFilePath, \u0026#34;utf8\u0026#34;); gatherKeyMap(keyMap, lng, JSON.parse(json)); }); updateTranslationsFromKeyMapToSheet(doc, toJson(keyMap)); }); } updateSheetFromJson(); translate/download.js\r/* eslint-disable no-undef */ /* eslint-disable @typescript-eslint/no-var-requires */ const fs = require(\u0026#34;fs\u0026#34;); const mkdirp = require(\u0026#34;mkdirp\u0026#34;); const { loadSpreadsheet, localesPath, ns, lngs, sheetId, columnKeyToHeader, NOT_AVAILABLE_CELL, } = require(\u0026#34;./index\u0026#34;); /** * fetch translations from google spread sheet and transform to json * @param {GoogleSpreadsheet} doc GoogleSpreadsheet document * @returns [object] translation map * { * \u0026#34;ko-KR\u0026#34;: { * \u0026#34;key\u0026#34;: \u0026#34;value\u0026#34; * }, * \u0026#34;en-US\u0026#34;: { * \u0026#34;key\u0026#34;: \u0026#34;value\u0026#34; * }, * } */ async function fetchTranslationsFromSheetToJson(doc) { const sheet = doc.sheetsById[sheetId]; if (!sheet) { return {}; } const lngsMap = {}; const rows = await sheet.getRows(); rows.forEach((row) =\u0026gt; { const key = row[columnKeyToHeader.key]; lngs.forEach((lng) =\u0026gt; { const translation = row[columnKeyToHeader[lng]]; if (translation === NOT_AVAILABLE_CELL) { return; } if (!lngsMap[lng]) { lngsMap[lng] = {}; } lngsMap[lng][key] = translation || \u0026#34;\u0026#34;; }); }); return lngsMap; } function checkAndMakeLocaleDir(dirPath, subDirs) { return new Promise((resolve) =\u0026gt; { subDirs.forEach((subDir, index) =\u0026gt; { mkdirp(`${dirPath}/${subDir}`, (err) =\u0026gt; { if (err) { throw err; } if (index === subDirs.length - 1) { resolve(); } }); }); }); } async function updateJsonFromSheet() { await checkAndMakeLocaleDir(localesPath, lngs); const doc = await loadSpreadsheet(); const lngsMap = await fetchTranslationsFromSheetToJson(doc); fs.readdir(localesPath, (error, lngs) =\u0026gt; { if (error) { throw error; } lngs.forEach((lng) =\u0026gt; { const localeJsonFilePath = `${localesPath}/${lng}/${ns}.json`; const jsonString = JSON.stringify(lngsMap[lng], null, 2); fs.writeFile(localeJsonFilePath, jsonString, \u0026#34;utf8\u0026#34;, (err) =\u0026gt; { if (err) { throw err; } }); }); }); } updateJsonFromSheet(); src/index.tsx\rimport \u0026#34;i18n\u0026#34;; ... package.json\r\u0026#34;scripts\u0026#34;: { ..., \u0026#34;scan:i18n\u0026#34;: \u0026#34;i18next-scanner --config i18next-scanner.config.js\u0026#34;, \u0026#34;upload:i18n\u0026#34;: \u0026#34;yarn run scan:i18n \u0026amp;\u0026amp; node translate/upload.js\u0026#34;, \u0026#34;download:i18n\u0026#34;: \u0026#34;node translate/download.js\u0026#34; }, 사용법 ## i18next.t()로 감싸져 있는 키를 스캔 후 업로드 yarn upload:i18n # 구글 스프레드 시트에서 번역을 받아옴 yarn download:i18n import { Trans, useTranslation } from \u0026#34;react-i18next\u0026#34;; import type { Ii18Next } from \u0026#39;i18n\u0026#39;; export default function Example() { const i18next = useTranslation(); // scan을 위한 자체 컨벤션으로 \u0026#34;i18next\u0026#34; 사용 const getTabList = (i18next: Ii18Next) =\u0026gt; [ { id: 1, label: i18next.t(\u0026#34;예시 1\u0026#34;) }, { id: 2, label: i18next.t(\u0026#34;예시 2\u0026#34;) }, { id: 3, label: i18next.t(\u0026#34;예시 3\u0026#34;) }, ]; const tabList = getTabList(i18next); return ( \u0026lt;div\u0026gt; // 1) 일반 사용 {i18next.t(\u0026#34;이메일\u0026#34;)} // 2) 변수 사용 {i18next.t( `이메일은 \u0026#34;{{email}}\u0026#34;이고 , 비밀번호는 \u0026#34;{{password}}\u0026#34;이다.`, { email: \u0026#34;example@gmail.com\u0026#34;, password: \u0026#34;1234\u0026#34; }, )} // 3) 단수・복수 사용; 변수명으로 count를 사용 해야함 {i18next.t(`같은 명의로 만들어진 아이디는 {{count}}개입니다.`, { count: 3 })} // 4) html 태그 사용; i18nKey에 \u0026#34;html\u0026#34;을 포함 해야함 (scan을 위한 자체 컨벤션) \u0026lt;Trans i18nKey=\u0026#34;예시 html\u0026#34;\u0026gt; {{ name: \u0026#34;정유찬\u0026#34; }}님은 i18next를 \u0026lt;br /\u0026gt; 사용할 수 있습니다. \u0026lt;/Trans\u0026gt; // 5) return 외부에서 사용 {tabList.map((tab) =\u0026gt; ( \u0026lt;div\u0026gt; {tab.label} \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt;; ) } *조건부 서식을 활용해서 작업이 필요한 부분의 가시성을 높혔다.\nPs. 언어 변경 Select\rimport { useEffect } from \u0026#34;react\u0026#34;; import { useSelect } from \u0026#34;hooks/useSelect\u0026#34;; import i18n, { CURRENT_LANGUAGE, LANGUAGE_LIST } from \u0026#34;i18n\u0026#34;; export default function LanguageSelector() { const languageSelect = useSelect( LANGUAGE_LIST.findIndex((language) =\u0026gt; language[0] === i18n.language) !== -1 ? i18n.language : \u0026#34;ko\u0026#34; ); useEffect(() =\u0026gt; { i18n.changeLanguage(languageSelect.value); localStorage.setItem(CURRENT_LANGUAGE, languageSelect.value); }, [languageSelect.value]); return ( \u0026lt;select {...languageSelect.attribute}\u0026gt; {LANGUAGE_LIST.map((language) =\u0026gt; ( \u0026lt;option key={language[0]} value={language[0]}\u0026gt; {language[1]} \u0026lt;/option\u0026gt; ))} \u0026lt;/select\u0026gt; ); } import { useState, ChangeEvent, SelectHTMLAttributes, DetailedHTMLProps, } from \u0026#34;react\u0026#34;; type TUseSelectProps = { initialValue?: string; selectAttributes?: DetailedHTMLProps\u0026lt; SelectHTMLAttributes\u0026lt;HTMLSelectElement\u0026gt;, HTMLSelectElement \u0026gt;; }; export const useSelect = ({ initialValue = \u0026#34;\u0026#34;, selectAttributes = {}, }: TUseSelectProps = {}) =\u0026gt; { const [value, setValue] = useState(initialValue); const onChange = (event: ChangeEvent\u0026lt;HTMLSelectElement\u0026gt;) =\u0026gt; { const newValue = event.target.value; if (newValue !== value) setValue(newValue); }; return { attribute: { value, onChange, ...selectAttributes }, value, setValue, }; }; Reference.\nhttps://npmtrends.com/react-i18next-vs-react-intl https://npmcompare.com/compare/i18n-react,react-i18next,react-intl,react-intl-redux [React] 국제화(internationalization, i18n) 라이브러리 비교 https://www.i18next.com/ 기존 프로젝트에 다국어 처리를 적용해보자(react-i18next) ","date":"14 November 2022","permalink":"/posts/work/5/","section":"Posts","summary":"배경 #새로 진행하고 있는 B2B 프로젝트에 글로벌 진출 기회가 생겨서 다국어 처리를 할 필요가 생겼다.","title":"다국어 처리 (react-i18next)"},{"content":"Axios Instance #base url 설정, 헤더에 액세스 토큰 포함, 액세스 토큰 만료 시 재발급 그리고 리프레시 토큰 만료 시 로그아웃을 axiosInstance를 통해 공통 설정으로 처리했다.\nyarn add axios axiosInstance.ts\rimport axios from \u0026#34;axios\u0026#34;; import { getAccessToken, logout, TOKEN_INFO } from \u0026#34;modules/account/apis\u0026#34;; import type { AxiosRequestConfig, AxiosResponse, AxiosError } from \u0026#34;axios\u0026#34;; // ===== Setting ===== // //# Set URL const config: AxiosRequestConfig = { baseURL: `https://${process.env.REACT_APP_BRANCH}.becon-api.com`, }; export const axiosInstance = axios.create(config); //# Set Authorization export const setAxiosHeader = (accessToken: string) =\u0026gt; { axiosInstance.defaults.headers.common.Authorization = `Bearer ${accessToken}`; }; // ===== Preprocessing ===== // //# Fulfilled Response (200번대 응답) const onFulfilled = (res: AxiosResponse): AxiosResponse =\u0026gt; { return res; }; //# Rejected Response (200번대 외 응답) const onRejected = async (err: AxiosError): Promise\u0026lt;AxiosResponse\u0026gt; =\u0026gt; { const { config, response } = err; if (!config) return Promise.reject(err); // [edge-case] 요청의 설정이 없을 시 //## Access Token 만료 시 if (response?.status === 401) { const tokenInfoStr = localStorage.getItem(TOKEN_INFO); if (!tokenInfoStr) return Promise.reject(err); // [edge-case] Local Storage에 정보가 없을 시 const tokenInfo: { accessToken: string; refreshToken: string; } = JSON.parse(tokenInfoStr); try { // 0. Refresh Token으로 새로운 Access Token 획득 const newAccessToken = await getAccessToken({ refreshToken: tokenInfo.refreshToken, }); // 1. 권한 부여 헤더의 Access Token 교체 setAxiosHeader(newAccessToken); // 2. Local Storage의 Access Token 교체 localStorage.setItem( TOKEN_INFO, JSON.stringify({ ...tokenInfo, accessToken: newAccessToken, }) ); // 3. 현재 요청의 Access Token 교체 if (!config.headers) config.headers = {}; // [edge-case] 요청에 헤더가 없을 시 config.headers.Authorization = `Bearer ${newAccessToken}`; return axiosInstance(config); } catch (err: unknown) { // [edge-case] Refresh Token 만료 시 logout({ isExpired: true }); return Promise.reject(err); } } return Promise.reject(err); }; axiosInstance.interceptors.response.use(onFulfilled, onRejected); account/apis/index.ts\rexport const ID = \u0026#34;withbecon_id\u0026#34;; export const TOKEN_INFO = \u0026#34;withbecon_token_info\u0026#34;; export const EXPIRED = \u0026#34;withbecon_expired\u0026#34;; export const INVALID = \u0026#34;withbecon_invalid\u0026#34;; /** 이메일 로그인 */ export const emailLogin = async ({ email, password, }: { email: string; password: string; }) =\u0026gt; { const res = await axiosInstance.post\u0026lt;{ result: TLogin }\u0026gt;(\u0026#34;/account/auth\u0026#34;, { email, password, }); const tokenInfo = { accessToken: res.data.result.access_token, refreshToken: res.data.result.refresh_token, }; setAxiosHeader(tokenInfo.accessToken); localStorage.setItem(ID, email); localStorage.setItem(TOKEN_INFO, JSON.stringify(tokenInfo)); return res.data.result; }; /** 휴대폰번호 로그인 */ export const phoneNumberLogin = async ({ phone_number, password, }: { phone_number: string; password: string; }) =\u0026gt; { const res = await axiosInstance.post\u0026lt;{ result: TLogin }\u0026gt;( \u0026#34;/account/auth/phone\u0026#34;, { phone_number, password, } ); const tokenInfo = { accessToken: res.data.result.access_token, refreshToken: res.data.result.refresh_token, }; setAxiosHeader(tokenInfo.accessToken); localStorage.setItem(ID, phone_number); localStorage.setItem(TOKEN_INFO, JSON.stringify(tokenInfo)); return res.data.result; }; /** 로그아웃 (query X) */ export const logout = ({ isExpired, isInvalid, }: { isExpired?: boolean; isInvalid?: boolean; } = {}) =\u0026gt; { if (isExpired) localStorage.setItem(EXPIRED, EXPIRED); if (isInvalid) localStorage.setItem(INVALID, INVALID); localStorage.removeItem(TOKEN_INFO); window.location.replace(window.location.origin); }; /** 엑세스 토큰 조회 (query X) */ export const getAccessToken = async ({ refreshToken, }: { refreshToken: string; }) =\u0026gt; { const res = await axiosInstance.post\u0026lt;{ access_token: string }\u0026gt;( \u0026#34;account/auth/refresh\u0026#34;, { refresh_token: refreshToken } ); return res.data.access_token; }; /** 어카운트 정보 조회 */ export const getAccount = async () =\u0026gt; { const res = await axiosInstance.get\u0026lt;{ account: TAccount }\u0026gt;(\u0026#34;my/account\u0026#34;); return res.data.account; }; React Query #yarn add @tanstack/react-query @tanstack/react-query-devtools index.tsx\rconst root = ReactDOM.createRoot( document.getElementById(\u0026#34;root\u0026#34;) as HTMLElement ); root.render( \u0026lt;QueryClientProvider client={queryClient}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;ReactQueryDevtools /\u0026gt; \u0026lt;/QueryClientProvider\u0026gt; ); queryClient.tsx\rconst generateQueryClient = (): QueryClient =\u0026gt; { return new QueryClient({ defaultOptions: { queries: { suspense: true, refetchOnWindowFocus: false, retry: 1, onError: queryErrorHandler, }, mutations: { onError: queryErrorHandler, }, }, }); }; export const queryClient = generateQueryClient(); queryErrorHandler.ts\rconst queryErrorHandler = (err: unknown): void =\u0026gt; { alert(`withbecon server error -\u0026gt; ${err}`); window.location.replace(window.location.origin); }; export default queryErrorHandler; ","date":"13 November 2022","permalink":"/posts/work/4/","section":"Posts","summary":"Axios Instance #base url 설정, 헤더에 액세스 토큰 포함, 액세스 토큰 만료 시 재발급 그리고 리프레시 토큰 만료 시 로그아웃을 axiosInstance를 통해 공통 설정으로 처리했다.","title":"[프로젝트 초기 설정] Axios Instance \u0026 React Query"},{"content":"","date":null,"permalink":"/tags/axios/","section":"Tags","summary":"","title":"axios"},{"content":"","date":null,"permalink":"/tags/react-query/","section":"Tags","summary":"","title":"React-query"},{"content":"코드 스플리팅 #리액트에서 활용 가능한 여러 방식의 코드 스플리팅이 있지만 우선 회사의 다른 프로젝트에서 사용하고 있는 loadable component를 활용한 페이지(라우팅) 기반의 코드 스플리팅만 적용 했다.\nyarn add @loadable/component @types/loadable__component App.tsx\nimport loadable from \u0026#34;@loadable/component\u0026#34;; ... const ExamplePage = loadable(() =\u0026gt; import(\u0026#34;pages/ExamplePage\u0026#34;)) ... function App() { return ( \u0026lt;Router\u0026gt; \u0026lt;Routes\u0026gt; \u0026lt;Route path=\u0026#34;/example\u0026#34; element={\u0026lt;ExamplePage /\u0026gt;} /\u0026gt; ... \u0026lt;Route path=\u0026#34;*\u0026#34; element={\u0026lt;NotFound /\u0026gt;} /\u0026gt; \u0026lt;/Routes\u0026gt; \u0026lt;/Router\u0026gt; ) } SASS(SCSS) #/* ===== 1) reset ===== */ @import \u0026#34;base/reset\u0026#34;; /* ... */ * { margin: 0; padding: 0; font: inherit; color: inherit; } *, :after, :before { box-sizing: border-box; flex-shrink: 0; } :root { line-height: 1.5; -moz-tab-size: 4; tab-size: 4; cursor: default; // 모바일에서 꾹 클릭 시 색상 변경 방지 -webkit-tap-highlight-color: transparent; // 내용 선택 방지 -webkit-touch-callout: none; -webkit-user-select: none; -ms-user-select: none; user-select: none; // 모바일에서 폰트 크기 조정 방지 -webkit-text-size-adjust: none; -moz-text-size-adjust: none; text-size-adjust: none; // 글이 상자 벗어나는 거 방지 overflow-wrap: break-word; // 폰트 랜더링 부드럽게 만들기 -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; } html, body { height: 100%; // 최상위 부모 요소 기본 크기 설정 font-size: 62.5%; // 1rem === 10px font-weight: 400; font-style: normal; } img { -webkit-user-drag: none; } img, picture, video, canvas, svg { // 위치값을 가지고 상자 벗어나는거 방지 display: block; max-width: 100%; } // Chrome 자동 완성 배경색 지우기 input:-webkit-autofill { box-shadow: 0 0 0 30px transparent inset; } input:-webkit-autofill, input:-webkit-autofill:hover, input:-webkit-autofill:focus, input:-webkit-autofill:active { transition: background-color 5000s ease-in-out 0s; } // 선택 및 입력 스타일 초기화 button, input, select, progress { appearance: none; -webkit-appearance: none; background-color: transparent; border: 0; \u0026amp;:focus, \u0026amp;:active { outline: none; box-shadow: none; } } meter { border: 0; } textarea { \u0026amp;:focus, \u0026amp;:active { box-shadow: none; outline: none; } } // 입력 대상 커서 텍스트로 변경 input, textarea { cursor: text; } // 선택 대상 커서 포인터로 변경 a, button, select, input[type=\u0026#34;checkbox\u0026#34;], input[type=\u0026#34;radio\u0026#34;], input[type=\u0026#34;range\u0026#34;], label { cursor: pointer; } // 링크 스타일 초기화 a { text-decoration: none; } // 표 스타일 초기와 table { border-collapse: collapse; border-spacing: 0; } // 목록 스타일 초기화 ul, ol { padding-left: 0; list-style: none; } *_(underscore)를 scss 파일 이름 앞에 붙일 경우 부분 파일로 취급해서 작업 시점에는 모듈화되어 있지만 실제로 사용되는 시점에는 main.scss 파일 하나에 작성된다.\nReference.\n코드 스플리팅 https://velog.io/@velopert/react-code-splitting SCSS https://www.joshwcomeau.com/css/custom-css-reset/ 2022 CSS Reset 다시 써보기! [css-real] 드래그(drag) 막기 ","date":"12 November 2022","permalink":"/posts/work/3/","section":"Posts","summary":"코드 스플리팅 #리액트에서 활용 가능한 여러 방식의 코드 스플리팅이 있지만 우선 회사의 다른 프로젝트에서 사용하고 있는 loadable component를 활용한 페이지(라우팅) 기반의 코드 스플리팅만 적용 했다.","title":"[프로젝트 초기 설정] 코드 스플리팅 \u0026 SASS"},{"content":"","date":null,"permalink":"/tags/sass/","section":"Tags","summary":"","title":"sass"},{"content":"배경 #다른 팀원들이 기존 업무로 바빴기 때문에 신규 B2B 프로젝트에 나만 우선 투입되었다. (\u0026ldquo;곧 신규 프로젝트를 시작할 것이고 이 신규 프로젝트를 주도적으로 이끌어 나갈 수 있을 것이다.\u0026ldquo;라고 면접 때 들었고 이것이 내가 이 회사를 선택한 주된 이유 중 하나이기도 해서 매우 기대가 됨) 효율적인 협업을 위해 eslint(linter)와 prettier(formatter)로 코드 스타일을 맞추고 이를 효율적으로 확실히 지키기 위해 lint-staged(변경된 파일만 lint 검사)와 husky(git hook 공유)를 사용했다.\n1) 프로젝트 시작 #yarn create-react-app [project name] --template typescript 2) ESLint와 Prettier 적용 # yarn add eslint prettier eslint-config-prettier eslint-plugin-import @typescript-eslint/parser eslint-import-resolver-typescript -D npx eslint --init ✔ How would you like to use ESLint? · problems ✔ What type of modules does your project use? · esm ✔ Which framework does your project use? · react ✔ Does your project use TypeScript? · No / Yes ✔ Where does your code run? · browser ✔ What format do you want your config file to be in? · JSON The config that you\u0026#39;ve selected requires the following dependencies: eslint-plugin-react@latest @typescript-eslint/eslint-plugin@latest @typescript-eslint/parser@latest ✔ Would you like to install them now? · No / Yes ✔ Which package manager do you want to use? · yarn .eslintrc.json { \u0026#34;env\u0026#34;: { \u0026#34;browser\u0026#34;: true, \u0026#34;es2021\u0026#34;: true }, \u0026#34;extends\u0026#34;: [ \u0026#34;eslint:recommended\u0026#34;, \u0026#34;plugin:react/recommended\u0026#34;, \u0026#34;plugin:@typescript-eslint/recommended\u0026#34;, \u0026#34;plugin:import/typescript\u0026#34;, \u0026#34;plugin:import/recommended\u0026#34;, \u0026#34;prettier\u0026#34; ], \u0026#34;overrides\u0026#34;: [], \u0026#34;parser\u0026#34;: \u0026#34;@typescript-eslint/parser\u0026#34;, \u0026#34;parserOptions\u0026#34;: { \u0026#34;ecmaVersion\u0026#34;: \u0026#34;latest\u0026#34;, \u0026#34;sourceType\u0026#34;: \u0026#34;module\u0026#34; }, \u0026#34;plugins\u0026#34;: [\u0026#34;react\u0026#34;, \u0026#34;react-hooks\u0026#34;, \u0026#34;@typescript-eslint\u0026#34;], \u0026#34;settings\u0026#34;: { \u0026#34;import/resolver\u0026#34;: { \u0026#34;node\u0026#34;: {}, \u0026#34;typescript\u0026#34;: { \u0026#34;directory\u0026#34;: \u0026#34;./src\u0026#34; } }, \u0026#34;import/parsers\u0026#34;: { \u0026#34;@typescript-eslint/parser\u0026#34;: [\u0026#34;.ts\u0026#34;, \u0026#34;.tsx\u0026#34;] } }, \u0026#34;rules\u0026#34;: { \u0026#34;react/react-in-jsx-scope\u0026#34;: 0, \u0026#34;react-hooks/rules-of-hooks\u0026#34;: 2, \u0026#34;react-hooks/exhaustive-deps\u0026#34;: 2, \u0026#34;import/order\u0026#34;: [ \u0026#34;error\u0026#34;, { \u0026#34;groups\u0026#34;: [ \u0026#34;builtin\u0026#34;, \u0026#34;external\u0026#34;, \u0026#34;internal\u0026#34;, [\u0026#34;parent\u0026#34;, \u0026#34;sibling\u0026#34;, \u0026#34;index\u0026#34;], \u0026#34;type\u0026#34;, \u0026#34;unknown\u0026#34; ], \u0026#34;pathGroups\u0026#34;: [ { \u0026#34;pattern\u0026#34;: \u0026#34;./*.scss\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;type\u0026#34;, \u0026#34;position\u0026#34;: \u0026#34;after\u0026#34; } ], \u0026#34;alphabetize\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34;, \u0026#34;caseInsensitive\u0026#34;: true }, \u0026#34;newlines-between\u0026#34;: \u0026#34;always\u0026#34; } ] } } .prettierrc.json { \u0026#34;arrowParens\u0026#34;: \u0026#34;always\u0026#34;, \u0026#34;bracketSpacing\u0026#34;: true, \u0026#34;htmlWhitespaceSensitivity\u0026#34;: \u0026#34;css\u0026#34;, \u0026#34;insertPragma\u0026#34;: false, \u0026#34;jsxBracketSameLine\u0026#34;: false, \u0026#34;jsxSingleQuote\u0026#34;: false, \u0026#34;printWidth\u0026#34;: 80, \u0026#34;proseWrap\u0026#34;: \u0026#34;preserve\u0026#34;, \u0026#34;quoteProps\u0026#34;: \u0026#34;as-needed\u0026#34;, \u0026#34;requirePragma\u0026#34;: false, \u0026#34;semi\u0026#34;: true, \u0026#34;singleQuote\u0026#34;: false, \u0026#34;tabWidth\u0026#34;: 2, \u0026#34;trailingComma\u0026#34;: \u0026#34;all\u0026#34;, \u0026#34;useTabs\u0026#34;: false, \u0026#34;vueIndentScriptAndStyle\u0026#34;: false } 3) Lint-Staged와 Husky 적용 # npx mrm lint-staged package.json { ..., \u0026#34;lint-staged\u0026#34;: { \u0026#34;*.{js,jsx,ts,tsx}\u0026#34;: [ \u0026#34;prettier --write\u0026#34;, \u0026#34;eslint --fix\u0026#34; ] } } npx husky-init .husky/pre-commit #!/usr/bin/env sh . \u0026#34;$(dirname -- \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; yarn lint-staged ❗️node_modules를 재설치 할 경우 다시 해줘야 함\n","date":"11 November 2022","permalink":"/posts/work/2/","section":"Posts","summary":"배경 #다른 팀원들이 기존 업무로 바빴기 때문에 신규 B2B 프로젝트에 나만 우선 투입되었다.","title":"[프로젝트 초기 설정] 협업 준비"},{"content":"배경 #제품 상세페이지의 제품 이미지 바로 아래에 해당 제품의 평균 별점이 보이면 좋겠다는 의견이 나와서 이를 반영하기로 했다. 리뷰에 이미 평균 별점을 보여주는 기능이 적용되어 있었지만 별이 정수 단위로만 채워지고 있어서(예시. 4.3점이면 네 개, 4.5점이면 다섯 개) 소수점까지 정확히 반영되는 별점을 만들고 싶었다.\n시행착오 #처음에는 별 5개가 나란히 있는 이미지를 받은 다음 아래에는 비어있는 별을, 위에는 채워져 있는 별을 겹쳐서 배치한 다음 채워져 있는 별의 부모 요소 넓이를 백분율에 따라 줄이고 overflow: hidden; 스타일을 적용하는 것으로 쉽게 구현했었다. 하지만 별 사이의 간격까지 백분율에 반영해 버리는 문제점을 지니고 있었다.\n구현 #문제점을 해결하기 위해서 별 하나하나를 정수로 구분하고 별 내부를 소수점으로 구분하는 방법을 사용했다. 그리고 소수점 단위의 스타일 적용을 sass에서 구현하기 위해서 https://www.sassmeister.com/ 사이트를 참조해가며 반복문을 작성했다. (styled-component의 props가 잠시 그리워지는 시점이었다.) 마지막으로 별의 일부만 채우는 기능을 구현하기 위해 \u0026lt;svg/\u0026gt;에 margin-left: ...;를 마이너스 단위로 줘서 이동시킨 다음 내부의 \u0026lt;path/\u0026gt;를 transform: translateX(...);로 다시 이동시키는 방법을 사용했다.\n별점 리뷰 컴포넌트\rimport { StarSvg } from \u0026#34;src/assets/index\u0026#34;; import styles from \u0026#34;./StarReview.module.scss\u0026#34;; interface IStarsProps { score: number | undefined; size: string; emptyColor: string; filledColor: string; } /** * 5점 만점의 별점 리뷰 컴포넌트 `★★★★☆` * @score 별점(1~5점) e.g. `4.3` * @size 크기 e.g. `4vw` * @emptyColor 비었을 때 색상 e.g. `\u0026#34;#EEEDEF\u0026#34;` * @filledColor 찼을 때 색상 e.g. `\u0026#34;#6435C7\u0026#34;` */ export default function StarReview({ score, size, emptyColor, filledColor, }: IStarsProps) { const arr = new Array(5).fill(0); const _score = score || 0; const integer = Math.floor(_score); const decimal = Number((Number(_score.toFixed(1)) - integer).toFixed(1)) * 10; return ( \u0026lt;div className={styles.container}\u0026gt; \u0026lt;div className={styles.stars}\u0026gt; {arr.map((_, i) =\u0026gt; ( \u0026lt;StarSvg width={size} height={size} fill={emptyColor} key={i} /\u0026gt; ))} \u0026lt;/div\u0026gt; {!_score || _score \u0026lt; 1 || _score \u0026gt; 5 ? null : ( \u0026lt;div className={styles.stars} data-type=\u0026#34;filled\u0026#34;\u0026gt; {arr.map((_, i) =\u0026gt; ( \u0026lt;div key={i} data-decimal={decimal} data-index={i === integer ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;} data-empty={i \u0026gt; integer ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;} \u0026gt; \u0026lt;StarSvg width={size} height={size} fill={filledColor} /\u0026gt; \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; )} \u0026lt;/div\u0026gt; ); } 별점 리뷰 스타일\r.container { position: relative; .stars { display: flex; gap: 4px; \u0026amp;[data-type=\u0026#34;filled\u0026#34;] { top: 0; position: absolute; @for $i from 0 through 9 { \u0026gt; div[data-decimal=\u0026#34;#{$i}\u0026#34;][data-index=\u0026#34;true\u0026#34;] \u0026gt; svg { margin-left: -(100% - percentage($i * 0.1)); \u0026gt; path { transform: translateX(100% - percentage($i * 0.1)); } } } \u0026gt; div[data-empty=\u0026#34;true\u0026#34;] \u0026gt; svg { display: none; } } } } 별 이미지 (svg)\r\u0026lt;svg width=\u0026#34;current\u0026#34; height=\u0026#34;current\u0026#34; viewBox=\u0026#34;0 0 16 16\u0026#34; fill=\u0026#34;none\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; \u0026gt; \u0026lt;path d=\u0026#34;M7.71663 0.815216C7.81002 0.546548 8.18998 0.546548 8.28337 0.815216L9.81237 5.21396C9.85357 5.33248 9.96418 5.41284 10.0896 5.4154L14.7456 5.51028C15.0299 5.51608 15.1474 5.87744 14.9207 6.04928L11.2097 8.86273C11.1097 8.93854 11.0675 9.06857 11.1038 9.18867L12.4524 13.6461C12.5347 13.9183 12.2273 14.1416 11.9939 13.9792L8.17135 11.3192C8.06836 11.2476 7.93164 11.2476 7.82865 11.3192L4.00614 13.9792C3.77267 14.1416 3.46527 13.9183 3.54764 13.6461L4.89617 9.18867C4.9325 9.06857 4.89025 8.93854 4.79027 8.86273L1.0793 6.04928C0.852639 5.87744 0.970053 5.51608 1.25443 5.51028L5.91037 5.4154C6.03582 5.41284 6.14643 5.33248 6.18763 5.21396L7.71663 0.815216Z\u0026#34; fill=\u0026#34;current\u0026#34; /\u0026gt; \u0026lt;/svg\u0026gt; export { ReactComponent as StarSvg } from \u0026#34;./star.svg\u0026#34;; *CRA 시에만 ReactComponent 사용 가능\n주의사항 #해당 코드를 다른 프로젝트에 적용할 때 제대로 적용되지 않는 문제가 발생했다. 문제를 해결하기 위해 개발자 모드에서 스타일을 하나하나 꺼보면서 원인을 파악했다. 원인은 문제가 발생하는 프로젝트에 전역으로 text-align: center; 스타일이 먹혀있는 것이었다. 이 경험 덕에 전역으로 스타일을 먹이는 것은 위험하다는 것과 svg도 text-align이 먹힌다는 것을 배웠다.\n참조 #출근 첫날 회사의 코드를 살펴보는 과정에서 이 코드를 보고는 \u0026ldquo;이런 식으로 sass에서 반복문을 활용하는구나\u0026quot;를 알게 되었고 메모장에 메모해 뒀었다. (취업 전에는 styled-component와 tailwind-CSS를 주로 사용해서 sass에 대한 이해도가 상대적으로 부족했다.) 그리고 별점의 소수점을 어떻게 sass에서 반영할 수 있을까를 고민하는 과정에서 이 코드가 떠올랐고 이를 참조해서 문제를 쉽게 해결할 수 있었다.\n$spacesPx: (2, 4, 6, 8, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100); @each $space in $spacesPx { .mt#{$space} { margin-top: #{$space}px; } .mr#{$space} { margin-right: #{$space}px; } .mb#{$space} { margin-bottom: #{$space}px; } .ml#{$space} { margin-left: #{$space}px; } } ","date":"5 November 2022","permalink":"/posts/work/1/","section":"Posts","summary":"배경 #제품 상세페이지의 제품 이미지 바로 아래에 해당 제품의 평균 별점이 보이면 좋겠다는 의견이 나와서 이를 반영하기로 했다.","title":"평균 별점 (소수점 반영)"},{"content":"","date":null,"permalink":"/categories/%5Cetc/","section":"Categories","summary":"","title":"\\etc"},{"content":"","date":null,"permalink":"/tags/error/","section":"Tags","summary":"","title":"error"},{"content":"","date":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git"},{"content":"배경 #취업을 하게 되면서 컴퓨터 두 대(개인 컴퓨터와 회사 컴퓨터)를 이용해 블로깅을 하게 되었고, 이 과정에서 서브 모듈 관련 문제를 만났다.\n문제 #blog 저장소에는 블로그 설정, 테마 등의 모든 요소가 저장되고 yuchanjeong.github.io 저장소에는 빌드 된 정적 파일들만 저장되고 있다. blog 저장소에서 블로그에 관한 모든 것들을 관리하고 yuchanjeong.github.io 저장소는 서브 모듈로 관리하고 있는데 git clone을 한 뒤 push를 했을 때 blog 저장소에는 정상적으로 반영이 되나 yuchanjeong.github.io 저장소에는 전혀 반영이 되지 않는 문제가 발생했다.\n해결 #문제의 원인은 일반 클론 시 서브 모듈까지 클론하지 않기 때문이었다. 그래서 git clone --recurse-submodules를 통해 서브 모듈까지 클론해 줬다. 하지만 여전히 문제가 해결되지 않았고, cd public을 통해 서브 모듈로 이동한 뒤 확인해 보자 서브 모듈의 현재 브랜치가 main이 아니었다. 그래서 서브 모듈의 브랜치를 main으로 변경해 주자 문제가 해결되었다.\n*만약 기존 폴더를 그대로 사용한다면 git pull origin main --rebase를 통해 변경사항을 당겨 받은 뒤 서브 모듈로 이동해 git pull origin main -f를 통해 서브 모듈의 변경사항도 당겨 받으면 된다.\nEtc # 서브 모듈 등록 git submodule add -b main https://github.com/YuchanJeong/yuchanjeong.github.io.git public 원격 저장소의 서브 모듈로 업데이트 하기 git submodule update --remote 스크립트의 개행 제거 vi -b up.sh :%s/control+v -\u0026gt; control+m//g ","date":"31 October 2022","permalink":"/posts/etc/1/","section":"Posts","summary":"배경 #취업을 하게 되면서 컴퓨터 두 대(개인 컴퓨터와 회사 컴퓨터)를 이용해 블로깅을 하게 되었고, 이 과정에서 서브 모듈 관련 문제를 만났다.","title":"깃허브 블로그 서브 모듈 문제"},{"content":"","date":null,"permalink":"/categories/%5Cbooks/","section":"Categories","summary":"","title":"\\books"},{"content":"","date":null,"permalink":"/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98-%EA%B8%80%EC%93%B0%EA%B8%B0/","section":"Tags","summary":"","title":"개발자의 글쓰기"},{"content":" 개발자의 글쓰기는 \u0026lsquo;정확\u0026rsquo;하고 \u0026lsquo;간결\u0026rsquo;하고 \u0026lsquo;가독성\u0026rsquo;이 높아야 한다.\n1) 기초 # 두괄식 - 핵심 설명 후 부가 설명 구조화 - 들여쓰기 활용 Ps1. 함수명에 사용하는 영단어 뉘앙스 차이\nstop(중지) / restart(재개) end(종료) / start(시작) finish(완전 종료) / pause(일시 중지) / hold(의도를 지닌 중지) get(획득) / retrieve(검색 후 획득) / acquire(독점 획득) / fetch(다음 대상 획득) set(할당) / init(초기값 할당) create(틀을 만듦) / register(만들어진 틀에 입력) change(내용 변화) / modify(틀린 내용 수정) / revise(새로운 내용으로 개정) do(행동) / must(필수) / should(권고) is(boolean 데이터) Ps2. \u0026ldquo;-조사\u0026rdquo;, \u0026ldquo;-하다\u0026rdquo;, \u0026ldquo;숫자-\u0026rdquo;, \u0026ldquo;-기호-\u0026ldquo;만 붙여 쓰고 나머지는 띄어 씀\n2) 네이밍과 주석 # 기본적인 네이밍 컨벤션 클래스와 컴포넌트 - PascalCase\n함수와 변수 - camelCase\n상수 - UPPER_DELIMITER_CASE\n패키지와 모듈 - lowercase 명사+명사+명사 (변수) 형용사+명사+명사 (변수) 동사+명사+명사 (함수) BEM 클래스 표기법 - 대상__요소\u0026ndash;상태 변수명 명확한 의미(E.g. d, day(X) -\u0026gt; today, someday(O)) 복수형은 짧을 때는 \u0026ldquo;-s\u0026rdquo;, 길 때는 \u0026ldquo;listOf-\u0026ldquo;나 \u0026ldquo;arrayOf-\u0026ldquo;로 표현 함수명 필요한 기능을 문장으로 작성 함수는 시스템이 할 일이기 때문에 사용자가 할 일은 삭제 중복 내용을 삭제하며 문장 정리 후 분리 1함수 1기능 원칙으로 문장 재분리 기능별 함수 작성 이름이 기능을 명확하게 설명해야 함 설명이 안될 경우 함수를 더 분리해야 함 좋은 이름의 기준 SMART Easy to Search 고전적 범주화 E.g. userBuyer, userPayer, userRegister Easy to Mix 상위 태그와 조합 E.g. h1.title, h2.title, p.title Easy to Agree 구별할 필요가 없는 것까지 이름을 새로 지을 필요 없음 Easy to Remember 이미 널리 알려진 용어는 그냥 쓰는 것이 효율적 Easy to Type 입력하기 쉽고 오타를 낼 가능성이 적은 이름 주석 코드는 의미를, 주석은 의도를 주석은 디버깅으로 바로 잡을 수 없으니 개발자가 신경 써야 함 3) 에러 메시지와 선택지 # 에러의 내용, 원인, 해결법을 알려 줘야 함 \u0026ldquo;예 / 아니오\u0026rdquo; 보다는 구체적인 선택지를 제시 E.g. \u0026ldquo;페이지에 머물기 / 페이지에서 나가기\u0026rdquo; 순서에 일관성이 있어야 함 비활성화를 활용해 에러 예방 가능 4) 릴리스 문서와 장애 보고서 #a. 릴리즈 문서\n선정: 회사와 개발자가 말하고 싶은 것과 독자가 듣고 싶은 것 중 두 개 이상 만족하는 것 선정 분류: 독자에 따라 \u0026ldquo;개발 관점에서 비슷한 내용\u0026rdquo; 혹은 \u0026ldquo;사용 관점에서 비슷한 내용\u0026quot;으로 분류 요약: 불필요한 부사, 형용사, 조사, 어미 제거 종합: 종합은 분석의 개념화와 반대로 특징이나 결과로 서술 Ps. Semantic Versioning - major(호환 X).minor(새로운 기능).patch\nb. 장애 보고서\n문제, 문제점, 해결책, 후순 계획 순서로 작성 면책 조항 필수 필수, 권장, 선택, 예외 사항 표기 장애 보고서 구성 장애 내용 장애 영향 장애 원인 조치 사항 조치 결과 핵심 원인 향후 대책 장애의 근본 원인을 찾기 위해 원인의 원인을 계속 찾아라(5 whys) 재발을 막기 위해서는 원인 대신 이유를 묻고 사람 주어로 대답하라 개발 관점은 기능이 작동하지 않은 것, 비즈니스 관점은 손실이 발생한 것 모호하게 말고 정확한 정보를 적어라(E.g. 재발 가능성 30%) 5) 개발 가이드 # 서비스 개념을 범주, 용도, 특징으로 설명하라 용도는 범주의 핵심 기능을 써라 특징은 장점(자신 기준)과 강점(경쟁사와 비교)에서 뽑아 써라 이해를 돕기 위해 그림과 글로 묘사해라 주관적 묘사와 객관적 묘사를 둘 다 써라 의견을 쓰려면 근거를 대라 주장과 이유, 문제와 답의 거리를 좁혀라 순서에서 단계를 단계에서 목차를 만들어라 6) SI 제안서 # 고객의 문제인식이 중대하고 제안사의 문제 해결 능력이 탁월할 때, 경쟁사와 비교하여 강점들을 제안하라 고객의 문제인식이 중대하고 제안사의 문제 해결 능력이 부족할 때, 일단 동감하고 경쟁사와 다른 방안을 제시하라 고객의 문제인식이 사소하고 제안사의 문제 해결 능력이 탁월할 때, 고객이 문제를 중대하게 인식하게 만들어라 고객의 문제인식이 사소하고 제안사의 문제 해결 능력이 부족할 때, 경쟁사의 전략을 확인해서 대처하라 요구사항을 분석하지말고 제시하라 변화하는 요구사항에 대비하라 - Two Track(전체 검수와 기능별 검수) 개발 시간 대비 고객의 예상 만족도가 높은 것 위주로 개발하라 7) 기술 블로그 # 주제 의식을 버리고 소재 의식으로 쓰자 독자 수준이 아니라 자기 수준으로 쓰자 저 직접 경험하고 실험한 과정이나 결과*목차를 잘 잡고 본문부터 써라 술 어떤 것을 분석하여 의미를 풀이하고 해석한 것*원전을 비교하고 실험해 풀이해서 써라 편 산만하고 복잡한 자료를 편집해 질서를 부여한 것*순서를 요약해서 써라 집 여러 사람의 견해나 흩어진 자료를 한데 모아 정리한 것*자료를 모아 핵심을 엮어 써라 ","date":"29 October 2022","permalink":"/posts/books/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98-%EA%B8%80%EC%93%B0%EA%B8%B0/","section":"Posts","summary":"개발자의 글쓰기는 \u0026lsquo;정확\u0026rsquo;하고 \u0026lsquo;간결\u0026rsquo;하고 \u0026lsquo;가독성\u0026rsquo;이 높아야 한다.","title":"개발자의 글쓰기 - 김철수"},{"content":"","date":null,"permalink":"/tags/%EA%B9%80%EC%B2%A0%EC%88%98/","section":"Tags","summary":"","title":"김철수"},{"content":"","date":null,"permalink":"/tags/retrospective/","section":"Tags","summary":"","title":"(Retrospective)"},{"content":"","date":null,"permalink":"/tags/%5C%5Cbecon/","section":"Tags","summary":"","title":"\\\\Becon"},{"content":"","date":null,"permalink":"/categories/diaries/","section":"Categories","summary":"","title":"\u003cDiaries\u003e"},{"content":"","date":null,"permalink":"/tags/interview/","section":"Tags","summary":"","title":"Interview"},{"content":"취직 #팀 프로젝트를 끝낸 뒤 아쉬움이 남아 팀 프로젝트 개선과 개인 프로젝트를 하나 더 진행하였다. 그 와중 팀 프로젝트를 끝낸 후 코드 스테이츠에 올려둔 이력서를 보고 회사 몇 군데에서 연락이 왔다. 과제를 요구하는 곳도 있었고 빠른 시일 내에 면접을 원하는 회사도 있어서 준비를 조금 하다 보니 이렇게 된 거 그냥 바로 취업 전선에 뛰어들자고 마음먹었다.\n이 후 첫 면접을 봤고 바로 합격 소식 받았다. 최근 세계적으로 유명한 투자 회사한테 거액의 투자금을 받은 점과 사업 아이템이 마음에 드는 회사였다. 하지만 새로운 사업을 시작하기 직전이라 빠른 결정을 원했고 아직 다른 면접이 많이 남은 시점에서 한 번에 결정해야 하는 것이 마음에 걸렸다. 주변 사람들은 우선 간다고 하고 합류하기 전까지 다른 회사 면접을 보고 결정하면 된다고 했지만 도리가 아닌 거 같아 정중하게 거절하였다.\n같은 상황을 다시 만들고 싶지 않았기 때문에 면접 일정을 최대한 몰아서 잡았고 그 결과 하루에 2~3개의 면접을 일주일 내내 봐야하는 일정이 만들어 졌다. 이 와중에 코딩 테스트와 사전 과제들도 쏟아져서 매우 타이트한 일정을 소화했다. 아침에 이동 하면서 회사에 대해서 공부하고 면접을 보고 저녁에 고시원에 와서는 코딩 테스트와 사전 과제를 하며 하루에 3시간도 잠을 자지 못했다.\n그렇게 목요일 오후까지 총 11개 회사의 면접을 봤고 연락이 오지 않은 두 곳(이후 불합격 확인)을 제외한 9곳의 회사에서 합격 소식을 받았다. (합격한 곳 중 두 곳은 임원 면접이 이후 프로세스로 남아 있어서 최종 합격은 아님)\n최종적으로는 두 곳 중에서 고민하게 되었는데 이미 어느정도 자리를 잡고 회사 내부의 개발문화가 잘 잡혀있으며 오랜 경력의 시니어 개발자가 있는 회사와 모든 직원이 주니어로 이루어져 있지만 성장 가능성이 눈에 보이고 대표님과 이사님이 유능해보이는 회사였다.\n나는 어떤 환경이라도 성장할 자신이 있었기 때문에 회사가 성장했을 때 리턴이 가장 클 거 같은 후자의 회사를 선택했다. (주니어 때 많은 시행착오를 겪는 것이 중요하다고 생각한 점도 선택의 큰 이유였음)\n면접 꿀팁 #대부분의 면접에서 좋은 결과를 얻을 수 있었던 이유는 내가 솔직했기 때문이라고 생각한다. 내가 뭘 잘할 수 있고 뭘 잘 못하는지 그리고 어떤 회사를 원하는지를 솔직하게 말했다. 면접은 테스트를 받는 자리가 아니라 서로가 서로를 알아가는 자리이기 때문이다. (그렇다고 단점을 강조하라는 말은 아님! 장점을 거짓으로 만들지 않는 것이 중요!)\n추가로 나는 다양한 분야에 관심이 많은데 이 점이 비전공자의 단점을 많이 상쇄했다고 생각한다. 개발 외에도 사업과 시장 자체에 관심을 가지고 접근했고 이 점이 면접 때 많이 어필되었다.\n마지막으로 신입에게 중요한 것은 성장 가능성과 열정 그리고 조직에 잘 융화되는 커뮤니케이션 능력이라고 생각한다. 만약 부족한 것이 있다면 채워나가는 노력을 하고 그 부분을 어필하면 좋다고 생각한다.\n출근 첫 주 #","date":"16 October 2022","permalink":"/posts/diaries/2/","section":"Posts","summary":"취직 #팀 프로젝트를 끝낸 뒤 아쉬움이 남아 팀 프로젝트 개선과 개인 프로젝트를 하나 더 진행하였다.","title":"취직 준비부터 면접 그리고 출근 첫 주"},{"content":"","date":null,"permalink":"/tags/%5Cdebate-ducks/","section":"Tags","summary":"","title":"\\Debate-Ducks"},{"content":"","date":null,"permalink":"/categories/projects/","section":"Categories","summary":"","title":"\u003cProjects\u003e"},{"content":"개요 # 실시간 영상 토론 배틀 플랫폼 Debate-Ducks의 개선 프로젝트\n프로젝트 명 Debate-Ducks 2 웹 사이트 https://debate-ducks.click/ 깃허브 저장소 클라이언트 저장소, 서버 저장소 총 인원 3인 (Front-end 2인, Back-end 1인) 총 기간 2022.05 - 2022.08 (4개월) 사용 기술\n(개인) Next.js / React-query / Redux / Socket.io / WebRTC /\nTypeScript / SCSS / AWS-SDK 담당 업무\n(개인) - 소켓 서버 연결 및 관련 이벤트\n- Q\u0026amp;A 페이지 및 체험 토론 기능\n- 실시간 영상 토론 진행, 녹화, 녹화 영상 다운로드 및 업로드 기능\n- 토론 게시물 페이지 (좋아요∙팩트체크∙투표∙댓글 기능)\n- 토론 목록 페이지 (필터링∙검색∙무한스크롤 기능)\n- 토론 생성 및 수정 페이지\n- 로그인, 회원가입, 헤더 및 마이페이지 개선\n- 크로스 브라우징 이슈 해결 및 성능 최적화\n*개선 외에는 각 항목 100% 담당 목적 # 기존 프로젝트에서 완성하지 못했던 기능의 완성과 아쉬웠던 기능의 개선 아쉬웠던 UI/UX 개선 코드의 가독성 및 유지 보수성 개성 새로운 스택 도입 및 활용 *Next.js 활용 이외의 목적은 모두 달성\n작업 내용 #\rQ\u0026A 페이지\r[참조] -\rQ\u0026A 페이지\rㅤ\rㅤ\r체험 토론\r[참조] -\r체험 토론\rㅤ\r실시간 영상 토론\r[참조] -\rRoom\r/\rWebRTC\r/\rStream\r/\rCanvas\r/\rReconnect\r/\rDebate\r/\rRecord\r/\rRecord\r/\r개발 재개 및 보류\r/\r토론 영상 업로드 실패 문제\rㅤ\r토론 게시물\r[참조] -\r기본 내용 및 팩트 체크\r/\r투표\r/\r댓글\r/\r로그인∙로그아웃 시 좋아요 여부와 투표 여부 반영 문제\rㅤ\r토론 목록\r[참조] -\r정렬 시 재요청 문제\r/\r카테고리 필터링\r/\r토론 목록 조회 페이지\r/\r토론 카드 수정\r/\r스크롤 위치 기억하기\r/\r토론 카드 목록 배치 문제\rㅤ\r토론 생성 및 수정 페이지\r[참조] -\r토론 게시물 CRUD\r/\r토론 생성 및 수정 페이지\rㅤ\r로그인, 회원가입, 헤더 및 마이페이지 개선\r[참조] -\r헤더 스타일 변경\r/\r회원가입 및 로그인 개선\r/\r로그인, 회원가입 및 마이페이지 개선\rㅤ\r크로스 브라우징 이슈 해결 및 성능 최적화\r[참조] -\r크로스 브라우징 이슈\r/\r성능 최적화 - 이미지\rㅤ\r두 칸 이상의 공백과 한 줄 이상의 개행 제거\r[참조] -\r두 칸 이상의 공백과 한 줄 이상의 개행 제거\rㅤ\rPs. 작업 인원과 기간 #\r프로젝트의 규모에 비해서 투입 인원 많고 기간이 깁니다.\n이유를 설명하자면 우선 참여 부담을 느끼지 않게 기간과 담당 업무를 정하지 않았었습니다. (명백한 실책이라고 생각합니다.) 컨벤션과 어떤 기술을 사용할지만 합의를 하고 각자 시간이 될 때 작업을 하기로 했었습니다. 개인 일정이 우선시 되다 보니 프로젝트의 기간만 길어지게 되었고, 개인 일정이 바쁜 팀원은 거의 참여하지 못했습니다.\n다음은 개인적으로 몇 가지 이슈가 발생했었습니다. 외국에 거주 중이었는데 코로나와 비행기 티켓 매진으로 인해 귀국일이 계속 미뤄졌었고, 앞서 말한 코로나 때문에 건강이 매우 나빠졌었습니다. 그리고 귀국 후의 검사에서 후유증과 피부 종양이 발견되어 즉시 입원 및 수술을 하게 되었었습니다. 퇴원 후에도 한동안 컨디션이 회복되지 않아 작업을 제대로 할 수 없었습니다.\n다행히 7월 중순부터 컨디션이 회복되기 시작해 작업에 집중할 수 있었고 현재는 건강합니다.\nPs. v2.0.0 마무리 후 간단한 회고 #[참조] - 간단한 회고\n","date":"12 September 2022","permalink":"/posts/projects/debate-ducks/32/","section":"Posts","summary":"개요 # 실시간 영상 토론 배틀 플랫폼 Debate-Ducks의 개선 프로젝트","title":"Debate Ducks 2"},{"content":" 주니어 레벨 프런트 앤드 개발자 기술 면접에 필요한 지식들을 간단히 정리한 문서\n(★은 면접의 주니어 프런트 앤드 기술 면접에서 출제 빈도를 고려해 지정) JS # Non-blocking I/O 및 Single thread로 동작 호이스팅 (★★★★★) # 로드 시 선언들을 모두 끌어올려서 유효 범위 최상단에 선언하는 것 let과 const는 선언 후 해당 코드가 실행되기 전까지 초기화(할당)가 되지 않기 때문에 일시적 사각지대에 빠져 호이스팅이 일어나지 않는 것처럼 보임 클로저 함수 (★★★★★) #[참조]\n함수를 반환하는 함수 외부 함수의 변수를 내부 함수에서 재사용 (은닉화 및 캡슐화 가능) 만들어진 환경을 기억하기 때문에 사용 후 참조 제거 권장 *은닉화 - 외부에서 내부의 변수에 함부로 접근하지 못하도록 하는 것\n*캡슐화 - 외부에서 내부에 어떠 일이 일어나고 있는지 모르게 하는 것\nPs. 커링 - 함수 하나가 n개의 인자를 받는 과정을 n개의 함수로 각각 인자를 받도록 하는 것\nThis (★★★★☆) # 일반 함수 (호출 기준) 일반 호출 시 전역 객체 메서드 호출 시 호출 객체 화살표 함수 (선언 기준) 화살표 함수를 감싸고 있는 외부 함수의 객체 이벤트 루프 (★★★★☆) # 자바스크립트 엔진이 아닌 런타임 환경(브라우저, 노드)에서 가지고 있는 장치 Call Stack(실행 컨텍스트)과 Task Queue(Callback Queue)를 감시하며, Call Stack이 비어있을 때 Task Queue에서 태스크를 가져와 Call Stack에 넣어서 실행시키는 기능 Micro Task Queue(Promise)가 Normal Task Queue(타이머 함수, UI 렌더링)보다 우선순위 (우선순위 큐) *실행 컨텍스트 - 실행할 코드에 제공할 환경 정보들을 모아놓은 객체 (이때 호이스팅, 외부환경 정보 구성, this 값 설정이 발생)\n이벤트 버블링 (★★★★☆) #[참조]\n하위 요소에서 상위 요소로 이벤트가 전파되는 것 (\u0026lt;-\u0026gt; 이벤트 캡쳐, capture: true) 부모요소에 이벤트의 위임을 해서 효율적인 코딩이 가능 Ps. ev.stopPropagation() - 이벤트 전파를 막음\nPs. ev.preventDefault() - 고유 동작을 막음\n데이터 타입 (★★★☆☆) # 원시 타입 string, number, boolean, undefined, null 변수에 값을 저장 참조 타입 array, object, function 변수에 힙의 주소를 저장, 값은 힙에 저장 같은 주소를 참조할 때 하나 변화 시 일괄 변화 (mutable) Ps. 얕은 복사 - 복사한 참조형 데이터 내부의 참조형 데이터는 같은 주소 참조\nPs. 깊은 복사 - 복사한 참조형 데이터 내부의 참조형 데이터도 다른 주소 참조\nWeb #웹 브라우저에 주소를 입력하면 어떤 일이 생기나요? (★★★★★) #[참조]\n웹 브라우저가 도메인 명으로 IP 주소 조회 (이때 먼저 캐시를 찾고, 그다음 DNS를 검색) 웹 브라우저가 찾은 IP 주소를 기반으로 서버와의 TCP 연결을 시작 웹 브라우저가 HTTP(s) 요청을 서버로 전송 웹 서버가 요청을 처리하고 응답을 다시 웹 브라우저로 전송 웹 브라우저가 전송 받은 콘텐츠를 렌더링 *캐시(Cache) - 자주 사용하는 데이터나 값을 미리 복사해 놓는 임시 장소\n*DNS(Domain Name System) - 도메인 명과 IP 주소를 상호 변경해주는 기능\n*HTTP(Hyper Text Transfer Protocol) - 클라이언트와 서버의 데이터 통신을 위한 프로토콜\n비연결성: 클라이언트와 서버가 연결되어 있지 않음\n무상태성: 서버가 클라이언트의 상태를 가지고 있지 않음\n*리소스(비용)를 줄이기 위해\nPs. HTTPs - HTTP의 보안이 강화된 버전 (SSL/TLS 사용, 공개키로 암호화 후 비밀키로 복호화)\nPs. URI(Uniform Resource Identifier)는 자원의 고유 식별자이고, URL(Uniform Resource Locator)은 자원의 실제 위치를 가리키는 URI의 서브셋\nwvvw.example.com/index.html ← URI(O), URL(O) wvvw.example.com/index ← URI(O), URL(X) TCP (★☆☆☆☆) #Transmission Control Protocol\n컴퓨터와 다른 컴퓨터의 데이터 통신을 위한 프로토콜 3 Way Handshake로 연결, 4 Way Handshake로 연결 해제 확인 응답 덕분에 신뢰성이 높음 (UDP와 차이점) 보내는 양을 늘리고 줄이는 방법으로 혼잡 제어 가능 *3 Way Handshake - 접속 요청 전달 ➀ → 확인 응답 및 준비 완료 전달 ② → 확인 응답 전달 ➀\n*4 Way Handshake - 연결 종료 요청 전달 ➀ → 확인 응답 전달 및 자신의 통신이 끝날 때까지 대기(TIME_WAIT) ② -\u0026gt; 통신이 끝난 후 종료 요청 전달 ② -\u0026gt; 확인 응답 전달 ➀\n*UDP(User Datagram Protocol) - TCP에서 신뢰성 기능이 빠진 것으로 주로 실시간 스트리밍을 하는 곳에서 사용\nRestful API (★★★★☆) #[참조]\n정보를 안전하게 교환하기 위해 사용하는 인터페이스 고유 식별자로 리소스를 표시하고 메서드로 리소스에 대한 처리를 표시 장점 별도의 인프라 구축 없이 쉽게 구현 가능 확장성: 클라이언트-서버 상호 작용을 최적화하기 때문에 효율적으로 크기 조정 가능 유연성: 완전한 클라이언트-서버 분리를 지원해 변경이 쉬움 독립성: 사용되는 기술과 독립적이라 통신에 영향을 주지 않고 양쪽의 기본 기술 변경 가능 단점 RESTful을 완벽히 만족하는 API를 만들기 어렵고, 어느 선까지 만족해야 할지 불명확함 *API - 다른 소프트웨어 시스템과 통신하기 위해 따라야 하는 규칙\nPs. HTTP 메서드\nCRUD - POST / GET / PATCH(일부)•PUT(전부) / DELETE Preflight Request - OPTIONS(권한 및 안전 확인용 사전 요청) Ps. GET vs POST\n요청 GET POST 캐시 O X 브라우저 기록 O X 북마크 O X 길이 제한 O X *axios에서 GET은 body 사용 불가능\nPs. 응답 번호\n응답 번호 설명 200대 성공 300대 리다이렉션 400대 클라이언트 요청 에러 500대 서버 에러 웹 저장소(HTML5) (★★★★☆) # vs 쿠키 클라이언트에 정보만 존재 \u0026lt;-\u0026gt; 요청 마다 서버에 함께 전송 (성능 저하 원인, 탈취 위험 높음) 용량 제한이 없음 \u0026lt;-\u0026gt; 있음 만료일이 없음 \u0026lt;-\u0026gt; 있음 로컬 스토리지 별도로 삭제할 때까지 영구 유지 도메인만 같으면 전역 공유 가능 세션 스토리지 탭이나 브라우저가 종료되면 삭제 같은 도메인이라도 다른 탭이나 브라우저면 공유 불가능 웹 워커(HTML5) (★★★★☆) # 브라우저의 메인 스레드와 별개로 작동하는 고유 스레드를 생성해 멀티 스레드를 가능하게 함 별도의 WorkerGlobalScope를 가져서 Window 메서드 호출이나 DOM 조작이 불가능 OSI 7계층 (★☆☆☆☆) #Open Systems Interconnection\n표준 프로토콜을 사용하여 통신할 수 있도록 국제 표준화 기구(ISO)가 만든 모델 통신 과정을 단계별로 파악할 수 있게 만들어 이해와 문제 해결에 도움을 줌 각 계층별 설명\n물리 계층 물리적, 전기적 특성을 이용해서 데이터를 전송하는 계층 단위: bit | 대표 장치: 통신 케이블, 리피터, 허브 데이터 링크 계층 데이터의 오류와 흐름을 관리해서 신뢰성 있는 전송을 보장하는 계층 맥 주소(하드웨어 주소) 사용 이더넷, USB, Bluetooth, Wi-Fi 같은 하드웨어 간의 접속 규격들이 대부분 해당 단위: frame | 대표 장치: L2 스위치 네트워크 계층 데이터를 목적지까지 가장 신속하고 안전하게 전송하는 계층 IP 주소(네트워크 주소) 사용 단위: packet | 대표 장치: 라우터, L3 스위치 전송 계층 양 끝단의 사용자 간 통신을 활성화하는 계층 단위: segment | 프로토콜: TCP, UDP 세션 계층 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공하는 계층 TCP/IP 세션을 만들고 없애는 역할 표현 계층 코드 간 번역을 담당하는 계층 (인코딩/암호화) 응용 계층 응용 프로세스와 직접 관계해 응용 서비스를 수행하는 계층 응용 서비스는 관련된 응용 프로세스들 사이의 전환을 제공 단위: message, data (5계층 이상) | 대표 장치: 방화벽, L7 스위치 | 프로토콜: HTTP Ps. TCP/IP 4계층 - 링크 계층(1, 2) -\u0026gt; 인터넷 계층(3) -\u0026gt; 전송 계층(4) -\u0026gt; 응용 계층(5, 6, 7)\n[참조] - 프런트엔드 개발자 기술면접 인터뷰 질문 모음(업데이트)\n","date":"8 September 2022","permalink":"/posts/etc/interview-1/","section":"Posts","summary":"주니어 레벨 프런트 앤드 개발자 기술 면접에 필요한 지식들을 간단히 정리한 문서","title":"[면접 대비] 주니어 프런트 앤드 기술 면접"},{"content":"","date":null,"permalink":"/categories/etc/","section":"Categories","summary":"","title":"\u003cEtc\u003e"},{"content":"","date":null,"permalink":"/tags/devlog/","section":"Tags","summary":"","title":"(Devlog)"},{"content":"[PR] - https://github.com/SuSang-YuHee/Debate-Ducks-Client/pull/144\n개요 #lighthouse와 profile을 이용해 성능 최적화를 시도했다.\n*딱 한번 최고점수 96점이 나왔고 평균 90점이 나온다.\n내용 #우선 차세대 형식을 사용해 이미지 제공하기를 따라 이미지를 webp로 모두 변경했다. 그리고 이미지 크기 적절하게 설정하기를 따라 실제 이미지의 크기도 적절하게 줄였다. 또 \u0026lt;Image /\u0026gt; 요소의 크기도 명시적으로 표시해 줬다. 그 결과 성능이 눈에띄게 개선 되었다. (성능 30점 상승 및 예상 절감치 17.56초 개선)\n개선 전 (lighthouse)\n개선 후 (lighthouse)\n이후 profile을 이용해 react 요소의 최적화를 시도했다. 우선 가장 많은 배열을 렌더링 하는 토론 목록에 React.memo를 적용하고 적용하기 전과 비교해 봤다.\n개선 전 (profile)\n개선 후 (profile)\n하지만 차이는 미비했고 이후 다른 요소들도 React.memo와 useCallback을 활용해서 적용 전후를 비교했는데 유의미한 성능의 차이가 나지 않았다. (확인 방법이 잘못됐을 수도 있어서 추후 재확인 필요❗️)\n최적화 방식은 메모이제이션이기 때문에 유의미한 성능 개선이 없다면 낭비가 발생한다고 판단해서 따로 적용하지 않았다.\n","date":"7 September 2022","permalink":"/posts/projects/debate-ducks/31/","section":"Posts","summary":"[PR] - https://github.","title":"[Debate-Ducks] 성능 최적화 - 이미지"},{"content":"시험 생성 페이지에 탭 추가 #[PR] - https://github.com/YuchanJeong/ddangddang-avility-test/pull/7\nTapBtn\n/** * \\# 탭 버튼 * @param width 버튼 넓이 * @param isActive 탭 활성화 여부 */ export const TapBtn = styled(Btn)\u0026lt;{ width: string; isActive: boolean }\u0026gt;` width: ${({ width }) =\u0026gt; width}; padding: ${({ theme }) =\u0026gt; theme.size.sm}; padding-top: ${({ theme }) =\u0026gt; theme.size.md}; border-radius: ${({ theme }) =\u0026gt; theme.size.br} ${({ theme }) =\u0026gt; theme.size.br} 0 0; background-color: ${({ theme, isActive }) =\u0026gt; isActive ? theme.colors.accent : \u0026#34;transparent\u0026#34;}; text-align: center; \u0026amp;:hover { color: ${({ theme, isActive }) =\u0026gt; isActive ? theme.colors.primary : theme.colors.accent}; } `; 시험 생성 페이지 작업 사전 준비 #[PR] - https://github.com/YuchanJeong/ddangddang-avility-test/pull/8\n탭 전환 개선 #기존에 탭의 전환을 setIsTestInfoActive((prevState) =\u0026gt; !prevState);로만 처리했기 때문에 현재 탭을 다시 클릭했을 때도 탭의 전환이 발생했다. 그래서 각 탭의 onClick에 조건을 줘서 탭 클릭 시에만 해당 탭으로 전환이 일어나도록 변경했다.\n\u0026lt;TapBtn onClick={() =\u0026gt; { if (!isTestInfoActive) toggleActive(); }} width=\u0026#34;10rem\u0026#34; isActive={isTestInfoActive} \u0026gt; 시험 정보 \u0026lt;/TapBtn\u0026gt; \u0026lt;TapBtn onClick={() =\u0026gt; { if (isTestInfoActive) toggleActive(); }} width=\u0026#34;10rem\u0026#34; isActive={!isTestInfoActive} \u0026gt; 문제 \u0026lt;/TapBtn\u0026gt; 이미지 압축 # Ps. 예시 이미지는 68kb에서 19kb로 유의미하게 압축됨\n[참조] - browser-image-compression/npm\nnpm install browser-image-compression --save 이벤트의 타입을 ChangeEvent로만 했을 때는 Property 'files' does not exist on type 'EventTarget'. 에러가 발생했다. 그래서 제네릭으로 \u0026lt;HTMLInputElement\u0026gt;를 넣어주자 Object is possibly 'null'. 에러가 발생했고, if (!ev.target.files) return;로 해결했다.\nimport imageCompression from \u0026#34;browser-image-compression\u0026#34;; import { ChangeEvent } from \u0026#34;react\u0026#34;; /** * \\# 이미지 압축 후 압축된 이미지의 Promise 반환 * * e.g. \u0026lt;input type=\u0026#34;file\u0026#34; accept=\u0026#34;image/*\u0026#34; onChange={(ev) =\u0026gt; compressImage(ev).then((img) =\u0026gt; ...)}/\u0026gt; * @param ev input의 onChange 이벤트 * @returns 압축된 이미지 파일의 Promise */ export const compressImage = async (ev: ChangeEvent\u0026lt;HTMLInputElement\u0026gt;) =\u0026gt; { if (!ev.target.files) return; //\u0026gt; 에러 방지 1 const file = ev.target.files[0]; if (!file) return; //\u0026gt; 에러 방지 2 const options = { maxSizeMB: 1, maxWidthOrHeight: 250, useWebWorker: true, fileType: \u0026#34;image/jpeg\u0026#34;, }; try { const compressedFile = await imageCompression(file, options); return compressedFile; } catch (error) { console.log(error); } }; 이미지 업로드 컴포넌트 #파일 입력창, 이미지 그리고 기본 이미지 컴포넌트를 합쳐서 하나의 이미지 업로드 컴포넌트로 만들었다.\n강조색 변경 #더 깔끔한 느낌을 주기 위해 강조색을 푸른색 계열로 변경했다.\n헤더 클릭 범위 개선 #기존에 헤더의 토글 메뉴 클릭 범위는 글자만이 아니라 해당 공간 전부였다. 그래서 다시 한번 공간을 나누는 것으로 클릭 범위를 글자만으로 제한했다.\nconst Menus = () =\u0026gt; ( \u0026lt;\u0026gt; \u0026lt;FlexBox justifyContent=\u0026#34;flex-end\u0026#34;\u0026gt; \u0026lt;UnderlineBtnMenu onClick={goToTag}\u0026gt;태그\u0026lt;/UnderlineBtnMenu\u0026gt; \u0026lt;/FlexBox\u0026gt; \u0026lt;FlexBox justifyContent=\u0026#34;flex-end\u0026#34;\u0026gt; \u0026lt;UnderlineBtnMenu onClick={goToCreate}\u0026gt;시험 만들기\u0026lt;/UnderlineBtnMenu\u0026gt; \u0026lt;/FlexBox\u0026gt; \u0026lt;FlexBox justifyContent=\u0026#34;flex-end\u0026#34;\u0026gt; \u0026lt;AccentBtn onClick={props.toggleTheme}\u0026gt; {props.isDarkMode ? \u0026lt;FaSun /\u0026gt; : \u0026lt;FaMoon /\u0026gt;} \u0026lt;/AccentBtn\u0026gt; \u0026lt;/FlexBox\u0026gt; \u0026lt;/\u0026gt; ); ","date":"3 September 2022","permalink":"/posts/projects/%EB%95%A1%EB%95%A1%EB%8A%A5%EB%A0%A5%EC%8B%9C%ED%97%98/5/","section":"Posts","summary":"시험 생성 페이지에 탭 추가 #[PR] - https://github.","title":"[땡땡능력시험] 시험 생성 페이지 - 기초"},{"content":"","date":null,"permalink":"/tags/%5C%EB%95%A1%EB%95%A1%EB%8A%A5%EB%A0%A5%EC%8B%9C%ED%97%98/","section":"Tags","summary":"","title":"\\땡땡능력시험"},{"content":"PageInner \u0026amp; Select #[PR] - https://github.com/YuchanJeong/ddangddang-avility-test/pull/5\nPageInner #브라우저의 높이에서 헤더와 푸터의 높이를 빼서 푸터 아래의 공간이 보이는 것을 막음\n/** \\# 최대 넓이 1200px, 최소 넓이 320px인 가로 가운데 정렬된 공간 */ export const InnerBox = styled.div` width: 1200px; //\u0026gt; 최대 넓이 max-width: 100%; //\u0026gt; 1200px 이하일 때 margin: 0 auto; //\u0026gt; 가로 가운데 정렬 position: relative; min-width: 320px; `; /** \\# 최대 넓이 1200px, 최소 넓이 320px인 가로 가운데 정렬된 공간 / 헤더 및 푸터에 따라 높이 조정 */ export const PageInnerBox = styled(InnerBox)` padding: ${({ theme }) =\u0026gt; theme.size.lg}; min-height: calc(100vh - 17rem); `; Select # 기존 select 스타일 적용 select *좌측 Safari, 우측 Chrome\nuseSelect #/** \\# useSelect 반환값 타입 */ export interface IUseSelectResult { attribute: { value: string; onChange: (ev: ChangeEvent\u0026lt;HTMLSelectElement\u0026gt;) =\u0026gt; void; }; value: string; setValue: Dispatch\u0026lt;SetStateAction\u0026lt;string\u0026gt;\u0026gt;; } /** * \\# select 요소 값 관리 * * e.g. * * const exampleSelect = useSelect(EXAMPLES[0]) * * \\\u0026lt;select {...exampleSelect.attribute}\u0026gt; * * {EXAMPLES.map((ex) =\u0026gt; (\u0026lt;option key={ex}\u0026gt;{ex}\u0026lt;/option\u0026gt;))} * * \u0026lt;/ select\u0026gt; * @param initialValue 초깃값 * @returns \\{ `attribute`: select 요소의 속성, `value`: 선택된 값, `setValue`: 값 직접 변경 시 사용 } */ export const useSelect = (initialValue: string): IUseSelectResult =\u0026gt; { const [value, setValue] = useState(initialValue); const onChange = (ev: ChangeEvent\u0026lt;HTMLSelectElement\u0026gt;) =\u0026gt; { if (ev.target.value !== value) setValue(ev.target.value); }; return { attribute: { value, onChange }, value, setValue, }; }; select 기본 스타일 제거 #//# SELECT 기본 스타일 제거 select::-ms-expand { display: none; } select { -webkit-appearance: none; -moz-appearance: none; appearance: none; } Select 컴포넌트 # 이전에는 select의 화살표에 background-image 사용 이번에는 여러 태마에 대응하기 위해 위치를 조정한 문자(\u0026ldquo;V\u0026rdquo;) 사용 z-index로 select 클릭이 가능하게 함 background-color: transparent;로 화살표가 보이게 함 padding-right로 내용이 화살표를 안가리게 함 //# Select 타입 interface ISelectProps { width: string; list: string[]; select: IUseSelectResult; } //# Select 스타일 const SelectStyle = styled.select\u0026lt;Pick\u0026lt;ISelectProps, \u0026#34;width\u0026#34;\u0026gt;\u0026gt;` width: ${({ width }) =\u0026gt; width}; padding: ${({ theme }) =\u0026gt; theme.size.sm}; padding-right: ${({ theme }) =\u0026gt; theme.size.lg}; border: 1px solid ${({ theme }) =\u0026gt; theme.colors.text}; \u0026amp;:focus { border: 1px solid ${({ theme }) =\u0026gt; theme.colors.accent}; outline: 1px solid ${({ theme }) =\u0026gt; theme.colors.accent}; } border-radius: ${({ theme }) =\u0026gt; theme.size.br}; background-color: transparent; //\u0026gt; ArrowStyle 보임 color: ${({ theme }) =\u0026gt; theme.colors.text}; cursor: pointer; `; //# Select 화살표 스타일 const ArrowStyle = styled.span` position: absolute; transform: translate(-2rem, 0.6rem); z-index: -1; //\u0026gt; SelectStyle 클릭 가능 `; /** * \\# Select * @param width `string` select 넓이 * @param list `string[]` option 목록 * @param select `{ attribute, value, setValue }` useSelect의 반환값 */ export function Select(props: ISelectProps) { return ( \u0026lt;div\u0026gt; \u0026lt;SelectStyle width={props.width} {...props.select.attribute}\u0026gt; {props.list.map((el) =\u0026gt; ( \u0026lt;option key={el}\u0026gt;{el}\u0026lt;/option\u0026gt; ))} \u0026lt;/SelectStyle\u0026gt; \u0026lt;ArrowStyle\u0026gt;▼\u0026lt;/ArrowStyle\u0026gt; \u0026lt;/div\u0026gt; ); } 사용 예시 #export function Create() { const EXAMPLES = [\u0026#34;1번 목록입니다.\u0026#34;, \u0026#34;2번 목록입니다.\u0026#34;, \u0026#34;3번 목록입니다.\u0026#34;]; //! const select = useSelect(EXAMPLES[0]); return ( \u0026lt;PageInnerBox\u0026gt; \u0026lt;Select width=\u0026#34;14rem\u0026#34; list={EXAMPLES} select={select} /\u0026gt; \u0026lt;/PageInnerBox\u0026gt; ); } Input \u0026amp; BorderBtn #[PR] - https://github.com/YuchanJeong/ddangddang-avility-test/pull/6\nInput #\ruseInput #/** \\# useInput 반환값 타입 */ export interface IUseInputResult { attribute: { value: string; placeholder: string; onChange: (ev: ChangeEvent\u0026lt;HTMLInputElement | HTMLTextAreaElement\u0026gt;) =\u0026gt; void; }; value: string; setValue: Dispatch\u0026lt;SetStateAction\u0026lt;string\u0026gt;\u0026gt;; } /** * \\# input 요소 값 관리 * * e.g. * * const exampleSelect = useSelect(\u0026#34;초깃값\u0026#34;, \u0026#34;표시자\u0026#34;) * * \\\u0026lt;input {...exampleInput.attribute} /\u0026gt; * @param initialValue 초깃값 * @param placeholder 표시자 * @returns \\{ `attribute`: input 요소의 속성, `value`: 선택된 값, `setValue`: 값 직접 변경 시 사용 } */ export const useInput = ( initialValue: string, placeholder: string ): IUseInputResult =\u0026gt; { const [value, setValue] = useState(initialValue); const onChange = ( ev: ChangeEvent\u0026lt;HTMLInputElement | HTMLTextAreaElement\u0026gt; ): void =\u0026gt; { setValue(ev.target.value); }; return { attribute: { value, placeholder, onChange }, value, setValue, }; }; Input 컴포넌트 #//# Input 타입 interface IInputProps { width: string; input: IUseInputResult; } //# Input 스타일 const InputStyle = styled.input\u0026lt;Pick\u0026lt;IInputProps, \u0026#34;width\u0026#34;\u0026gt;\u0026gt;` width: ${({ width }) =\u0026gt; width}; padding: ${({ theme }) =\u0026gt; theme.size.sm}; border: 1px solid ${({ theme }) =\u0026gt; theme.colors.text}; \u0026amp;:focus { border: 1px solid ${({ theme }) =\u0026gt; theme.colors.accent}; outline: 1px solid ${({ theme }) =\u0026gt; theme.colors.accent}; } border-radius: ${({ theme }) =\u0026gt; theme.size.br}; background-color: ${({ theme }) =\u0026gt; theme.colors.primary}; color: ${({ theme }) =\u0026gt; theme.colors.text}; cursor: text; `; /** * \\# Input * @param width `string` input 넓이 * @param select `{ attribute, value, setValue }` useInput의 반환값 */ export function Input(props: IInputProps) { return \u0026lt;InputStyle width={props.width} {...props.input.attribute} /\u0026gt;; } BorderBtn # //# 테두리 있는 버튼 기본 스타일 const BorderBtn = styled(Btn)\u0026lt;{ width: string }\u0026gt;` width: ${({ width }) =\u0026gt; width}; padding: ${({ theme }) =\u0026gt; theme.size.sm}; border-radius: ${({ theme }) =\u0026gt; theme.size.br}; cursor: pointer; text-align: center; \u0026amp;:hover { color: ${({ theme }) =\u0026gt; theme.colors.text}; } \u0026amp;:active { color: ${({ theme }) =\u0026gt; theme.colors.text}; background-color: ${({ theme }) =\u0026gt; theme.colors.accent}; box-shadow: inset 0 0 50px 10px ${({ theme }) =\u0026gt; theme.colors.primary}; } `; /** * \\# 확인 버튼 (강조 색상) * @param width `string` 버튼 넓이 */ export const ConfirmBtn = styled(BorderBtn)` border: 1px solid ${({ theme }) =\u0026gt; theme.colors.accent}; background-color: ${({ theme }) =\u0026gt; theme.colors.accent}; color: ${({ theme }) =\u0026gt; theme.colors.primary}; `; /** * \\# 취소 버튼 (강조 테두리) * @param width `string` 버튼 넓이 */ export const CancelBtn = styled(BorderBtn)` border: 1px solid ${({ theme }) =\u0026gt; theme.colors.accent}; background-color: ${({ theme }) =\u0026gt; theme.colors.primary}; color: ${({ theme }) =\u0026gt; theme.colors.accent}; `; LINK 컴포넌트 에러 🐞 #[Issue] - https://github.com/YuchanJeong/ddangddang-avility-test/issues/4\n# 문제\nWarning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()? # 해결\nLink 컴포넌트 자식 요소로 컴포넌트가 직접 오게되면 발생하는 문제라 Fragment 요소로 감싸서 해결\n\u0026lt;Link href={\u0026#34;https://github.com/YuchanJeong/ddangddang-avility-test\u0026#34;}\u0026gt; \u0026lt;\u0026gt; \u0026lt;FaGithub /\u0026gt; \u0026lt;/\u0026gt; \u0026lt;/Link\u0026gt; [참조] - Using functional components as child of \u0026lt;Link/\u0026gt; causes ref-warnings\n","date":"1 September 2022","permalink":"/posts/projects/%EB%95%A1%EB%95%A1%EB%8A%A5%EB%A0%A5%EC%8B%9C%ED%97%98/4/","section":"Posts","summary":"PageInner \u0026amp; Select #[PR] - https://github.","title":"[땡땡능력시험] 페이지 이너, 셀렉트, 인풋 및 버튼"},{"content":"*Pull Request\n토론 영상 업로드 실패 문제 #문제1 #배포된 웹 사이트에서 진행한 토론 영상이 업로드에 실패했다.\n해결1 #먼저 서버 로그를 확인해 보니 \u0026ldquo;참석자가 이미 있는 토론은 수정할 수 없습니다.\u0026rdquo; 경고가 떴다. 백엔드 코드를 살펴보니 배포 버전이 구 버전이어서 문제가 생긴 것이었고, 서버 담당자가 배포 코드를 최신화해서 해결하고 배포 자동화를 성공시켜 재발을 방지했다.\n문제2 #서버 코드를 최신화 한 뒤 테스트 토론 영상은 정상적으로 업로드 되었는데, 그 다음 토론을 실제로 진행했을 때 토론 영상이 또 업로드에 실패했다.\n해결2 #우선 원인 파악을 위해 관련 기능들에 로그를 찍은 다음 확인해 봤다. 그 결과 blobRef.current가 undefined로 찍혔다. 영상 다운로드 기능은 제대로 작동했기 때문에 녹화 종료 로직에서 비동기 처리에 문제가 있다고 인지했다.\n확인 결과 영상의 길이를 메타데이터에 합치는 로직을 then으로 처리했었는데, 비동기 처리를 기다리지 않고 debateDone 소켓 이벤트가 발동했기 때문에 생긴 문제였다.\n즉, 잘 되던 기능이 고장난게 아니라 처음부터 잘못되어 있었는데, 영상 길이가 특정 임계치를 넘기 전에는 메타데이터의 변경이 빨라서 업로드 기능이 제대로 작동한 것이다. 그래서 await를 통해 해당 함수 내에서 다른 기능들도 비동기 처리를 기다리게 만들었다.\n기존 코드\nrecorderRef.current.onstop = () =\u0026gt; { const duration = Date.now() - startTimeRef.current; const blob = new Blob(blobsRef.current, { type: \u0026#34;video/webm\u0026#34;, }); ysFixWebmDuration(blob, duration, { logger: false }).then((fixedBlob) =\u0026gt; { blobRef.current = fixedBlob; blobsRef.current = []; if (isDoneRef.current) { socketRef.current.emit(\u0026#34;debateDone\u0026#34;, { debateId }); } else { setIsPauseModalOn(true); } }; 수정 코드\nrecorderRef.current.onstop = async () =\u0026gt; { const duration = Date.now() - startTimeRef.current; const blob = new Blob(blobsRef.current, { type: \u0026#34;video/webm\u0026#34;, }); const fixedBlob = await ysFixWebmDuration(blob, duration, { logger: false, }); blobRef.current = fixedBlob; blobsRef.current = []; if (isDoneRef.current) { socketRef.current.emit(\u0026#34;debateDone\u0026#34;, { debateId }); } else { setIsPauseModalOn(true); } }; 토론 게시물 URL 문제 #문제 #\r토론 게시물에서 로그인을 할 경우 제대로된 페이지가 나오지 않는 문제가 발생했다.\n해결 #급하게 정적 배포로 변경하면서 다이나믹 라우팅을 쿼리 파라미터로 교체해서 발생한 사이드 이펙트였다. URL에 ?debateId=이 포함되어 있어야 하는데 그렇지 않은 것이다.\n우선 debateId가 없을 때 에러페이지를 보여주는 로직을 추가했다.\nif (debate.isError || !debateId) return \u0026lt;Error /\u0026gt;; 그리고 pathname은 경로만 저장하기 때문에 이전 페이지 기억 로직에 search를 추가했다.\nstorage.setItem( \u0026#34;currentPath\u0026#34;, globalThis.location.pathname + globalThis.location.search ); Ps. TDD의 필요성 #계획한 데로 하나하나 확인하면서 개발이 진행되었을 때는 크게 문제 발생하지 않는다. 하지만 변경 사항이 생기면 여러 사이드 이펙트가 발생하고 문제가 생길 수 있다. 특히 프로젝트의 규모가 커질 경우 확인에 많은 어려움이 있을 것이다. 이때 TDD로 진행했다면 예상치 못한 문제를 최소의 비용으로 확인하고 수정할 수 있다.\n하지만 지금 진행하고 있는 땡땡능력시험에 바로 도입하기는 아직 어렵다고 판단되어 학습 후 추가하는 방향으로 생각하고 있다.\n","date":"31 August 2022","permalink":"/posts/projects/debate-ducks/30/","section":"Posts","summary":"*Pull Request","title":"[Debate-Ducks] 치명적인 문제들 해결"},{"content":" [PR] - https://github.com/YuchanJeong/ddangddang-avility-test/pull/3\nStyled-components 설정 #설치 #npm i styled-components styled-normalize npm i -D @types/styled-components 테마 스타일 #styles/theme.ts\n유지 보수성을 위해 테마별 스타일의 값들을 미리 지정 //# 사이즈 export const size = { sm: \u0026#34;.5rem\u0026#34;, md: \u0026#34;1rem\u0026#34;, lg: \u0026#34;2rem\u0026#34;, xl: \u0026#34;3rem\u0026#34;, }; //# 폰트 export const fonts = { family: { san_serif: \u0026#34;sans-serif\u0026#34;, serif: \u0026#34;serif\u0026#34;, }, size: { sm: \u0026#34;1.4rem\u0026#34;, md: \u0026#34;1.6rem\u0026#34;, lg: \u0026#34;2rem\u0026#34;, xl: \u0026#34;2.5rem\u0026#34;, xxl: \u0026#34;3rem\u0026#34;, title: \u0026#34;6rem\u0026#34;, }, weight: { light: 100, normal: 400, bold: 700, }, }; //# 미디어 쿼리 (부트스트랩 기준) const mediaSize = { mobile: \u0026#34;576px\u0026#34;, tablet: \u0026#34;768px\u0026#34;, laptop: \u0026#34;992px\u0026#34;, }; export const device = { mobile: `@media only screen and (max-width: ${mediaSize.mobile})`, tablet: `@media only screen and (max-width: ${mediaSize.tablet})`, laptop: `@media only screen and (max-width: ${mediaSize.laptop})`, }; //# 색상 const colors = { accent: \u0026#34;#7F00FF\u0026#34;, }; export const lightThemeColors = { ...colors, text: \u0026#34;#222120\u0026#34;, primary: \u0026#34;#FAFAFA\u0026#34;, }; const darkThemeColors = { ...colors, text: \u0026#34;#FAFAFA\u0026#34;, primary: \u0026#34;#222120\u0026#34;, }; //# 공통 스타일 모음 const defaultStyle = { size, fonts, device, }; //# 각 테마 export const lightTheme = { ...defaultStyle, colors: lightThemeColors, }; export const darkTheme = { ...defaultStyle, colors: darkThemeColors, }; //# 기본 테마 declare module \u0026#34;styled-components\u0026#34; { export interface DefaultTheme { size: typeof size; fonts: typeof fonts; device: typeof device; colors: typeof lightThemeColors; } } 공용 스타일 #styles/GlobalStyle.tsx\nnormalize로 브라우저별로 다른 스타일 통일 [참조] import { createGlobalStyle, css } from \u0026#34;styled-components\u0026#34;; import { normalize } from \u0026#34;styled-normalize\u0026#34;; const GlobalStyle = createGlobalStyle` ${normalize} //\u0026gt; 참조: https://necolas.github.io/normalize.css/latest/normalize.css * { box-sizing: border-box; } html { font-size: 62.5%; //\u0026gt; 1rem = 10px; } ${({ theme }) =\u0026gt; { return css` body { font-family: ${theme.fonts.family.san_serif}; font-weight: ${theme.fonts.weight.normal}; font-size: ${theme.fonts.size.md}; } `; }} `; export default GlobalStyle; 테마 및 공용 스타일 적용 #pages/_app.tsx\nThemeProvider로 테마 전역 공급 GlobalStyle로 공용 스타일 적용 import type { AppProps } from \u0026#34;next/app\u0026#34;; import Head from \u0026#34;next/head\u0026#34;; import { ThemeProvider } from \u0026#34;styled-components\u0026#34;; import GlobalStyle from \u0026#34;../styles/GlobalStyle\u0026#34;; import { darkTheme, lightTheme } from \u0026#34;../styles/theme\u0026#34;; function MyApp({ Component, pageProps }: AppProps) { return ( \u0026lt;\u0026gt; \u0026lt;Head\u0026gt; \u0026lt;title\u0026gt;땡땡능력시험\u0026lt;/title\u0026gt; \u0026lt;/Head\u0026gt; \u0026lt;ThemeProvider theme={isDarkMode ? darkTheme : lightTheme}\u0026gt; \u0026lt;GlobalStyle /\u0026gt; \u0026lt;Component {...pageProps} /\u0026gt;; \u0026lt;/ThemeProvider\u0026gt; \u0026lt;/\u0026gt; ); } export default MyApp; className 에러 🐞 #[Issue] - https://github.com/YuchanJeong/ddangddang-avility-test/issues/2\n# 문제\n“Prop className did not match.” 에러 발생\n# 해결\nbabel-plugin-styled-components로 환경과 상관없이 일관된 className을 생성\nnpm i -D babel-plugin-styled-components .babelrc 작성\n{ \u0026#34;presets\u0026#34;: [\u0026#34;next/babel\u0026#34;], \u0026#34;plugins\u0026#34;: [\u0026#34;babel-plugin-styled-components\u0026#34;] } [참조] - Prop className did not match\n로컬 스토리지 테마 상태 관리 Hook #hooks/useThemeInLocalStorage.ts\n로컬 스토리지로 테마 상태를 관리하는 커스텀 훅 수화 불일치 문제를 예방하기 위해 Dependency가 빈 배열인 useEffect 사용 (typeof window === \u0026quot;undefined\u0026quot; 사용 시 문제 발생) import { useEffect, useState } from \u0026#34;react\u0026#34;; /** * \\# 로컬 스토리지로 테마 상태 관리 * @returns \\{ `isDarkMode`: 다크 모드 여부, `toggleTheme`: 테마 전환 함수 } */ export const useThemeInLocalStorage = () =\u0026gt; { const [isDarkMode, setIsDarkMode] = useState\u0026lt;boolean\u0026gt;(false); //\u0026gt; 수화 불일치 문제 예방 (typeof window === \u0026#34;undefined\u0026#34; 사용 시 문제 발생) useEffect(() =\u0026gt; { setIsDarkMode(localStorage.getItem(\u0026#34;isDarkMode\u0026#34;) === \u0026#34;true\u0026#34; ? true : false); }, []); const toggleTheme = () =\u0026gt; { setIsDarkMode((prevState) =\u0026gt; { localStorage.setItem(\u0026#34;isDarkMode\u0026#34;, `${!prevState}`); return !prevState; }); }; return { isDarkMode, toggleTheme }; }; 기본 스타일 #components/atoms/BasicStyles.tsx \u0026amp; BasicStyles.d.ts\n자주 사용하게 될 스타일들을 미리 컴포넌트로 만듦 Flex-box는 props로 속성을 변형시킬 수 있게 만듦 Ps. 최소 넓이는 최소형 휴대폰 Apple iPhone SE를 기준으로 설정 [참조]\nimport styled from \u0026#34;styled-components\u0026#34;; import { IFlexBox } from \u0026#34;./BasicStyles.d\u0026#34;; /** \\# 최대 넓이 1200px, 최소 넓이 320px인 가로 가운데 정렬된 공간 */ export const InnerBox = styled.div` width: 1200px; //\u0026gt; 최대 넓이 max-width: 100%; //\u0026gt; 1200px 이하일 때 margin: 0 auto; //\u0026gt; 가로 가운데 정렬 position: relative; min-width: 320px; `; /** * \\# Flex-box * @param justifyContent ? `\u0026#34;center\u0026#34;(def) | \u0026#34;flex-start\u0026#34; | \u0026#34;flex-end\u0026#34; | \u0026#34;space-between\u0026#34; | \u0026#34;space-around\u0026#34;;` * @param alignItems ? `〃` * @param isFlexColumn ? `false(def) | true` * @param isFlexWrap ? `false(def) | true;` * @param gap ? `\u0026#34;0\u0026#34;(def) | \u0026#34;px\u0026#34; | \u0026#34;rem\u0026#34; | \u0026#34;%\u0026#34;` */ export const FlexBox = styled.div\u0026lt;IFlexBox\u0026gt;` display: flex; justify-content: ${({ justifyContent }) =\u0026gt; justifyContent || \u0026#34;center\u0026#34;}; align-items: ${({ alignItems }) =\u0026gt; alignItems || \u0026#34;center\u0026#34;}; flex-direction: ${({ isFlexColumn }) =\u0026gt; (isFlexColumn ? \u0026#34;column\u0026#34; : \u0026#34;row\u0026#34;)}; flex-wrap: ${({ isFlexWrap }) =\u0026gt; (isFlexWrap ? \u0026#34;wrap\u0026#34; : \u0026#34;nowrap\u0026#34;)}; gap: ${({ gap }) =\u0026gt; gap || \u0026#34;0\u0026#34;}; `; /** \\# Bold, 포인터, 스크롤 방지 (기본 버튼 속성) */ export const Btn = styled.div` font-weight: ${({ theme }) =\u0026gt; theme.fonts.weight.bold}; cursor: pointer; -moz-user-select: none; -webkit-user-select: none; -ms-user-select: none; user-select: none; `; components/atoms/Btns.tsx\n//# Flex-box 정렬 타입 type TFlexArrangement = | \u0026#34;flex-start\u0026#34; | \u0026#34;flex-end\u0026#34; | \u0026#34;center\u0026#34; | \u0026#34;space-between\u0026#34; | \u0026#34;space-around\u0026#34;; /** \\# Flex-box 타입 */ export interface IFlexBox { justifyContent?: TFlexArrangement; alignItems?: TFlexArrangement; isFlexColumn?: boolean; isFlexWrap?: boolean; gap?: string; } import styled from \u0026#34;styled-components\u0026#34;; import { Btn } from \u0026#34;./BasicStyles\u0026#34;; /** \\# hover 시 밑줄이 쳐지는 버튼 */ export const UnderlineBtn = styled(Btn)` \u0026amp;:hover { text-decoration: underline ${({ theme }) =\u0026gt; theme.colors.accent}; } `; /** \\# hover 시 색상이 강조되는 버튼 */ export const AccentBtn = styled(Btn)` \u0026amp;:hover { color: ${({ theme }) =\u0026gt; theme.colors.accent}; } `; Header #components/header/Header.tsx \u0026amp; Header.style.tsx\n중복되는 컴포넌트의 모음을 내부에서 묶어서 사용 (e.g. Menus) Styled-component는 컴포넌트 내부에 작성되면 안됨❗️ import { useRouter } from \u0026#34;next/router\u0026#34;; import { useState } from \u0026#34;react\u0026#34;; import { FaSun, FaMoon, FaHamburger } from \u0026#34;react-icons/fa\u0026#34;; import { InnerBox } from \u0026#34;../common/atoms/BasicStyles\u0026#34;; import { AccentBtn } from \u0026#34;../common/atoms/Btns\u0026#34;; import { BtnMenuMobile, FlexBoxHeader, FlexBoxMenus, FlexBoxMenusMobile, UnderlineBtnMenu, UnderlineBtnTitle, } from \u0026#34;./Header.style\u0026#34;; interface IHeaderProps { isDarkMode: boolean; toggleTheme: () =\u0026gt; void; } /** * \\# 헤더 * @param isDarkMode `boolean;` 다크 모드 여부 * @param toggleTheme `() =\u0026gt; void;` 테마 변경 함수 */ export function Header(props: IHeaderProps) { //# 테마 전환 const [isMobileMenuOn, setIsMobileMenuOn] = useState\u0026lt;boolean\u0026gt;(false); const toggleMenu = () =\u0026gt; { setIsMobileMenuOn((prevState) =\u0026gt; !prevState); }; //# 라우팅 const router = useRouter(); const goToMain = () =\u0026gt; { router.push(\u0026#34;/\u0026#34;); }; const goToTag = () =\u0026gt; { router.push(\u0026#34;/tag\u0026#34;); }; const goToCreate = () =\u0026gt; { router.push(\u0026#34;/create\u0026#34;); }; //# 메뉴 모음 const Menus = () =\u0026gt; ( \u0026lt;\u0026gt; \u0026lt;UnderlineBtnMenu onClick={goToTag}\u0026gt;태그\u0026lt;/UnderlineBtnMenu\u0026gt; \u0026lt;UnderlineBtnMenu onClick={goToCreate}\u0026gt;시험 만들기\u0026lt;/UnderlineBtnMenu\u0026gt; \u0026lt;AccentBtn onClick={props.toggleTheme}\u0026gt; {props.isDarkMode ? \u0026lt;FaSun /\u0026gt; : \u0026lt;FaMoon /\u0026gt;} \u0026lt;/AccentBtn\u0026gt; \u0026lt;/\u0026gt; ); return ( \u0026lt;InnerBox\u0026gt; \u0026lt;FlexBoxHeader\u0026gt; \u0026lt;UnderlineBtnTitle onClick={goToMain}\u0026gt;땡땡능력시험\u0026lt;/UnderlineBtnTitle\u0026gt; \u0026lt;FlexBoxMenus\u0026gt; \u0026lt;Menus /\u0026gt; \u0026lt;/FlexBoxMenus\u0026gt; \u0026lt;BtnMenuMobile isMobileMenuOn={isMobileMenuOn} onClick={toggleMenu}\u0026gt; \u0026lt;FaHamburger /\u0026gt; \u0026lt;/BtnMenuMobile\u0026gt; \u0026lt;/FlexBoxHeader\u0026gt; {isMobileMenuOn ? ( \u0026lt;FlexBoxMenusMobile\u0026gt; \u0026lt;Menus /\u0026gt; \u0026lt;/FlexBoxMenusMobile\u0026gt; ) : null} \u0026lt;/InnerBox\u0026gt; ); } import styled from \u0026#34;styled-components\u0026#34;; import { FlexBox, Btn } from \u0026#34;../common/atoms/BasicStyles\u0026#34;; import { UnderlineBtn } from \u0026#34;../common/atoms/Btns\u0026#34;; /** \\# Flex-box / 양끝 정렬 */ export const FlexBoxHeader = styled(FlexBox)` justify-content: space-between; padding: ${({ theme }) =\u0026gt; theme.size.lg}; height: 7rem; `; /** \\# Flex-box / 반응형(모바일 제외) */ export const FlexBoxMenus = styled(FlexBox)` gap: ${({ theme }) =\u0026gt; theme.size.lg}; ${({ theme }) =\u0026gt; theme.device.mobile} { display: none; } `; /** \\# Flex-box / 세로 배치 / 반응형(모바일) */ export const FlexBoxMenusMobile = styled(FlexBox)` flex-direction: column; gap: ${({ theme }) =\u0026gt; theme.size.xl}; text-align: right; display: none; \u0026amp; \u0026gt; * { margin: ${({ theme }) =\u0026gt; theme.size.lg}; \u0026amp;:first-child { margin-top: 0; } } ${({ theme }) =\u0026gt; theme.device.mobile} { display: block; } `; /** \\# hover 시 밑줄이 쳐지는 버튼 / 세리프 */ export const UnderlineBtnTitle = styled(UnderlineBtn)` font-family: ${({ theme }) =\u0026gt; theme.fonts.family.serif}; font-size: ${({ theme }) =\u0026gt; theme.fonts.size.xxl}; `; /** \\# hover 시 밑줄이 쳐지는 버튼 */ export const UnderlineBtnMenu = styled(UnderlineBtn)` font-size: ${({ theme }) =\u0026gt; theme.fonts.size.lg}; `; /** \\# isMobileMenuOn 시 색상이 강조되는 버튼 / 반응형(모바일) */ export const BtnMenuMobile = styled(Btn)\u0026lt;{ isMobileMenuOn: boolean }\u0026gt;` color: ${({ theme, isMobileMenuOn }) =\u0026gt; isMobileMenuOn ? theme.colors.accent : theme.colors.text}; font-size: ${({ theme }) =\u0026gt; theme.fonts.size.xl}; display: none; ${({ theme }) =\u0026gt; theme.device.mobile} { display: block; } `; ","date":"30 August 2022","permalink":"/posts/projects/%EB%95%A1%EB%95%A1%EB%8A%A5%EB%A0%A5%EC%8B%9C%ED%97%98/3/","section":"Posts","summary":"[PR] - https://github.","title":"[땡땡능력시험] Styled-components 설정 및 헤더•푸터"},{"content":" 공식 문서와 블로그 정리글들의 내용을 바탕으로 기본적인 내용만 정리. Table # 넣을 수 있는 Item의 개수는 무제한 같은 리전에서는 중복된 이름 사용 불가 Primary key #[참조] - DynamoDB 테이블에 적합한 기본 키를 선택하려면 어떻게 해야 하나요?\nPartition key (Hash) 간단한 기본 키 테이블에 파티션 키만 있는 경우 두 항목의 파티션 키값은 동일할 수 없음 일치 방식의 검색만 지원 Partition key (Hash) \u0026amp; Sort key (Range) 파티션 키와 정렬 키의 조합 테이블에 복합 기본 키가 있는 경우 두 항목의 파티션 키값은 동일할 수 있음 (이때 정렬 키값은 달라야 함) 일치, 부등호, 포함, ~로 시작하는 등 다양한 검색 지원 Ps. 타입은 S(string), N(number), B(binary)\nPs. 적절한 기본 키를 선택하지 못하면 데이터 배포 및 핫 키가 고르지 않을 수 있으며, 이로 인해 조절 오류가 발생할 수 있음\nSecondary Index # 기본 키 이외의 요소로 쿼리하기 위해 사용\n[참조] - 보조 인덱스를 사용하여 데이터 액세스 향상\nLocal Secondary Index 테이블의 기본 키가 파티션 키와 정렬 키의 조합을 사용할 때만 사용 가능 인덱스의 파티션 키가 테이블의 파티션 키와 일치해야 함 Global Secondary Index 테이블의 기본 키의 종류에 상관없이 사용 가능 인덱스의 파티션 키가 테이블의 파티션 키와 일치하지 않아도 됨 Ps. 보조 인덱스로 쿼리는 할 수 있지만 보조 인덱스를 가지고 바로 업데이트를 하는 것은 불가능\nPs. 로컬 보조 인덱스를 사용하는 이유 중 하나는 hot key issue(특정 파티션 키만 유독 많이 사용되어 용량이 몰리는 것)를 막기 위함\nQuery \u0026amp; Scan # Query [참조] 파티션 키와 정렬 키로 일부만 검색하는 방식 scan 보다 속도가 빠름 Scan 전체 데이터를 모두 검색하는 방식 query 보다 속도가 느림 지양해야 하는 작업 쿼리에 대한 키 조건 표현식 # 표현식 설명 a = b 속성 a가 값 b와 같은 경우 true a \u0026lt; b a가 b보다 작은 경우 true a \u0026lt;= b a가 b보다 작거나 같은 경우 true a \u0026gt; b a가 b보다 큰 경우 true a \u0026gt;= b a가 b보다 크거나 같은 경우 true a BETWEEN b AND c a가 b보다 크거나 같고 c보다 작거나 같은 경우 true begins_with (a, substr) a 속성 값이 특정 하위 문자열로 시작하는 경우 true Ps. 이 표현식들은 실제 값이 아닌 자리 표시자(:name 및 :sub)를 사용 [참조]\n쿼리에 대한 필터 표현식 # 필터 표현식은 Query가 완료된 후 결과가 반환되기 전에 적용 필터 표현식에는 파티션 키 또는 정렬 키 속성이 포함될 수 없음 키 조건 표현식과 동일한 비교기, 함수 및 논리적 연산자를 사용할 수 있음 같지 않음 연산자(\u0026lt;\u0026gt;), OR 연산자, CONTAINS 연산자, IN 연산자, BEGINS_WITH 연산자, BETWEEN 연산자, EXISTS 연산자 및 SIZE 연산자를 사용할 수 있음 [참조] 기타 참조 모음\n[참조] - 효과적으로 파티션 키를 설계해 사용하는 모범 사례\n[참조] - AWS DynamoDB 사용해보기\n[참조] - AWS DynamoDB 사용기_보조 인덱스 사용 위주로\n[참조] - Understanding hot keys in Dynamo DB\n","date":"29 August 2022","permalink":"/posts/studies/db/dynamodb/2/","section":"Posts","summary":"공식 문서와 블로그 정리글들의 내용을 바탕으로 기본적인 내용만 정리.","title":"[DynamoDB] 기본 개념"},{"content":"","date":null,"permalink":"/categories/studies/","section":"Categories","summary":"","title":"\u003cStudies\u003e"},{"content":"","date":null,"permalink":"/tags/aws/","section":"Tags","summary":"","title":"AWS"},{"content":"","date":null,"permalink":"/tags/dynamodb/","section":"Tags","summary":"","title":"DynamoDB"},{"content":"What is Amazon DynamoDB? # 완전관리형 NoSQL 데이터베이스 서비스\n[참조]\n원활한 확장성 빠르고 예측 가능한 성능 분산 데이터베이스 크기 조정 관리 부담 줄임 유휴 시 암호화 [참조] 데이터 보호와 관련된 운영 부담 및 복잡성 제거 다운타임 또는 성능 저하 없이 테이블의 처리 능력 확장 또는 축소 가능 리소스 사용률 및 성능 지표 모니터링 (AWS Management Console) 온디맨드 백업 기능 [참조] 특정 시점으로 복구 기능 [참조] 만료된 항목 테이블에서 자동 삭제 [참조] 높은 가용성 및 내구성 [참조] DynamoDB를 로컬 환경에서 사용하기 #Docker에 설치 #docker pull amazon/dynamodb-local docker run -p 8000:8000 --name local-dynamodb amazon/dynamodb-local \\ -jar DynamoDBLocal.jar -sharedDb *sharedDb옵션이 설정되어 있지 않으면 CLI와 SDK가 연동되지 않는다❗️\nAWS CLI로 연결 # IAM 사용자 추가 [참조]\nIAM -\u0026gt; 사용자 추가 AWA CLI 설치 [참조]\ncurl \u0026#34;https://awscli.amazonaws.com/AWSCLIV2.pkg\u0026#34; -o \u0026#34;AWSCLIV2.pkg\u0026#34; sudo installer -pkg AWSCLIV2.pkg -target / AWS CLI 연결\naws configure AWS Access Key ID [None]: AWS Secret Access Key [None]: Default region name [None]: local Default output format [None]: json aws configure list Ps. 기본 명령어 (CLI) [참조]\n테이블 조회\naws dynamodb list-tables \\\r--endpoint-url http://localhost:8000 테이블 생성\naws dynamodb create-table \\ --table-name [테이블 이름] \\ --attribute-definitions \\ AttributeName=[속성1 이름],AttributeType=[속성1 타입] AttributeName=[속성2 이름],AttributeType=[속성2 타입] \\ --key-schema \\ AttributeName=[속성1 이름],KeyType=HASH AttributeName=[속성2 이름],KeyType=RANGE \\ --provisioned-throughput \\ ReadCapacityUnits=1,WriteCapacityUnits=1 \\ --endpoint-url http://localhost:8000 *RANGE(속성2)는 옵션\n테이블 삭제\naws dynamodb delete-table \\ --table-name [테이블 이름] \\ --endpoint-url http://localhost:8000 AWS SDK로 연결 (feat. JavaScript) # 설치\nnpm i @aws-sdk/client-dynamodb @aws-sdk/lib-dynamodb 환경변수 설정\n# Local NEXT_PUBLIC_AWS_REGION=local NEXT_PUBLIC_AWS_ENDPOINT=http://localhost:8000 NEXT_PUBLIC_AWS_ACCESS_KEY_ID= NEXT_PUBLIC_AWS_SECRET_ACCESS_KEY= DynamoDBClient 설정\nimport { DynamoDBClient } from \u0026#34;@aws-sdk/client-dynamodb\u0026#34;; export const ddbClient = new DynamoDBClient({ region: process.env.NEXT_PUBLIC_AWS_REGION, endpoint: process.env.NEXT_PUBLIC_AWS_ENDPOINT, credentials: { accessKeyId: process.env.NEXT_PUBLIC_AWS_ACCESS_KEY_ID || \u0026#34;\u0026#34;, secretAccessKey: process.env.NEXT_PUBLIC_AWS_ACCESS_KEY_ID || \u0026#34;\u0026#34;, }, }); DynamoDB admin (GUI) #[참조] - npm/dynamodb-admin\nnpm install -g dynamodb-admin # For Mac/Linux: DYNAMO_ENDPOINT=http://localhost:8000 dynamodb-admin AWS-SDK로 사용 (feat. JavaScript) #[참조] - 웹 문서\n[참조] - 깃허브 예제\n항목 만들기 (예시)\nimport { PutCommand } from \u0026#34;@aws-sdk/lib-dynamodb\u0026#34;; import { v4 as uuid } from \u0026#34;uuid\u0026#34;; import { ddbClient } from \u0026#34;./dynamodb\u0026#34;; export const putTest = async () =\u0026gt; { const params = { TableName: \u0026#34;Test\u0026#34;, Item: { id: uuid(), title: { S: \u0026#34;제목\u0026#34; }, author: { S: \u0026#34;작성자\u0026#34; }, }, }; try { const data = await ddbClient.send(new PutCommand(params)); console.log(\u0026#34;Success-putTest\u0026#34;, data); } catch (err) { console.log(\u0026#34;Error-putTest\u0026#34;, err); } }; ","date":"28 August 2022","permalink":"/posts/studies/db/dynamodb/1/","section":"Posts","summary":"What is Amazon DynamoDB?","title":"[DynamoDB] 시작하기"},{"content":"로컬 DynamoDB 연결 #우선 Docker를 사용해서 로컬에 DynamoDB를 만들었다. 그 후 CLI로 테이블을 만들고 AWS-SDK로 아이템의 생성 및 테이블의 조회를 테스트 했다.\n하지만 CLI에서 만든 테이블이 AWS-SDK로 확인했을 때 조회되지 않았다. sharedDb 옵션을 사용하지 않으면 프로그램별로 DB가 따로 생성되기 때문이었다. [참조]\n그래서 sharedDb 옵션을 포함한 DynamoDB를 다시 만들었으며, 추가로 GUI로 확인할 수 있게 dynamodb-admin을 사용했다.\n[참조] - [DynamoDB] 시작하기 (My Blog)\nDB 구체화 #시험 페이지 #이번 프로젝트에서는 DB로의 요청과 서버의 부담을 최소화시키는 방법을 고민했다. 한번 생성된 시험은 같은 형태로 여러 사용자들에게 보여줄 것이기 때문에 정적으로 생성(SSG)하고, 변경 사항이 있을 때만 해당 페이지를 업데이트하고 다시 정적으로 배포(On-demand Revalidation)해서 서버의 부담과 DB로의 요청을 줄일 것이다.\n시험 목록 #각 시험 페이지의 경우는 시험의 생성, 수정, 삭제 시에만 페이지를 정적으로 생성해 주면 된다. 하지만 시험 목록의 경우에는 작성된 시험의 수가 많아지게 되면 미리 정적으로 생성하는 편이 더 많은 부담을 줄 수 있다. 그래서 우선은 시험 목록의 상위 일부만 정적으로 생성하고 그 이후는 무한 스크롤 방식으로 CSR로 구현하는 방식을 도입할 것이다.\n여기서 하나 더 고려할 점은 DynamoDB의 경우 특정 항목만 조회할 때 쿼리가 먼저 완료된 후 결과가 반환되기 전에 필터링이 적용돼서 동일한 양의 읽기 용량을 사용한다.\n그렇기 때문에 내부 문제들까지 조회할 필요가 없는 시험 목록을 위해 시험 테이블을 조회할 경우 읽기 용량의 낭비가 발생한다. 만약 모든 시험 목록을 정적으로 생성한다면 해당 데이터를 그대로 시험 페이지에서 사용하면 되지만 시험 목록의 상위 일부만 정적으로 생성할 것이기 때문에 사용할 수 없는 방법이다.\n그래서 시험 목록 테이블과 시험 내용 테이블로 분리하기로 했다. 생성, 수정, 삭제 시 더 많은 읽기 용량을 사용하지만 조회의 빈도수가 더 많을 것이라는 가정 하에서 이 편이 더 효율적이라고 판단했기 때문이다.\n점수와 댓글 #점수와 댓글의 경우에는 조금 더 많은 고민이 필요했다. 조회 만큼은 아니겠지만 시험의 생성, 수정, 삭제 보다는 더 많은 빈도로 발생할 것이기 때문이다. 하지만 고민과 검색의 결과로 얻은 답은 현재로써는 알 수 없다는 것이다. ISR이나 On-demand Revalidation의 비용 효율에 대해서 살펴봐도 정확한 가이드 라인이나 비교는 찾지 못했다. 그래서 서비스를 우선 SSG로 구현한 다음 CSR과 비교해 보고 판단할 것이다.\n[참조] - What happens if Next.js ISR with the revalidate value is 1 second in Production?\n검색 #현재 DynamoDB의 경우 쿼리에 대한 키 조건 표현식에 포함이 없다. 즉 검색어를 포함하는 게시물만 조회할 수는 없기 때문에 전체 게시물을 스캔한 다음 필터링을 통해 검색 기능을 구현해야 한다. 하지만 이렇게 구현할 경우 시험의 수가 많아지게 되면 읽기 용량의 낭비가 크게 발생할 것이다.\n여기서 이 프로젝트의 경우 OO 능력 시험, OO 영역의 형태로 시험의 제목이 정해질 것이기 때문에 해당 값들을 미리 배열에 저장해두고 검색 기능에 활용할 수 있다는 생각이 들었다.\n시험의 생성 시 주제와 영역 테이블에 해당 값들을 저장해두고 getStaticProps를 통해 값들을 받은 다음 클라이언트 내부에서 부분 검색을 구현한 다음 해당 값을 쿼리에 대한 키 조건으로 사용하면 되는 것이다.\n하지만 이렇게 될 경우 각 테이블들에 대한 스캔이 시험의 생성, 변경, 수정, 삭제 시마다 일어나게 된다. 그래도 각 테이블은 아주 작은 문자열을 값으로 하는 단일 항목으로 구성되며, 프로젝트의 특성상 \u0026ldquo;영화, 드라마, 만화 등\u0026rdquo; 중복되는 값이 많을 것이라 괜찮다고 판단했다. 이 부분도 점수, 댓글과 마찬가지로 추후 확인이 필요하다.\n사용자 정보 #기획 구체화를 위해 PIKU(이상형 월드컵)를 참조했다. 사용자가 특정 게시물을 만들고 해당 게시물을 다른 사용자가 선택을 통해 풀어가는 방식이 비슷했고, 실제로 많은 이용자를 가지고 있으며, 많은 인터넷 방송인들이 콘텐츠로 활용하고 있기 때문이다.\nPIKU에서 이상형 월드컵을 만들기 위해서는 로그인이 필요한데, 회원가입에 사용되는 이메일은 별다른 인증이 없었다. 그리고 로그인 후의 기능도 내가 만든 이상형 월드컵 보기 뿐이었다. 댓글의 경우는 비로그인 상태에서 달 수 있었다.\n참조 후 이 프로젝트의 주 서비스는 시험을 만들고 만들어진 시험을 푸는 것인데, 굳이 로그인/회원가입이라는 중간 과정을 넣을 필요가 있을까 하는 생각이 들었다.\n또한 로그인이 필요한 이유는 시험 게시물의 수정, 삭제, 모아보기 그리고 댓글을 위해서이다. 여기서 모아보기를 제외한다면 작성 시 암호를 넣고 해당 암호를 입력했을 때만 수정 및 삭제가 가능하게 하면 따로 사용자 정보를 저장하지 않고도 구현할 수 있다.\n그리고 회원가입에 심리적 부담감이 있는 사용자도 있기 때문에 서비스의 접근성을 더 높이기 위해서 이 과정을 빼는 것도 괜찮겠다고 판단했다.\nPs. 댓글 작성의 경우 리뷰 형태로 시험을 푼 후에만 작성이 가능하게 할 것이며 이때 점수 공개 여부와 비밀번호를 통해 추후 수정 및 삭제가 가능하게 할지 여부를 정할 수 있을 것이다.\nPs. Next.js의 api나 AWS의 Lambda를 사용한 회원가입, 로그인, 인증 기능을 공부해둔 상태라 조금 아쉬웠지만 이 프로젝트에서는 필요 없다고 생각해서 다음에 잘 사용해 보겠다. [참조]\nDB 수정안 #TestCovers: { testId: uuid, //# Hash Attribute (Partition Key) coverUrl: string, category: string, //\u0026gt; Secondary Index area: string, //\u0026gt; Secondary Index createdAt: string //\u0026gt; Secondary Index updatedAt: string }[] TestContents: { testId: uuid, //# Hash Attribute (Partition Key) password: string, //# Range Attribute (Sort Key) coverUrl: string, category: string, area: string, questions: { point: number, question: string, desc?: {type: string, data: string}, choice1: {type: string, data: string}, choice2: {type: string, data: string}, choice3: {type: string, data: string}, choice4: {type: string, data: string}, answer: number, explanation?: string, }[], createdAt: string, updatedAt: string }[] TestResults: { testId: uuid, //\u0026gt; Hash Attribute (Partition Key) totalCount: number, totalScore: number }[] Categories: { category: string }[] Areas: { area: string }[] Comments: { commentId: uuid, //# Hash Attribute (Partition Key) password: string, //# Range Attribute (Sort Key) testId: uuid, //\u0026gt; Secondary Index comment: string, point: number, createdAt: string, updatedAt: string }[] 구현 가능 여부 테스트 #이전에 프로젝트에서는 기획 단계에서 구현 가능 여부를 정확히 확인하지 않고 들어갔다. 그래서 나중에 구현에 실패하고 급하게 해결 방법을 찾은 경험이 있다.\n이에 교훈을 얻어 이번에는 미리 확인을 하고 들어가기로 했다. 특히 On-demand Revalidation 같은 경우는 22년 6월에 안정화된 기능이라 예시가 별로 없어서 예제를 직접 만들어서 확인했다.\npages/[testId].tsx\nimport { GetStaticPaths, GetStaticProps } from \u0026#34;next\u0026#34;; import { useRouter } from \u0026#34;next/router\u0026#34;; export default function Test({ test }: { test: string }) { const router = useRouter(); //# 마음대로 요청할 수 없게 비밀 키 활용 function revalidation() { fetch( `/api/revalidate?testId=${router.query.testId}\u0026amp;secret=${process.env.NEXT_PUBLIC_MY_SECRET_TOKEN}` ); } //# 빌드 중일 때 보이는 화면 if (router.isFallback) return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{test}\u0026lt;/h1\u0026gt; \u0026lt;h1 onClick={revalidation}\u0026gt;revalidate\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } export const getStaticPaths: GetStaticPaths = async () =\u0026gt; { return { paths: [], //\u0026gt; build 시 만들 경로 fallback: true, //\u0026gt; paths에 없는 경로일 경우 build 중 fallback 상태 }; }; export const getStaticProps: GetStaticProps = async (context) =\u0026gt; { const testId = context.params?.testId; const test = testId; console.log(context.params); //# 특정 조건일 때 404 page if (testId === \u0026#34;0\u0026#34;) { return { notFound: true, }; } return { props: { test, }, }; }; pages/api/revalidate.ts\nexport default async function handler(req: any, res: any) { console.log(`Revalidating-try: ${req.query.testId}`); if (req.query.secret !== process.env.NEXT_PUBLIC_MY_SECRET_TOKEN) { return res.status(401).json({ message: \u0026#34;Invalid token\u0026#34; }); } try { //# 해당 경로 페이지 revalidation await res.revalidate(`/${req.query.testId}`); return res.json({ revalidated: true }); } catch (err) { return res.status(500).send(\u0026#34;Error revalidating\u0026#34;); } } .env\nNEXT_PUBLIC_MY_SECRET_TOKEN= ","date":"28 August 2022","permalink":"/posts/projects/%EB%95%A1%EB%95%A1%EB%8A%A5%EB%A0%A5%EC%8B%9C%ED%97%98/2/","section":"Posts","summary":"로컬 DynamoDB 연결 #우선 Docker를 사용해서 로컬에 DynamoDB를 만들었다.","title":"[땡땡능력시험] DynamoDB 연결 및 기능 구체화"},{"content":"\n","date":"27 August 2022","permalink":"/posts/studies/css/styled-components/1/","section":"Posts","summary":"","title":"[Styled-components] 시작하기"},{"content":"기획 이유 #가끔씩 대학수학능력시험을 패러디한 게시물들을 볼 수 있는데, 대부분이 이미지나 PDF로 만들어져 있다. 그래서 이런 게시물들을 웹 사이트를 통해 쉽게 만들고 공유할 수 있게 하면 좋을꺼 같다는 생각을 했다.\n예시 구상 #우선 디자인은 심플한 시험지 느낌으로 갈 거라 크게 어렵지 않을 것이다. 흑백을 기본으로 라이트 모드와 다크 모드를 구현할 것이다.\n다음으로 필요한 기능은 크게 시험을 만드는 기능과 푸는 기능 그리고 로그인 기능이 있다.\n시험 문제는 질문과 보기로 이루어질 것인데 문제 유형 별로 지문과 이미지가 들어갈 것이다. 추가로 정답 지정과 함께 해설도 넣을 수 있게 할 것이다. 또란 배점의 합이 100점이 아닐 경우 만들기는 완료되지 않을 것이며, 마지막 페이지에서 자동 분배 혹은 질문의 목록과 함께 배점을 설정할 수 있게 해줄 것이다. 마지막으로 자신이 만든 문제는 복사도 가능하게 할 것이다.\n문제를 풀 때는 페이지 네이션을 통해 문제 간 이동을 쉽게 하고, 문제를 다 푼 후 점수와 등수를 확인하고 공유할 수 있게 할 것이다.\n로그인은 문제를 만들 때 필요하다. 로그인 상태에서는 북마크 한 토론, 내가 만든 토론, 내가 푼 토론을 확인할 수 있을 것이다. 그리고 당연히 정보 수정도 가능할 것이다.\nDB 초안 #시험 문제의 형태와 개수가 정해져 있지 않고, 데이터의 업데이트가 빈번하지 않으며 각 정보들이 복잡한 관계로 얽혀있지 않아 NoSQL을 사용할 것이다\n시험: { id: uuid, 표지: image, 제목: string, 작성자: string, 작성일: date, 문제들: { 배점: number, 질문: string, 지문?: string | image, 보기1: string | image, ... 정답: number, 해설?: string }[], 푼 사람 수: number[] 점수 총점: number[] } 사용자 : { id: uuid, 닉네임: string, 이메일: string, 비밀번호: string, 푼 시험들: {시험id: uuid, 점수: number}[] 북마크한 시험들: uuid[] } 와이어 프레임 초안 - main #최대한 깔끔하게 만드는 것이 목표이다.\n기술 스택 #우선 코드의 안전성을 위해서 TypeScript를 사용할 것이다. 다음으로 시험 문제는 한번 만들어지면 변경되지 않을 것이라 SSG를 사용하기 적합하고, 이를 위해 Next.js를 사용할 것이다. 앱 내부에서 사용하는 전역 상태는 크게 없고, 서버에서 받아온 데이터를 주로 다루게 될 거라 React-query를 사용할 것이다. 마지막으로 JS의 상수와 함수를 스타일에도 활용하기 위해 Styled Components를 사용할 것이다.\n데이터 베이스는 NoSQL이면서 서버리스로 사용할 수 있는 AWS의 DynamoDB를 사용하기로 했다.\nProject Init #[PR] - https://github.com/YuchanJeong/ddangddang-avility-test/pull/1\nnpm install\nnpx create-next-app --typescript [project-name] --use-npm npm i -D eslint prettier eslint-config-prettier @typescript-eslint/eslint-plugin tsconfig.json +\n\u0026#34;target\u0026#34;: \u0026#34;es6\u0026#34;, .eslintrc.json\n{ \u0026#34;plugins\u0026#34;: [\u0026#34;@typescript-eslint\u0026#34;], \u0026#34;extends\u0026#34;: [ \u0026#34;next/core-web-vitals\u0026#34;, \u0026#34;plugin:@typescript-eslint/recommended\u0026#34;, \u0026#34;plugin:import/recommended\u0026#34;, \u0026#34;prettier\u0026#34; ], \u0026#34;rules\u0026#34;: { \u0026#34;react/react-in-jsx-scope\u0026#34;: 0, \u0026#34;import/order\u0026#34;: [ \u0026#34;error\u0026#34;, { \u0026#34;groups\u0026#34;: [ \u0026#34;builtin\u0026#34;, \u0026#34;external\u0026#34;, \u0026#34;internal\u0026#34;, [\u0026#34;parent\u0026#34;, \u0026#34;sibling\u0026#34;, \u0026#34;index\u0026#34;], \u0026#34;unknown\u0026#34; ], \u0026#34;alphabetize\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;asc\u0026#34;, \u0026#34;caseInsensitive\u0026#34;: true }, \u0026#34;newlines-between\u0026#34;: \u0026#34;always\u0026#34; } ] } } .prettierrc.json\n{ \u0026#34;arrowParens\u0026#34;: \u0026#34;always\u0026#34;, \u0026#34;bracketSpacing\u0026#34;: true, \u0026#34;htmlWhitespaceSensitivity\u0026#34;: \u0026#34;css\u0026#34;, \u0026#34;insertPragma\u0026#34;: false, \u0026#34;jsxBracketSameLine\u0026#34;: false, \u0026#34;jsxSingleQuote\u0026#34;: false, \u0026#34;printWidth\u0026#34;: 80, \u0026#34;proseWrap\u0026#34;: \u0026#34;preserve\u0026#34;, \u0026#34;quoteProps\u0026#34;: \u0026#34;as-needed\u0026#34;, \u0026#34;requirePragma\u0026#34;: false, \u0026#34;semi\u0026#34;: true, \u0026#34;singleQuote\u0026#34;: false, \u0026#34;tabWidth\u0026#34;: 2, \u0026#34;trailingComma\u0026#34;: \u0026#34;all\u0026#34;, \u0026#34;useTabs\u0026#34;: false, \u0026#34;vueIndentScriptAndStyle\u0026#34;: false } .vscode/settings.json\n{ \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.fixAll.eslint\u0026#34;: true }, \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34;, \u0026#34;css.lint.unknownAtRules\u0026#34;: \u0026#34;ignore\u0026#34; } next.config.js\n/** @type {import(\u0026#39;next\u0026#39;).NextConfig} */ const nextConfig = { reactStrictMode: false, swcMinify: true, }; module.exports = nextConfig; .gitignore +\n.gitconfig .env .babelrc\nnpm i -D babel-plugin-styled-components { \u0026#34;presets\u0026#34;: [\u0026#34;next/babel\u0026#34;], \u0026#34;plugins\u0026#34;: [\u0026#34;babel-plugin-styled-components\u0026#34;] } Ps. src/\nConvention #Case # Type Case 파일 snake_case 컴포넌트 PascalCase 변수 camelCase(명사) *배열: -(e)s, listOf- 함수 camelCase(동사) 상수 UPPER_DELIMITER_CASE 클래스(CSS) kebab-case, B__E—M 테이블(DB) PascalCase 키(DB) camelCase(명사) *배열: -(e)s, listOf- Comment # 코드는 의미를, 주석은 의도를 (개발자의 글쓰기-김철수)\nExport 하는 대상\n/** * \\# 설명1 / 설명2 / ... * @param 인자 ?(필수 요소가 아닐 때) `타입;`(타입이 명시되지 않는 경우) 인자 설명 * @returns 반환값(e.g. \\{`title`: 제목,`author`: 작성자}) */ 주석 레벨\n//# --- (1) //\u0026gt; --- (2) //- --- (3) //. --- (4) Branch # Type Pattern Description Main main 가장 최신에 배포 된 버전 Development dev 완성된 기능들을 모아 두는 곳 Feature feat/branch_name dev에 병합 Hotfix hotfix/branch_name main에 병합 Commit #[Type] Title # ---------- # [Add] 기능 추가 # [Delete] 기능 삭제 # [Update] 기능 개선 # [Change] 기능 변경 # [Modify] 오타 수정 및 코드 정돈 # [Fix] 문제 해결 # [Setting] 설치 및 설정 # [Style] 스타일 관련 작업 # [Docs] 문서 관련 작업 # [Test] 테스트 관련 작업 # [Hotfix/Type] main 혹은 dev에 바로 Push # ---------- # 개조식으로 작성 # 내용이 필요할 경우 제목에서 한 줄 띄우고 작성 # 내용이 여러 줄일 때는 \u0026#34;-\u0026#34;로 구분 # \u0026#34;어떻게\u0026#34; 보다는 \u0026#34;무엇을\u0026#34;, \u0026#34;왜\u0026#34;를 설명 Etc # 기명 함수 컴포넌트 사용 (bcs of \u0026ldquo;Props 타입 구체적 명시\u0026rdquo;) const 최우선 사용, var 사용 금지 interface는 I-, type은 T-로 타입명 시작 ","date":"27 August 2022","permalink":"/posts/projects/%EB%95%A1%EB%95%A1%EB%8A%A5%EB%A0%A5%EC%8B%9C%ED%97%98/1/","section":"Posts","summary":"기획 이유 #가끔씩 대학수학능력시험을 패러디한 게시물들을 볼 수 있는데, 대부분이 이미지나 PDF로 만들어져 있다.","title":"[땡땡능력시험] 기획 및 초기 설정"},{"content":"","date":null,"permalink":"/tags/styled-components/","section":"Tags","summary":"","title":"Styled-components"},{"content":"토론 카드 목록 배치 문제 #*Pull Request\n필터링이 적용 되었을 때 토론 카드 목록이 이상하게 배치되는 문제를 발견했다.\nuseInfiniteQuery의 목록은 pages 내부의 각 page에 담겨있는데 이것이 원인이었다. 자세히 설명하자면 pages를 flex-box로 감싸면 page에 반영이 되지 않아, pages를 flex-box로 삼아 page도 감싸줬다. 그래서 필터를 통해 다른 pages의 item들이 붙게 되면 문제가 생긴다. 그래서 flat을 통해 평탄화 시켜줬더니 해결됐다.\nuseEffect(() =\u0026gt; { setListOfDebates(() =\u0026gt; { return debates.data ? debates.data?.pages .map((page) =\u0026gt; page.list.filter((debate: TDebateOfDebates) =\u0026gt; { const status = debate.video_url ? STATUSES[2] : debate.participant?.id ? STATUSES[1] : STATUSES[0]; return checkFilters( statuses, status, categories, debate.category ); }) ) .flat() : []; }); }, [categories, debates.data, statuses]); Ps. 노가다 반응형 로직 삭제 #[참조]\n요소들의 크기는 반응형 디자인을 위해 rem을 사용했고, 미디어 쿼리는 px를 사용하기 때문에 기존의 노가다 반응형 로직은 글씨 크기가 다른 브라우저에서는 제대로 작동하지 않았다. 그래서 사용자에게 일관된 UI를 제공하기 위해 미디어 쿼리를 사용하지 않고 flex: wrap;만 사용해서 목록을 구현했다.\n소소한 개선들 #*Pull Request\n초기 렌더링 시 debateId가 undefined일 때 요청하는 문제 해결 (by enabled) 리액트 쿼리 수화 기능 삭제 좋아요 목록 즉시 반영 토론 게시물에서 좋아요를 누운 다음 목록으로 돌아왔을 때 좋아요 토론 목록이 변경되지 않았다. 좋아요를 누르는 로직에서 좋아요 목록의 쿼리를 무효화하는 방식으로 쉽게 해결했다. 이 과정에서 좋아요 목록의 쿼리 키로 queryKeys를 사용하고 있지 않아서 그 부분도 수정해 줬다. v2.1.3 마무리 그리고 #아직 개선 사항들은 남았지만 v2.1.3을 마지막으로 주 일과로 debate-ducks 프로젝트를 개발하는 일은 마무리하고자 한다. 지금부터는 취업 준비와 영어 공부를 하면서 우선 만족스럽게 사용하지 못한 Next.js를 제대로 사용해 보고자 한다. 그 후 React Native를 공부해서 앱을 하나 만들어 보고 싶다.\n추가 사항 목록\n쪽지 기능 특정 사용자의 작성 토론, 참여 토론, 작성 댓글 모아보기 페이지 관리자 페이지 점수 및 랭킹 제도 Ps. 실제 토론 영상도 하나 찍어야 한다❗️\n","date":"24 August 2022","permalink":"/posts/projects/debate-ducks/29/","section":"Posts","summary":"토론 카드 목록 배치 문제 #*Pull Request","title":"[Debate-Ducks] 소소한 문제들 해결"},{"content":"","date":"24 August 2022","permalink":"/posts/studies/react/react-native/od-1/","section":"Posts","summary":"","title":"[React Native] 공식 문서로 공부하자!"},{"content":"","date":null,"permalink":"/tags/react-native/","section":"Tags","summary":"","title":"React Native"},{"content":"정적 배포로 변경 #*Pull Request\n속도 저하 문제 #Next.js의 Pre-rendering을 사용하기 위해 Vercel에서 배포를 했다. 하지만 심각한 속도 저하의 문제가 있었고, 원인은 서버 배포를 하는 환경과 프런트 서버를 배포하는 환경이 다르기 때문이었다.\n배포 환경 개발 환경 정적 배포 #우리가 처음에 프런트의 배포에 EC2가 아니라 Vercel을 사용한 것은 배포 담당자의 AWS 프리 티어 용량을 초과할 수 있기 때문이었다. 그래서 이번에는 내 AWS의 EC2에 올리기로 했다. 하지만 기본 프리 티어의 메모리로는 우리 프로젝트를 감당할 수 없었다.\n그래서 빌드 파일을 따로 깃 허브 저장소에 올리려고 했으나 파일 하나당 용량(100mb)이 초과해서 빌드 파일을 push할 수 없었다. git LFS를 사용해 파일을 잘게 쪼게서 올리는 방식도 있었으나 당장 많은 처리가 수동으로 필요했고 결국 s3에 정적으로 배포하기로 결정했다.\n이 과정에서 동적 라우팅 된 페이지에서 새로고침 시 주소를 찾지 못하는 문제를 해결하기 위해 동적 라우팅을 빼고 쿼리로 대체했다.\n[debateId].tsx + /${debateId} -\u0026gt; debate.tsx + /debate?debateId=${debateId}\n아쉬운 점 #이렇게 되고 나니 Next.js를 사용한 의미가 거의 없어졌다. 사실 기존에도 SSR만 사용했었기 때문에 Next.js를 제대로 활용하지 못했었고, 그래서 추가 학습을 통해 ISR(Incremental Static Regeneration)과 ODR(On Demand Revalidation)을 사용하는 법을 익히고 적용 방법을 고민했다. 특히 \u0026ldquo;사용자 수가 늘어나서 데이터의 변동이 잦을 때도 ISR과 ODR이 효과적일까?\u0026ldquo;에 대한 정답을 찾으려고 많은 노력을 했었다.\n지금 공부했던 내용들을 당장은 사용할 수 없어서 조금 아쉽지만 그래도 클라인트의 랜더링에 대해 더 깊게 이해할 수 있어서 만족한다. 해당 내용을 다음에는 꼭 활용해 보고싶다.\nPs. 확실히 첫 로딩은 체감되게 느려졌다. ㅜㅠ\n회원가입, 로그인 및 마이페이지 개선 #*Pull Request\n회원가입 및 로그인 페이지 짤림 문제 #회원가입 페이지와 로그인 페이지에서 창의 세로 길이가 줄어들었을 경우 잘림 현상과 함께 드래그도 할 수 없는 문제를 발견했다. 원인은 outer를 화면에 고정된 요소로 만들어 뒀기 때문이었다. 그래서 해당 부분을 제거해서 잘림 현상을 해결했다.\n그리고 align-items를 flex-start로 만들어 위로 튀어나옴 문제를 해결했다. 또한 outer에 padding을 주고 내부의 container에는 margin을 줘서 경계에 너무 붙지 않게 만들었다.\n변경 전 (회원가입) 변경 후 (회원가입) 기존 스타일 (회원가입)\n.outer { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: -1; } 변경 후 스타일 (회원가입)\n.outer { width: 100%; height: 100%; display: flex; justify-content: center; align-items: flex-start; padding: 1rem; z-index: -1; min-width: 22rem; } .container { margin: 2rem; } 비로그인 시 마이페이지 렌더링 #기존 마이페이지는 사용자 정보가 없을 때 제대로 처리하지 못하는 문제가 있었다. 처음에는 사용자 정보가 없을 때 에러 페이지를 렌더링 했으나 페이지 이동 혹은 로그아웃 시 깜박이듯 에러 화면이 노출되는 것이 마음에 들지 않았다. 그래서 사용자 정보가 없을 때 기본 이미지와 함께 로그인 버튼을 보여 주는 것으로 변경했다.\n기존 마이페이지 (비로그인 시) 개선 마이페이지 (비로그인 시) createObjectURL 에러 해결 #\r사용자 프로필 이미지 수정 후 저장하지 않고 파일 업로드 도달에서 취소를 누르면 에러가 발생했다. 적절한 타입이 아닌 데이터가 들어갈 경우 나는 에러로 handleChangeImage에 조건을 걸어서 걸러주는 것으로 해결했다. 추가로 revokeObjectURL를 사용해 메모리 누수를 막았다.\nconst handleChangeImage = (e: BaseSyntheticEvent) =\u0026gt; { if (!e.target.files[0]) return; setImage(e.target.files[0]); setPreviewImageUrl(window.URL.createObjectURL(e.target.files[0])); }; const handleImageSave = () =\u0026gt; { if (user.data) { ... window.URL.revokeObjectURL(previewImageUrl); } }; Ps. 추가로 이미지를 변경한 이후 다시 취소할 수 있게 버튼을 만들었다. 기타 문제 해결 # 회원가입, 로그인 및 마이페이지 최소 넓이 설정 마이페이지 placeholder 색상 회색으로 변경 (구분 용의) 회원가입 및 마이페이지 이름 유효성 검사 개선 (낱자를 뺀 한글, 영어, 숫자) ","date":"23 August 2022","permalink":"/posts/projects/debate-ducks/28/","section":"Posts","summary":"정적 배포로 변경 #*Pull Request","title":"[Debate-Ducks] 정적 배포로 변경 및 마이페이지 개선"},{"content":"사파리 브라우저에서 발생하는 문제들 해결 #*Pull Request\n*Issue\n이번 프로젝트의 개발과정에서 아쉬운 점은 크게 세 가지이다.\n개선 프로젝트라는 이유로 미리 기능들을 설계하고 작업에 들어가지 않아 작업과 설계를 동시에 한 점 TDD를 하지 않은 점 (하지만 이는 아직 때가 아니라고 생각해 의도적으로 하지 않음, 다음 프로젝트 때 도입 예정) 크로스 브라우징 이슈를 체크를 하지 않은 점 (적어도 크롬과 사파리 양쪽은 체크해야 했음) 특히 1번과 2번 문제는 내가 인식하고 있었지만 3번 문제는 취업 준비를 하면서 회사들의 자원 자격을 살펴보다가 \u0026ldquo;크로스 브라우저 트러블 슈팅 경험\u0026quot;을 보고 인지하게 되었다. (반성 of 반성 😢🙏)\n그래서 사파리에서 기능 테스트를 하고 몇 가지 치명적인 결함을 인지했다.\n비디오 멈춤 문제 #캔버스에 비디오가 그려지지 않고 멈추는 문제가 발생했다. 사용자의 뷰에서 비디오 요소가 벗어나면 캔버스에 더 이상 그릴 수 없는 문제와 비슷해 보였기 때문에 해당 부분을 바로 확인해 봤다.\n역시나 비디오의 크기가 0이 아니자 정상적으로 캔버스에 사용자의 비디오가 그려졌다. 크롬에서는 크기가 0인 비디오도 인식 하지만 사파리에서는 인식하지 못했다.\n그래서 이번에는 사용자의 비디오 크기를 0.1로 하고, z-index를 -1로 했더니 정상적으로 기능이 작동했다. (둘 중 하나의 처리만 해줘도 정상 작동함)\nmimeType is not supported #\r미디어 레코드를 녹화할 때 크롬은 mp4를 사파리는 webm을 지원하지 않았다. 그래서 try와 catch로 조건부 mimeType을 설정해서 해결했다.\nlet recorder; try { recorder = new MediaRecorder(mergedStream, { mimeType: \u0026#34;video/webm\u0026#34;, }); } catch (err1) { try { recorder = new MediaRecorder(mergedStream, { mimeType: \u0026#34;video/mp4\u0026#34;, }); } catch (err2) { toast.error(\u0026#34;녹화 준비에 실패 했습니다.\u0026#34;); } } Ps. HTMLMediaElement.captureStream()는 사파리에서 지원하지 않고, HTMLCanvasElement.captureStream()는 모든 브라우저에서 지원한다.\n화면 공유 중지 버튼 #\r사파리의 경우 화면 공유 시 크롬에서는 제공되는 컨트롤 바가 제공되지 않는다. 그래서 사용자가 원할 때 화면 공유를 끌 수 없었고, 화면 공유가 실행 중일 때 화면 공유 중지 기능을 추가해 줬다.\n화면 공유 컨트롤 바 Ps. 준비 버튼과 나가기 버튼의 색상을 검은색으로 변경했다. 현제 토글 버튼의 경우 버튼의 모양은 현재 상태(꺼져있는 상태는 파란색, 켜져있는 상태는 주황색)를, 글자는 눌렀을 때 어떤 기능을 할 것인지를 표시하고 있다. (Zoom의 버튼 표시 참조) 하지만 준비와 나가기의 경우 토글의 느낌으로 상태를 정의할 수 없다고 판단해 검은색으로 다르게 표시해 줬다.\n사파리용 폰트 #사파리에서는 getContext(\u0026quot;2d\u0026quot;)의 폰트 적용이 제대로 되지 않았다. ...getContext(\u0026quot;2d\u0026quot;).font의 기본값이 san-serif라 사파리 전용으로 Apple SD Gothic Neo를 넣어 줬더니 해결됐다.\nApple SD Gothic Neo 적용 전 Apple SD Gothic Neo 적용 후 스타일 통일 #select 요소의 스타일을 통일해줬다.\n//^IE select::-ms-expand { display: none; } //# SELECT 기본 스타일 제거 select { -webkit-appearance: none; -moz-appearance: none; appearance: none; //\u0026gt; 화살표 표시 background: url(\u0026#34;/images/arrow.png\u0026#34;) no-repeat 95% 50%/0.7rem auto; } 사파리 스타일 크롬 스타일 통일 스타일 소소한 문제들 해결 #*Pull Request\n에러 페이지의 이미지 경로가 상대 경로로 되어있어 절대 경로로 수정 검색 시 trim 적용 확인 모달 스타일 및 체험 토론 시작 메시지 수정 정식 토론에도 토론 영상 시간 추가 입장하기 조건 수정 ","date":"22 August 2022","permalink":"/posts/projects/debate-ducks/27/","section":"Posts","summary":"사파리 브라우저에서 발생하는 문제들 해결 #*Pull Request","title":"[Debate-Ducks] 크로스 브라우징 이슈"},{"content":"에러 페이지 제작 #*Pull Request\nAmazon의 에러 페이지에 귀여운 강아지가 있는 것이 마음에 들어서 참조했다. 또한 에러 페이지의 경우 마주하는 것만으로도 사용자가 불쾌감을 느낄 수 있는데, 이를 최소화하기 위해 귀여운 이미지를 사용하는 것은 좋은 방법이라고 생각해서 새끼 오리를 넣었다.\n그리고 푸터가 중간에 오고 아래 여백이 남는 상황이 발생하는 게 마음에 들지 않아 최소 높이로 기본 공간을 확보해 주고, 뷰의 높이에서 헤더와 푸터를 뺀 높이를 높이로 삼아서 푸터가 중간에 오는 일이 없게 만들었다.\nmin-height: 44rem; height: calc(100vh - 14rem); 스크롤 위치 기억하기 #*Pull Request\n토론 목록에서 토론 게시물 확인 후 목록으로 돌아갔을 때 목록의 처음으로 되돌아가는 문제가 있었다. 이를 해결하기 위해 전역 변수로 메인 페이지의 스크롤 위치를 저장해서 되돌아갈 때 해당 위치로 이동하게 만들었다.\n하지만 첫 페이지(무한 스크롤이라 눈에 보이는 페이지 구분은 없지만 요청은 페이지 단위로 일어남) 이상으로는 되돌아 가지 못하는 문제가 발생했다. 원인을 파악하던 도중 SSR에서 무한 스크롤은 첫 페이지만 가져온다는 점을 깨달았다. 그래서 SSR을 제거해 줬더니 잘 작동했다. 이 과정에서 SSR을 적용한 무한 스크롤이 마지막 페이지를 가져오지 못하는 문제도 발견했다. (SSR에 대해서는 추가 학습이 필요함 🔥)\n마지막으로 스크롤 이벤트의 발생 횟수를 조절하기 위해 debounce를 적용시켰다. throttle이 아닌 debounce를 적용 시킨 이유는 지연 시간을 300ms로 두고 헤더의 바로 아래까지만 스크롤을 했을 때, 아무것도 적용하지 않았을 때는 68번, throttle을 적용 했을 때는 612번, debounce를 적용 했을 때는 5번의 이벤트가 발생했기 때문이다. (왜 throttle을 적용했을 때 더 많은 이벤트가 발생하는지는 파악 실패) 또한 마지막 스크롤 위치만 기억하면 되는 현재 이벤트는 사용자가 이벤트를 발생 시키지 않고 끝까지 스크롤을 해도 상관없기 때문에 디바운스를 적용시켰다.\n//# 스크롤 위치 기억 //\u0026gt; 스크롤 저장 const handleSetScrollY = () =\u0026gt; { if (globalThis.location.pathname === \u0026#34;/\u0026#34;) setScrollY(window.pageYOffset); }; //\u0026gt; 스크롤 이동 useEffect(() =\u0026gt; { if (scrollY !== 0) window.scrollTo(0, scrollY); }, [scrollY]); //\u0026gt; 스크롤 감지 useEffect(() =\u0026gt; { const watch = () =\u0026gt; { window.addEventListener(\u0026#34;scroll\u0026#34;, _.debounce(handleSetScrollY, 100)); }; watch(); return () =\u0026gt; { window.removeEventListener(\u0026#34;scroll\u0026#34;, _.debounce(handleSetScrollY, 100)); }; }); Ps. 처음에는 카드를 눌러서 이동할 때 스크롤 위치를 저장할 까도 생각했는데, 그렇게 할 경우 게시물 확인 후 목록으로 되돌아온 다음 다른 페이지를 확인하고 다시 되돌아올 경우 이전 스크롤 위치로 돌아가기 때문에 스크롤 위치를 계속 저장하는 현재의 방식으로 결정했다.\n수화 불일치 문제 해결 #*Pull Request *Issue\n# 문제\n홈 \u0026amp; 탑 버튼 컴포넌트에서 수화 불일치 문제가 했다.\n# 원인\n사전 렌더링 된 React 트리와 브라우저에서 첫 번째로 렌더링 된 React 트리 간에 차이 때문에 발생한다. 대표적인 예로 window를 사용했을 때 발생할 수 있다.\nconst [scrollY, setScrollY] = useState\u0026lt;number\u0026gt;( typeof window !== \u0026#34;undefined\u0026#34; ? window.pageYOffset : 0 ); # 해결\n사전 렌더링 될 때 useState의 초깃값을 사용하게 되고, 브라우저에서 첫 번째로 렌더링 된 후 useEffect로 변경된 값을 사용하면 해결된다.\nconst [scrollY, setScrollY] = useState\u0026lt;number\u0026gt;(0); useEffect(() =\u0026gt; { setScrollY(window.pageYOffset); }, []); Etc #단순 주석 체계 수정 #*Pull Request\n//# //\u0026gt; //- 토큰 만료 시 삭제 #*Pull Request\n로컬 저장소에 저장되어 있는 토큰이 만료되었을 때 삭제해 줌으로써 필요 없는 요청을 방지했다.\nonError: () =\u0026gt; { window.localStorage.removeItem(\u0026#34;debate-ducks-token\u0026#34;); setTimeout(() =\u0026gt; { queryClient.setQueryData([queryKeys.users], () =\u0026gt; null); queryClient.invalidateQueries([queryKeys.users]); }, 100); }, 파일 이름 문제 #\r배포 시 빌드 에러가 발생했다. 로컬에서 테스트했을 때는 발생하지 않았고, 내 로컬에서 main을 그대로 pull 해서 확인해도 이상이 없었다. 하지만 다른 팀원이 당겨서 확인했을 때는 배포 때와 같은 에러가 발생했고 이유는 단순히 파일 이름이 달라서 생긴 문제였다.\n하지만 내 로컬에서만 파일 이름이 정상이었고 git status도 잡아내지 못했다. 찾아보니 파일 내용의 변경 없이 파일 이름만 바뀔 경우 이런 현상이 생길 수 있다고 한다. 다음부터는 주의해야겠다.\nwatch 모드 문제 #배포 버전에서 프로필 이미지 변경 시 해당 에러가 일어나 서버 담당자에게 문의했다. 검색 결과 watch 모드가 켜져 있을 때 발생하는 에러라서 watch 모드를 끄자 해결되었다고 전달받았다.\n해킹 시도!? #서버의 로그를 살펴보자 해킹 시도의 흔적으로 보이는 로그들이 찍혀있었다. 다행이 .env파일이 올라가있지 않고, FortiOS도 사용하고 있지 않아 문제는 없었으나 찝찝함이 남는다.\n추가) 하루 뒤에도 살펴보자 /manager 등의 정보가 있을만한 API로 계속해서 요청을 시도하고 있었다.\n","date":"20 August 2022","permalink":"/posts/projects/debate-ducks/26/","section":"Posts","summary":"에러 페이지 제작 #*Pull Request","title":"[Debate-Ducks] 에러 페이지 \u0026 스크롤 위치 기억하기"},{"content":"체험 토론 제작 #*Pull Request\n체험 토론을 따로 만들지만 유지 보수성을 위해 기존 토론의 코드를 그대로 사용하고 싶었다. 기존 토론을 만들 때 체험 토론을 고려하고 만들지 않았지만 기존 코드를 80% 이상 재활용하고 스타일은 100% 재활용할 수 있었다.\n토론 진행 기능 #자잘한 수정을 제외하면 크게 두 기능을 새로 만들었다. 우선 socket.io 대신 setInterval을 이용한 토론 진행 기능이다. 처음에는 handleDebate를 setInterval에 넣어서 작성했는데 제대로 작동하지 않았다.\nconst handleDebate = () =\u0026gt; { if (curDebate.turn \u0026lt; 7 \u0026amp;\u0026amp; curDebate.time \u0026lt; 1) { setCurDebate((prevState) =\u0026gt; ({ ...prevState, notice: debateProgress[prevState.turn + 1][0], turn: prevState.turn + 1, time: debateProgress[prevState.turn + 1][1], })); } else { setCurDebate((prevState) =\u0026gt; ({ notice: prevState.notice, turn: prevState.turn, time: prevState.time - 1, }));! } ... } setInterval이 시작할 때 정해진 curDebate값이 handleDebate 함수 내에서 변하지 않기 때문이었다. 그래서 setInterval로 1초마다 isDebating: boolean을 setIsDebating((prevState) =\u0026gt; !prevState)로 바꿔줬고 usEffect로 토론 진행을 시켜줬다.\nPs. 이번 기회로 왜 React에서 사이드 이펙트를 useEffect로 관리해야 하는지를 깨달았다.\nuseEffect(() =\u0026gt; { setCurDebate((prevState) =\u0026gt; { if ((prevState.turn === 7 \u0026amp;\u0026amp; prevState.time \u0026lt; 0) || !isStart) { return prevState; } if (prevState.turn \u0026lt; 7 \u0026amp;\u0026amp; prevState.time \u0026lt; 2) { return { notice: debateProgress[prevState.turn + 1][0], turn: prevState.turn + 1, time: debateProgress[prevState.turn + 1][1], }; } else { return { notice: prevState.notice, turn: prevState.turn, time: prevState.time - 1, }; } }); }, [DEBATE_INFO.title, debateProgress, isDebating, isStart]); // dependency에 isDebating 필요 녹화 기능 #다음으로는 녹화 기능이다. 오디오 스트림을 따로 합칠 필요도 없고 토론 종료 소켓 이벤트를 발동시킬 필요도 없어서 간단히 추가로 작성했다. 처음에는 토론을 시작할 때 recorderRef를 설정하고 녹화를 시작하게 했지만 20% 확률로 녹화가 진행되지 않는 문제가 있었다.\nrecorderRef의 설정과 녹화 시작이 너무 가까워서 그런가 하고 recorderRef의 설정을 방 입장 시 발생하는 useEffect에 넣어줬지만 여전히 문제가 해결되지 않았다.\n그래서 코드를 더 꼼꼼히 살펴보자 사용자의 stream을 비동기로 받아서 streamRef에 저장하는데, streamRef를 바로 사용하는 게 문제라는 것을 깨달았다. 그래서 사용자의 stream을 비동기로 받는 then의 내부에 녹화 설정 로직을 넣어서 해결했다.\nnavigator.mediaDevices .getUserMedia({ video: { facingMode: \u0026#34;user\u0026#34;, width: 500, height: 500 }, audio: { echoCancellation: true, noiseSuppression: true }, }) .then((stream) =\u0026gt; { streamRef.current?.getTracks().forEach((track) =\u0026gt; { track.stop(); }); streamRef.current = stream; if (videoRef.current) videoRef.current.srcObject = stream; //\u0026gt; 녹화 준비 const mergedAudioRef = stream.getAudioTracks(); const setRecorder = () =\u0026gt; { //- 30fps로 캔버스 요소 녹화 const canvasStream = canvasRef.current?.captureStream(30); ... } setRecorder(); }) 화면 녹화 문제 #\r갑자기 녹화 영상이 재생되지 않는 문제가 발생했다. 처음에는 여전히 코드가 잘못된 것인가 생각했지만 이전에 잘 재생되었던 다른 영상도 재데로 작동하지 않는 것을 보고 코드가 아닌 다른 문제라고 생각했다.\n생각해 보니 PR을 위해서 화면을 기록하던 도중에 녹화 영상이 재생되지 않아 그대로 다른 영상도 확인했었다. 화면 기록을 중지하고 다시 확인해 보니 이전에 잘 재생되었던 영상은 그대로 잘 재생됬고, 화면 기록과 동시에 녹화된 영상은 여전히 재생되지 않았다.\n해당 내용은 사용자에게 알릴 필요가 있다고 생각해서 Q\u0026amp;A에 추가하고 중요 표시(❗️)를 해줬다.\n영상 길이 표시 #이전에 피드백이 들어왔던 부분이기도 하고 개인적으로도 신경 쓰이던 부분이 영상의 전체 시간이 나오지 않는다는 점이었다. 처음 보게 되면 영상 길이가 0초가 나오기도 하며 스트리밍이 되면서 계속 늘어나는 형태였고, 그래서 사용자가 헷갈릴 수 있었다.\n이전에 Blob에 대해서 공부하면서 Blob의 메타 데이터에 대해서 알게 되었고, 추가로 알아보자 MediaRecorder는 메타 데이터에 영상의 길이(duration)을 포함하지 않는다는 것을 알게 되었다. 그래서 어떻게 추가할 수 있는지를 알아보았고 fix-webm-duration를 통해 추가했다.\n*fix-webm-duration npm 주소\nrecorderRef.current?.start(1000 / 30); startTimeRef.current = Date.now(); recorderRef.current.onstop = () =\u0026gt; { const duration = Date.now() - startTimeRef.current; const blob = new Blob(blobsRef.current, { type: \u0026#34;video/webm\u0026#34;, }); ysFixWebmDuration(blob, duration, { logger: false }).then((fixedBlob) =\u0026gt; { blobRef.current = fixedBlob; }); }; 기존 녹화 영상 개선 녹화 영상 Ps. 문제 해결 능력이 오르고 있다! #확실히 문제 해결 능력이 오르고 있는 것을 느끼는 중이다. 예전에는 문제가 생겼을 때 해결에 집중하고 원인을 파악하지 못해서 헤맸다. 이제는 확실히 문제를 일으키지 않는 부분, 문제를 일으킬 여지가 있는 부분, 문제를 일으킬 것으로 의심되는 부분을 구분해서 하나하나 확인하면서 문제의 원인을 먼저 파악하고 원인에 맞는 해결책을 찾았다.\n❗️문제 해결에서 가장 중요한 것은 문제의 원인 파악이다. 원인 파악이 안된 해결은 반의반의 반쪽짜리 해결일 뿐이다. 원인을 알아야 재발도 방지할 수 있다.\n","date":"19 August 2022","permalink":"/posts/projects/debate-ducks/25/","section":"Posts","summary":"체험 토론 제작 #*Pull Request","title":"[Debate-Ducks] 체험 토론"},{"content":"Q\u0026amp;A 페이지 제작 #*Pull Request\n한눈에 정보를 쉽게 찾을 수 있게 토글 형식으로 제작했다. 각 질문은 유지 보수성을 위해 배열에 정보를 입력했고, 이를 map을 통해 나열하게 만들었다.\nconst CONTENTS = [ { title: \u0026#34;토론에 어떻게 참여하나요?\u0026#34;, detail: \u0026#34;Debate Ducks에서 토론에 참여하는 방법은 두 가지입니다. 첫 번째는 [토론 만들기]를 통해 토론을 만든 다음 참여자를 기다리는 것이고, 두 번째는 참여 가능한 토론에서 [참여하기]를 통해 다른 사람이 만든 토론에 참여하는 것입니다. 참여자가 있는 토론은 대기 중인 토론이 되며, 참여자는 [입장하기]를 통해 실시간 영상 토론방으로 입장할 수 있습니다. 실시간 영상 토론방에서 참여자가 모두 [준비]한 경우 토론이 시작됩니다.\u0026#34;, }, ... ] CONTENTS.map((CONTENT, idx) =\u0026gt; (...) 열려있는 질문과 닫혀있는 질문을 구분하기 위해서 열린 질문의 인덱스를 저장하는 배열을 useState로 상태 관리했다. 그리고 해당 인덱스가 배열에 포함되어 있을 경우 열린 상태로 아닌 경우 닫힌 상태로 구분했다. 상세 설명의 경우 재랜더링을 최소화 하기 위해 닫힌 상태일 때 JSX에서 삼항 연산자를 사용하는 방법으로 감추지 않고 스타일을 display: none;으로 변경하는 방식으로 감췄다.\nPs. 재랜더링 최소화 고려는 이번에 처음 해봤다. 이후 리팩토링을 진행하거나 다른 프로젝트를 진행할 때는 이도 고려할 것이다.\nconst [openedDetail, setOpenedDetail] = useState\u0026lt;number[]\u0026gt;([]); const handleOpen = (num: number) =\u0026gt; { if (openedDetail?.includes(num)) { const idx = openedDetail.indexOf(num); setOpenedDetail([...openedDetail.filter((_, i) =\u0026gt; idx !== i)]); } else { setOpenedDetail([...openedDetail, num]); } }; const checkOpen = (num: number) =\u0026gt; { return openedDetail?.includes(num); }; \u0026lt;div className={checkOpen(idx) ? styles.open : styles.close}\u0026gt;...\u0026lt;/div\u0026gt; Etc #토론 목록 margin-bottom 변경 #*Pull Request\n토론이 없을 때 나타나는 문구의 스타일이 삼항 연산자 밖에 있어서 생긴 문제였다. 그래서 토론이 없을 때 나타나는 문구의 스타일을 삼항 연산자 안으로 옮겨서 해결했다.\n변경 전 변경 후 소소한 개선 #*Pull Request\n녹화 종료 시 Blob 목록 비우기 색상값 오타 수정 ($c-gray-dark -\u0026gt; $c-gray_dark) ","date":"18 August 2022","permalink":"/posts/projects/debate-ducks/24/","section":"Posts","summary":"Q\u0026amp;A 페이지 제작 #*Pull Request","title":"[Debate-Ducks] Q\u0026A 페이지"},{"content":"회원가입 개선 #*Pull Request\n기존에 회원가입 실패 시에도 콜백 로그인 페이지로 이동하는 문제가 있었다. 그래서 회원가입 성공 시에만 로그인 페이지로 이동할 수 있게 성공과 실패를 구분하는 인자를 콜백 함수에 넣어줬다.\nexport const postUser = (userInfo: IUserInfo, callback?: () =\u0026gt; void) =\u0026gt; { axios .post(`${process.env.NEXT_PUBLIC_API_URL}/users`, userInfo) .then(() =\u0026gt; { if (callback) callback(); toast.success(\u0026#34;회원가입이 완료되었습니다.\u0026#34;); }) .catch((err: AxiosError\u0026lt;{ message: string }\u0026gt;) =\u0026gt; { if (callback) callback(); toast.error( `${err.response?.data?.message || \u0026#34;네트워크 에러가 발생했습니다.\u0026#34;}` ); }); }; SSR 도입 #*Pull Request\n기존에는 AWS의 s3에 정적 배포를 해서 SSR을 사용하지 않았다. 하지만 정적 배포 시 다이나믹 라우팅된 주소를 읽지 못하는 문제가 발생했다. App 내에서 useRouter를 통한 이동은 가능하지만 새로고침이나 주소를 직접 입력할 경우 찾지 못했다. 😢 (html 파일이 [debateId].html로 나오니 어쩔 수 없는 문제) 다이나믹 라우팅 대신 쿼리를 사용하면 해결이 가능했지만, 우선 다이나믹 라우팅을 그대로 쓸 수 있게 vercel로 배포를 바꿨다.\n그래서 이제 SSR을 적용할 수 있었고 유저 정보가 필요하지 않은 정보들을 SSR로 요청하게 작성했다.\nimport { Hydrate, QueryClient, QueryClientProvider } from \u0026#34;react-query\u0026#34;; import { ReactQueryDevtools } from \u0026#34;react-query/devtools\u0026#34;; ... \u0026lt;QueryClientProvider client={queryClient}\u0026gt; \u0026lt;Hydrate state={pageProps.dehydratedState}\u0026gt; ... \u0026lt;/Hydrate\u0026gt; \u0026lt;ReactQueryDevtools /\u0026gt; \u0026lt;/QueryClientProvider\u0026gt; ... // /[debateId].tsx export const getServerSideProps: GetServerSideProps = async (context) =\u0026gt; { const debateId = typeof context.params?.debateId === \u0026#34;string\u0026#34; ? parseInt(context.params?.debateId) : 0; const queryClient = new QueryClient(); await queryClient.prefetchQuery([\u0026#34;debates\u0026#34;, `${debateId}`], () =\u0026gt; getDebate(debateId) ); await queryClient.prefetchInfiniteQuery([\u0026#34;comments\u0026#34;, `${debateId}`], () =\u0026gt; getComments(debateId, 1, \u0026#34;DESC\u0026#34;) ); return { props: { // prefetchInfiniteQuery를 사용할 시 필요함. (공식문서) // 추측으로는 쓸데없는 속성들 제거와 불변성 유지가 목적. dehydratedState: JSON.parse(JSON.stringify(dehydrate(queryClient))), }, }; }; 소소한 개선 #*Pull Request\n헤더 이벤트 범위 조정 #기존에 헤더의 모든 부분에 onClick 이벤트가 적용되어 있어서, 로고를 눌렀을 때만 변경되게 수정해 줬다.\n참여하기 실패 시 쿼리 무효화 #기존에는 동시간대에 두 명의 사용자가 참여하기를 누를 경우 늦게 누른 사용자는 이미 참여자가 있다고 toast 메시지로만 받게 되어 있었다. 하지만 이뿐만 아니라 쿼리를 무효화해서 참여하기 요청을 추가로 보내지 않을 수 있게 만들어 줬다.\nPs. 토론 목록에 바로 반영이 되게 하기 위해 토론 수정 시 토론 목록 쿼리 무효화를 해줬다.\n푸터 제작 #아주 간단한 푸터를 제작했다. Debate Ducks를 클릭하면 메인 페이지로, SuSang-YuHee를 클릭하면 팀 깃허브로 이동하게 만들었다.\n체험 로그인 제작 #미리 저장해둔 체험 아이디로 로그인 시키는 방식으로 우선 체험 로그인 기능을 제작하였다.\n뒤로가기 방지 안내 메시지 넣기 #뒤로가기 방지 시 안내를 통해 사용자가 알 수 있게 변경했다.\n","date":"17 August 2022","permalink":"/posts/projects/debate-ducks/23/","section":"Posts","summary":"회원가입 개선 #*Pull Request","title":"[Debate-Ducks] SSR 도입과 소소한 개선"},{"content":"로그인/로그아웃 시 좋아요 여부와 투표 여부 반영 문제 #*Pull Request\n*Issue\n# 문제\n로그인과 로그아웃 시 좋아요 여부와 투표 여부가 제대로 반영되지 않는 문제 발생했다. (좋아요 여부와 투표 여부는 사용자 아이디와 토론 아이디를 받아서 표시하게 되는데 이게 제대로 반영되고 있지 않았음)\n# 원인\n이전에 로그인 시 잘 반영되는걸 확인 했었고, 이후 로그아웃 시 잘 반영 되는걸 확인 했었다. 하지만 로그아웃 기능 개발 후 로그인 시 잘 반영되는지 확인하지 않았던 것을 깨달았다.\n그래서 로그아웃 시 했던 처리를 살펴보자 치명적인 문제가 있음을 깨달았다. (그 당시에 이력서 제출 전에 작업을 끝내기 위해 빠르게 개발하느라 확인이 미흡했음. 급할수록 사전 구상을 덜하고 작업에 들어가기 때문에 사후 확인을 더욱 철저하게 할 필요가 있는데\u0026hellip;반성합니다🙏)\n로그아웃은 따로 api가 없어서 (서버에서 미구현) 토큰을 지우고 쿼리에 저장된 사용자 정보를 직접 setQueryData로 날리는 방식으로 구현했고 잘 작동했다. 그래서 그 직후 좋아요 여부와 투표 여부도 useEffect를 사용해 비슷하게 구현했다. 하지만 해당 방식으로는 현재 페이지의 좋아요 여부와 투표 여부만 변경되는 치명적인 문제가 있었다. 그 당시에는 한 페이지에서만 확인을 끝내서 발견하지 못했던 문제이다.\n추가로 내가 처음 이 문제를 인지하게된 부분인데, 로그인 상태에서 새로고침 시 좋아요 여부와 투표 여부가 null로 변경되는 문제가 있었다. 이유는 새로고침 시 사용자 정보를 받기 이전에 useEffect 내부의 로직이 작동해 쿼리에 null이 저장되고 기본 설정이 staleTime: infinity;기 때문에 사용자 정보를 받은 뒤 추가 요청이 일어나지 않아서 발생한 문제이다.\n// Bad!! 로그아웃 시 좋아요 여부와 투표 여부 처리 useEffect(() =\u0026gt; { if (!user.data) { queryClient.setQueryData([queryStr.hearts, `${debateId}`], () =\u0026gt; null); queryClient.setQueryData([queryStr.votes, `${debateId}`], () =\u0026gt; null); } }, [debateId, queryClient, user.data]); # 해결\n우선 invalidateQueries는 useMutation 내부에서 사용하지 않으면 작동하지 않는다. 하지만 현제 로그아웃 api가 없어서 useMutation을 사용하기 애매했다. 그래서 쿼리의 값과 상관없이 로그아웃 상태에서 좋아요 여부가 false가 나오게 조건에 사용자 정보 여부를 추가했다. (투표도 마찬가지)\nheart.data \u0026amp;\u0026amp; user.data ? styles.heart_fill : styles.heart_empty; 하지만 이렇게만 처리할 경우 사용자가 로그아웃 후 다른 아이디로 로그인했을 때 기존 쿼리에 저장된 값이 유지되는 문제가 있었다. 그래서 로그인 시 해당 쿼리들을 무효화하는 방식을 사용했다. (기존에는 로그인 시 토큰을 쿼리가 아닌 로컬 저장소에 저장하기 때문에 따로 useMutation을 사용하지 않았으나 쿼리 무효화를 위해 변경)\nqueryClient.invalidateQueries([queryStr.users]); queryClient.invalidateQueries([queryStr.hearts]); queryClient.invalidateQueries([queryStr.votes]); Ps. 가장 쉽게 처리하는 방법은 staleTime을 짧게 두는 것이다. 하지만 그럴 경우 요청의 수가 많아지게 되고 이를 원하지 않아 다른 해결 방법을 고민했다.\nPs. 이번에 문제가 발생한 이유는 A를 개발하고 확인한 뒤, B를 개발하고 확인할 때 B만 확인했기 때문이다. 하지만 개발이 쌓일수록 앞의 모든 기능을 직접 하나씩 확인하기 힘들기 때문에 테스트 주도 개발의 필요성을 절실히 깨달았다.\n코드 정돈 및 개선 #*Pull Request\n주석 #주석을 제대로 달면서 작업하지 않았기 때문에 지금이라도 주석을 달아서 코드의 가독성을 높이고자 한다. 하지만 주석을 제대로 활용하고 있는지 모르겠다. 나는 주로 구분 용도로 활용하고 있으며, 함수의 경우에는 어떤 기능을 하는지를 간단히 설명하고 있다.\n//* 텍스트 인풋 요소의 value 관리 //* ex. const exampleInput = useInput(\u0026#34;초기값\u0026#34;, \u0026#34;\u0026#34;) / \u0026lt;input {...exampleInput.attribute} /\u0026gt; export const useInput = (...) =\u0026gt; {...} 코드는 의미를, 주석은 의도를 (개발자의 글쓰기-김철수)\n토론 중 차례 넘기기 #넘기기 버튼은 자신의 차례일 때 남은 시간이 1분 미만일 경우에만 사용할 수 있다. 기존에는 사용이 불가능할 때 버튼을 누르면 toast 메시지로 현제 사용할 수 없다고 알려주는 방식을 사용했다. 사용 불가능 상태를 따로 만들 경우 시간을 계속해서 추적하면서 재랜더링이 일어나기 때문이다.\n하지만 사용자 입장에서 사용 불가능한 버튼이 활성화되어 있는 게 마음에 들지 않아 시간을 추적해서 사용 시간이 아닐 때 버튼을 사용 불가능하게 만들었다. 이후 재랜더링이 계속 일어나는 단점을 해결하기 위해 시간을 추적하지 않고 해당 시간이 1분 미만인지를 추적하는 방식으로 변경했다. 마지막으로 넘기기 가능 시간을 2분 미만으로 변경했다.\n넘기기 불가능 넘기기 가능 로그아웃 모달 및 마이페이지 #로그아웃 부분을 수정하다가 같은 기능을 코드 복사 붙여넣기로 구현해 놓은 것을 봤고, 유지 보수성을 위해 이를 하나의 로그아웃 모달로 통합했다.\n로그아웃 모달 적용 과정에서 마이페이지를 살펴봤고, 에러와 개선이 필요한 점들을 발견했다. 이를 마이페이지를 담당한 팀원분께 전달하고 그 분이 바쁘실 경우 추후 내가 작업할 예정이다. (❗️작업 완료 [참조])\n이름 유효성 검사(회원가입에서도 필요), createObjectURL 에러 해결 [참조], 페이지 접근 권한 설정, 프로필 변경 취소 버튼 제작 인풋에 placeholder 색 구분 *참조\n리액트 쿼리 # queryStr으로 명명되어 있던 쿼리의 키들을 좀 더 명확하게 queryKeys로 변경했다. 쿼리 내에서 toast 메시지가 너무 많이 사용되고 있어서, 사용자가 변경을 바로 인지할 수 있는 경우는 toast 메시지를 보여주지 않게 바꿨다.\nPs. 메시지나 모달의 어투를 통일성 있게 맞췄다. 사용자 정보 변경 시 변경된 프로필 이미지나 이름이 적용될 수 있게 토론 및 댓글 목록의 쿼리를 무효화해줬다. 그리고 비밀번호는 사용자 쿼리에 저장되지 않기 때문에 비밀번호 변경 시 사용자 정보의 쿼리 무효화를 제거해 줬다. 회원가입 중 모달 #회원가입 실패 시 \u0026ldquo;회원가입 중 모달\u0026quot;이 닫히지 않아 catch에도 모달을 닫는 로직을 추가했다.\n타입명 #타입명을 interface는 I로, type은 T로 시작하게 변경\nPs. 컴포넌트 코드 정돈 및 개선은 추후 작업 예정\n","date":"16 August 2022","permalink":"/posts/projects/debate-ducks/22/","section":"Posts","summary":"로그인/로그아웃 시 좋아요 여부와 투표 여부 반영 문제 #*Pull Request","title":"[Debate-Ducks] 로그인/로그아웃 문제 해결과 코드 정돈 및 개선"},{"content":"헤더 개선 및 기타 에러 해결 #*Pull Request\n빈 팩트체크 표시 # 기존 팩트체크 변경 후 팩트체크 투표 - 0표일 때 처리 # 기존 투표 변경 후 투표 로그아웃 기능 개선 #기존에는 로그아웃 시 로컬 저장소에서 토큰을 지우고, 메인 페이지로 보내주는 방식으로 되어있었습니다. 그래서 변경된 사항이 바로 사용자의 화면에 반영되지 않았다.\n해당 부분의 개선을 위해 queryClient.setQueryData([queryStr.users], () =\u0026gt; null); 처리를 해줘서 유저 접어보의 변경이 사용자의 화면에 바로 변경되게 하고, 메인 페이지로 보내는 기능은 필요 없다고 생각해 삭제했다.\n헤더 스타일 변경 # 기존 헤더 (반응형 X) 변경 후 헤더 (반응형 O) 이미지 경고 해결 #이미지 관련 경고들이 떴는데 경고에 해결 방법이 명시되어 있어서 쉽게 해결했다.\n이미지에 priority={true} 추가 부모 요소에 position: relative; 추가 회원가입 및 로그안 개선 #*Pull Request\n기존에는 로그인 시 메인 페이지로 보내는 방식으로 되어있었다. 하지만 로그인 직후 원래 보던 페이지로 돌아가는 게 더 적합하다고 판단해서 세션에 경로를 저장하는 방식으로 구현했다.\n이 기능을 추가했기 때문에 이전에 만들었던 로그인 모달은 삭제해 줬다. 추가로 스크롤 위치도 기억해서 되돌아갈 수 있게 업데이트할 예정이다. useEffect(() =\u0026gt; storePathValues, [router.asPath]); function storePathValues() { const storage = globalThis?.sessionStorage; if (!storage) return; const prevPath = storage.getItem(\u0026#34;currentPath\u0026#34;); storage.setItem(\u0026#34;prevPath\u0026#34;, prevPath || \u0026#34;\u0026#34;); storage.setItem(\u0026#34;currentPath\u0026#34;, globalThis.location.pathname); } login(userInfo.email, userInfo.password, () =\u0026gt; { router.push(\u0026#34;/\u0026#34;); queryClient.invalidateQueries([queryStr.users]); user.refetch(); const storage = globalThis?.sessionStorage; const link = storage.getItem(\u0026#34;prevPath\u0026#34;) === \u0026#34;/signin\u0026#34; || storage.getItem(\u0026#34;prevPath\u0026#34;) === \u0026#34;/signup\u0026#34; ? \u0026#34;/\u0026#34; : storage.getItem(\u0026#34;prevPath\u0026#34;) || \u0026#34;/\u0026#34;; router.push(link); }); 추가로 회원가입 시 비밀번호 암호화 과정으로 인해 발생한 대기시간 동안 대기 안내 모달을 띄워 사용자에게 알려주는 기능을 추가했다.\n토론 목록 상태관리 리덕스 사용 #*Pull Request\n토론 목록에서 필터링을 적용하거나 검색을 한 다음 토론 게시물을 보고 다시 돌아왔을 때 상태를 여전히 기억하고 있어야 한다. 하지만 기존에는 useState로만 지역적으로 관리되고 있었다. 그래서 리덕스를 사용해서 전역 상태로 관리하기로 했다.\nContext API를 사용하지 않은 이유는 Context API로 관리되는 상태 값을 변경하면, Provider로 감싼 모든 자식 컴포넌트들이 릭 렌더링 되기 때문에 추가로 방어 코드를 작성해 줘야 하기 때문이다. 즉 Context API는 상태 관리보다는 정적인 값에 가까운 데이터를 전역적으로 사용할 때 사용하기 적합해서 이번에는 사용하지 않았다.\n추가로 스크롤 위치도 기억해서 되돌아갈 수 있게 업데이트할 예정이다. Ps. 간단한 회고 # 기존 프로젝트에서 완성하지 못했던 기능 완성 및 아쉬웠던 기능 개선. 아쉬웠던 UI/UX 개선. 코드의 가독성 및 유지 보수성 개선. 기간의 압박으로 도입하지 못했던 새로운 스택들 도입. 협업의 방식을 효율적으로 개선. 위의 목록은 개선 프로젝트를 시작할 때 새웠던 목표 들이다.\n우선 기존 프로젝트에서 완성하지 못했던 토론 게시물 페이지까지 완성은 했다. 그리고 React-query를 활용한 기본 CRUD에서 기능적인 개선도 있었다. 추가로 실시간 토론 진행에서 넘기기 기능, 차례에 맞는 오디오 및 화면 공유 그리고 토론 목록에서 좋아 요한 토론만 보기 등 사소한 개선 사항들도 많았다.\n하지만 체험 페이지, Q\u0026amp;A 페이지, 특정 유저가 쓴 글/댓글 살펴보기, 랭킹 페이지 등 이전에 계획했던 추가 기능들을 넣지는 못했다. 특히 동영상 저장의 부담을 피하고자 구상했던 Youtube 자동 업로드 방식은 Youtube의 정책 변화로 더 이상 이용할 수 없었다. 개인적으로 클라이언트만 건드려서 추가 가능한 부분들부터 우선적으로 업데이트하고 서버가 필요한 부분은 서버 담당자에게 요청하고 만약 서버 담당자가 바쁘다면 직접 서버 부분도 만들어볼 생각이다.\n다음으로 UI/UX 부분은 직관성을 이전보다 더 고려 하면서 작업했다. 특히 이미지와 영어로 표현된 많은 정보들과 생략된 정보들을 한글로 직관적으로 바꿔줬다. 유효성 검사 부분에서도 사용자가 최대한 추가 작성을 할 필요 없게 잘 표시해 줬다. 무엇보다 이전에는 하지 못했던 반응형 작업도 했다. 또한 라우팅 부분도 무조건 메인 페이지로 보내는 것이 아닌 적합한 페이지로 보내는 방식을 사용했다.\n코드의 가독성 및 유지 보수성은 아직 많이 부족하지만 이전과 비교했을 때는 많이 개선되었다. 특히 토론 진행 부분에서 이전에는 각 토론 단계의 이벤트를 하나하나 적어 줬다면 이번에는 배열과 객체를 활용해 하나의 이벤트로 관리했다. 그 덕에 가독성은 물론 변경 사항이 있을 때 간단히 수정할 수 있게 됬다.\n개인적으로 이번 프로젝트 최고의 수확은 TypeScript 사용이다. 코드의 안정성 확보는 물론 협업 시 많은 도움이 되었다. 무엇보다 컴파일 단계에서 에러를 뱉어주기 때문에 JavaScript를 사용했다면 놓치고 지나쳤을 많은 에러들을 사전에 예방할 수 있었다. 앞으로도 단기간에 빠르게 작업해야하는 미니 프로젝트가 아닌한 TypeScript를 계속 사용할 것이다.\nNext.js의 경우 정적 배포를 해야해서 최고의 장점 중 하나로 꼽히는 SSR을 제대로 사용하지 못했다. 그래서 파일 기반 라우팅 등 개발 시점의 이득은 있었지만 사용 시점의 이득은 미비했다.\nReact-query의 경우는 확실히 만족했다. 사용 방법이 쉬웠으며 무엇보다 따로 처리해 줘야했던 많은 부분들을 다양한 옵션으로 쉽게 처리할 수 있었다. 또한 서버에서 받아오는 데이터와 클라이언트에서 관리하는 데이터를 확실히 구분할 수 있었기 때문에 개발 단계에서의 혼란을 줄일 수 있었다.\nCSS에 많은 기능이 추가되고 있는 지금 SCSS는 점점 설자리를 잃어간다고 생각했다. 하지만 일단 사용해 보니 CSS로는 어렵게 처리해야 하는 부분을 훨씬 쉽게 처리할 수 있었다. (아직은 SCSS가 설자리가 충분히 있는 거 같다. 하지만 점차 CSS가 발전함에 따라 필요 없어지게 될 거 같다는 나의 생각에는 변화가 없다.) 무엇보다 이전에 사용했던 Tailwind CSS는 작업 속도 측면에서는 월등히 빨랐지만 가독성 면에서 많이 떨어져 협업이나 유지 보수 측면에서는 좋지 않았다. 하지만 SCSS Module로 작업하면서 해당 부분이 많이 개선되었다.\nNest.js의 경우는 Socket 부분을 작업할 때나 간단한 수정을 할 때 말고는 사용해 보지 않았으나 확실히 철저히 모듈화가 되어있어서 좋았다. 클라이언트 작업을 할 때도 서버 측의 코드를 쉽게 찾아서 살펴보고 그에 맞게 짤 수 있었다.\n협업의 방식은 조금 더 효율적이게 개선은 되었다. 이전에는 모든 것을 화상 회의로 결정했지만 이제는 화상 회의가 필요한 사항과 아닌 사항을 적절히 구분했다. 하지만 프로젝트 시작 시 기간을 정해두고 \u0026ldquo;이 기간 안에 각자 이 업무를 완성하자!\u0026ldquo;가 아닌 \u0026ldquo;각자 가능한 만큼 작업을 하자.\u0026ldquo;라고 시작했기 때문에 프로젝트 기간이 전반적으로 늘어지게 되었다.\n나 같은 경우는 비행기 티켓이 없어서 3일에 걸친 귀국을 했고 또 귀국하자마자 수술과 입원을 해서 컨디션까지 최악이었다. 그래서 6월부터 7월 중순까지는 제대로 된 작업을 하지 못했었다. 다른 팀원 한 분의 경우에는 따로 진행하는 프로젝트와 면접 준비 등으로 이 프로젝트를 할 시간이 부족해서 단기간 일부 기능만 참가 하셨다. 그래서 프로젝트 진행 기간 대비 결과물의 볼륨이 크지 않은점이 아쉽다.\n프런트 앤드 저장소 insights의 contributors Ps. 추후 계획 #우선 Q\u0026amp;A 페이지와 체험 토론 페이지 그리고 스크롤 위치 기억까지는 빠른 시일 내에 작업할 예정이다. 그 뒤로는 Vue 혹은 React-native를 사용해서 프로젝트를 만들어볼 것이다. 현재는 이왕 React 사용해온 만큼 React-native까지 React를 좀 더 끝장내자는 쪽으로 마음이 기울어 있는 상태이다.\n그리고 CS에 관련된 책을 읽으며 관련 지식을 늘려가고, 국내로 돌아온 만큼 영어 사용이 이전보다 현저히 줄어들어 추가로 영어 학습을 진행할 것이다. 현재는 OPIC을 준비해 볼까 생각하는 중이다.\n물론 떨어진 컨디션 회복을 위해 운동도 꾸준히 할 것이다.\n","date":"9 August 2022","permalink":"/posts/projects/debate-ducks/21/","section":"Posts","summary":"헤더 개선 및 기타 에러 해결 #*Pull Request","title":"[Debate-Ducks] 프로젝트 v2.0.0 마무리"},{"content":"실시간 영상 토론 에러 해결 및 스타일 적용 #*Pull Request\n내가 프로젝트에서 가장 먼저 한 작업이 실시간 영상 토론이다. 이 기능을 완성한 다음 다른 기능들을 작업하고, 기능 작업의 역순으로 스타일 적용을 하면서 기능의 개선도 함께 진행했다.\n기능을 완성한 다음 추가 작업을 한 적이 없는데, 스타일 적용을 위해 실시간 토론 기능을 확인하자 WebRTC 연결 에러가 발생했다.\n변경 사항이 없는데 갑자기 에러가 발생해서 매우 당황스러웠다. 이 때문에 실책을 하나 했다. 이미 기능이 너무 복잡해서 어디서 문제가 발생했는지 확인이 어렵다고 생각해 실시간 토론 기능을 우선 모두 삭제하고 다시 하나씩 확인하면서 재작업을 진행했다. (하지만 콘솔을 먼저 찍어봤으면 삭제 후 재작업 없이 확인이 가능했다. 🥲🥲🥲)\n재작업 과정에서 콘솔을 하나씩 찍으면서 확인했고, 먼저 연결이 두 번씩 진행되고 있는 문제를 발견했다.\n이 문제는 서버 측의 socket.io 입장 이벤트 조건을 추가하는 것으로 쉽게 해결했다.\nif (roomSize \u0026lt; 2 \u0026amp;\u0026amp; !roomId[socket.id]) { roomId[socket.id] = data.debateId; ... } else if (roomId[socket.id]) { } else { socket.emit(\u0026#34;overcapacity\u0026#34;); } 다음으로 연결 해제를 확인했는데, 페이지를 벗어났음에도 가끔씩 disconnect 콘솔이 찍히지 않는 것을 확인했다. 언제 찍히지 않는지를 확인 해보자 페이지의 이동이 App 내부에서 일어났을 경우에만 disconnect 이벤트가 발생하지 않았다.\n위의 두 번씩 진행되는 연결 문제를 이전에 발견하지 못한 것도, 현재 발생하는 WebRTC 연결 문제도 이 같은 이유였다. 이전에 작업할 때는 실시간 영상 토론 페이지밖에 없어서 뒤로 가기와 앞으로 가기를 테스트 할 때, App 외부에서 App 내부로만 이동이 있었고, router 버튼도 만들어져있지 않아 주소를 통해 직접 이동했기 때문에 이 문제를 발견하지 못한 것이었다. 이를 깨닫고 삭제했던 실시간 토론 기능을 git revert 했다.\n그래서 이전에 사용했던 뒤로 가기 방지 함수로 뒤로 가기를 막고, 페이지 이동 시 router 함수와 함께 피어와 소켓 연결을 끊어주는 로직을 적어 넣었다. 이 과정에서 페이지 이동 후에도 사용자의 미디어를 여전히 획득하고 있어서 이를 꺼주는 로직도 추가했다.\n미디어 획득 시 녹화 표시 추가로 스타일 적용과 함께 사용자에게는 상대의 영상이 연결된 시점이 연결이기 때문에 연결 여부의 기준을 피어에서 상대 미디어의 획득으로 변경했다.\n또한 기존에는 발언 시간에 발언자 외의 마이크는 음소거 했었는데, \u0026ldquo;소리가 작다\u0026quot;거나 \u0026ldquo;지금 음소거가 되어있다\u0026rdquo; 아니면 \u0026ldquo;공유 화면의 크기가 너무 작아서 조금만 키워달라\u0026rdquo; 등 요청이 필요할 수 있다고 판단해 차례 변경 시 음소거는 하되 다시 켤 수 있게 권한을 줬다.\n마지막으로 토론 진행 페이지에서는 헤더가 불필요하다고 판단해 정규 표현식을 이용해 빼줬다.\nreturn /\\/debateroom/.test(router.pathname) ? null : (...) 녹화 영상 s3 업로드 기능 추가 #*Pull Request\n토론 진행 페이지의 접근 가능 조건 중 하나가 토론에 video_url이 존재하는 지지 여부였기 때문에 업로드 즉시 에러 페이지로 가버리는 문제가 발생했다. 그래서 useMutation이 아니라 토론 종료 로직 내부에서 axios를 직접 사용해서 해결했다. (useMutation은 hook이라 컴포넌트 내부에서만 사용해야 함)\nPs. 기존에는 사용자가 이미지가 없는 경우 모두 회색 오리를 사용했는데, 현재 기본 이미지는 연두색 오리로 변경했고 비어있음 혹은 탈퇴한 회원의 경우에는 회색 오리를 그대로 사용했다.\n","date":"7 August 2022","permalink":"/posts/projects/debate-ducks/20/","section":"Posts","summary":"실시간 영상 토론 에러 해결 및 스타일 적용 #*Pull Request","title":"[Debate-Ducks] 실시간 영상 토론 진행 페이지"},{"content":" 해당 내용의 PR 주소 첨부 시작. 간단한 에러들 해결 #*Pull Request\n이미지 엑박 에러 #import Image from \u0026quot;next/image\u0026quot;;의 Image 태그에 unoptimized={true} 추가해서 엑박 에러를 간단히 해결했다.\n사실 unoptimized={true}를 사용하면 Image 태그를 사용하는 의미가 많이 퇴색되므로 추후 다른 방식으로 문제를 해결할 것이다.\n토론 게시물의 날짜 줄 바뀜 #원래 날짜는 한 줄로 표시되게 해뒀는데 확인 해보니 여러 줄로 표시되고 있었다. 상위 요소에 word-break: pre-line; 스타일이 추가되었기 때문이었다. 그래서 날짜 요소에 word-break: nowrap;를 주는 것으로 간단히 해결했다.\n메인페이지 대체 #*Pull Request\n이전 프로젝트의 경우 완성은 못했지만 기획 단계에서 토론 페이지 외에도 랭킹 페이지, 일반 게시물 페이지 등을 만들 계획을 세웠었다. 또한 그 당시에 코드스테이츠 측에서 제공해 준 참조 프로젝트들 대부분이 메인 페이지에서 어떤 프로젝트 인지를 설명하고 있었기 때문에 우리도 이를 따랐었다.\n하지만 현재는 볼륨을 줄이고 핵심 기능에 집중하기 위해 토론 페이지만을 남겨뒀고, 체험하기 기능과 프로젝트 설명은 따로 QnA 페이지로 뺄 계획이다. 이런 상황에서 프로젝트를 설명하는 메인 페이지는 일시적으로 방문하는 인사 담당자를 고려한다면 괜찮지만 자주 방문하는 실제 사용자를 고려한다면 버튼을 한 번 더 누르게 만드는 불만족 요소가 될 것이라고 판단했다.\n특히 이 프로젝트는 토론하기 기능을 사용하지 않는 이상은 단순한 게시판이다. 즉 보기만 할 때는 특별한 사용법이 필요하지 않다. 또한 대부분의 게시판 웹 사이트들은 메인 페이지에서 게시물 목록들을 바로 확인할 수 있게 해서 게시물에 대한 접근성을 높인다.\n이러한 점을 근거로 팀원들에게 해당 사안을 건의했고 만장일치로 설명글을 적을 예정이던 메인 페이지를 기존의 토론 목록 게시판으로 대체 하기로 결정됬다.\n참여하기 추가 #*Pull Request\n홈 및 탑 버튼 추가 #*Pull Request\n프로필 이미지 테두리 추가 #*Pull Request\n","date":"6 August 2022","permalink":"/posts/projects/debate-ducks/19/","section":"Posts","summary":"해당 내용의 PR 주소 첨부 시작.","title":"[Debate-Ducks] 토론 목록 및 게시물 기타 작업들"},{"content":" 이력서 구글 드라이브 링크\n프로젝트가 완성되어 감에 따라 그리고 마침 패스트벤처스 포트폴리오사 개발자 채용 연계라는 좋은 기회가 있어서 첫 이력서를 작성하게 되었다. 정확히 말하자면 첫 한글 이력서이다. 두바이에 있을 때 CV를 적어서 뿌렸던 적이 있기 때문이다.\n잡담 - 영어 인터뷰 #잠시 그때 이야기를 하자면 부트 캠프 수료를 끝낸 직후 두바이에서 일하는 여자친구가 다시 장거리 연애가 되는 게 싫어서 두바이에서 직장을 구하길 원했고, 나는 인터뷰 만이라도 좋은 기회가 될 거라고 생각해서 응했다.\n그렇게 총 세 번의 전화/화상 면접의 기회를 가졌는데 3번 중 두 번의 인사 담당자가 인도인이었고, 평상시 영어 실력의 반도 발휘할 수 없었다. (미국식 영어에만 익숙한 죄 😢 빨리 영어 실력을 더 늘려야겠다 🔥) 한 번은 그나마 호주 사람이어서 이야기는 잘 이어간 거 같다. 당연하다면 당연하게도 전부 탈락했다.\n하지만 사실 붙었다고 해도 갈 생각은 전혀 없었다. 인터뷰를 했던 회사는 모두 디자인 에이전시였고, 그들이 나에게 주로 물어본 내용은 CMS(Content Managements System)나 웹 빌더를 잘 다루는지였다. 물론 나는 제대로 다뤄본 적이 없었고, 그들은 내가 JavaScript 기반으로 React를 주로 사용하는 건 전혀 관심이 없었다.\n그래도 이 인터뷰를 통해 영어실력의 부족함을 다시 한번 깨달은 것에 매우 만족한다. (여자친구는 매우 아쉬워 했지만 😢)\n이력서 작성 준비 #이전부터 틈틈이 자료를 수집하고 나 스스로에 대해서 작성해뒀다. 하지만 수집한 자료는 대부분이 링크여서 다시 해당 링크를 타고 글과 영상을 하나하나 확인하면서 메모했다.\n키워드만 몇개 뽑아서 나열 하자면\n당연하지만 이력서에는 사실만을 적어라. 면접에서 다 티가 난다. 가장 강조하고 싶은 특징을 하나만 골라서 어필해라. 개발자 역량을 위주로 관련 없는 건 빼라. 어떤 문제를 만나서 어떻게 해결했는지를 적어라. 참조 링크가 있으면 좋다. 작성한 이력이 실질적으로 어떤 의미를 지니는지를 고민해라. 프로젝트 자체를 강조하지 말라. 프로젝트에서의 역할과 업무가 더 중요하다. 추상적으로 적지 마라. 이다.\n이력서 작성 #Why? 를 좋아하는 개발자 정유찬 #우선 2번 팁(가장 강조하고 싶은 특징을 하나만 골라서 어필해라.)을 고려해서 내가 가지고 있는 많은 특징 중에 지금 가장 내 성장에 도움이 되고 있는 특징이 무엇인지를 고민했다.\n고민의 결과로 얻은 답은 \u0026ldquo;왜?\u0026ldquo;를 묻는 것을 좋아한다는 점이었다. 원래부터 호기심이 많았던 나는 \u0026ldquo;왜?\u0026ldquo;를 달고 사는 사람이었다. 그래서 평소에 잡지식이 많다는 소리를 들으면서 살았는데, 이 특징이 개발 공부를 시작하자 엄청난 장점으로 다가왔다. 부트 캠프 과정에서 페어들이 보통 지나치는 내용을 나는 궁금해했고 그 결과가 프로젝트 단계에서 잘 드러났었다.\n예시를 하나 들자면 부트 캠프에서 setState에 대해서 배울 때 변하는 상태를 관리하기 위해서 사용한다면서 장바구니의 상품 개수를 예시로 설명을 해줬다. 실습도 단순히 문자를 변화시키는 것이었는데 이때 나는 객체를 넣으면 어떻게 될지 궁금했고 객체를 넣자 제대로 작동하지 않았다. 그래서 왜 그런지를 찾아보자 참조형 데이터와 React의 특징 때문이었고, 이 과정에서 참조형 데이터의 업데이트를 배울 수 있었다.\n그리고 퍼스트 프로젝트가 막바지에 이르렀을 때 이 지식이 빛을 발했다. 더미 데이터를 넣어서 할 때는 각자가 원시형 데이터로 하나씩 관리해서 이상이 없었지만 서버에서 받은 데이터를 그대로 state로 관리하려고 하자 제대로 업데이트가 진행되지 않는 것이었다. 팀원들은 이유를 알지 못했고 도움 요청이 들어왔다. 나는 이미 참조형 데이터의 업데이트에 대해서 알고 있었기에 문제를 빠르게 해결할 수 있었다.\n하나만 더 이야기하자면 최근에 개선 프로젝트를 시작하면서 이미 확인을 마친 코드를 며칠 뒤에 다시 하나씩 살펴보면서 “왜 이 코드가 필요하지? 왜 이렇게 작성했을까?”를 고민하는 시간을 가지고 있다. 분명 열심히 생각하고 짠 코드임에도 불구하고 다시 보면 필요 없거나 개선이 필요해 보이는 부분이 눈에 보였다. 이렇게 내 코드를 스스로 확인하고 고치는 과정에서 스스로 실력이 느는 걸 느끼고 있다.\n그래서 \u0026ldquo;Why? 를 좋아하는 개발자 정유찬\u0026quot;을 제목으로 삼고 이력서의 핵심 키워드를 \u0026ldquo;왜?\u0026ldquo;로 삼았다. 사실 \u0026ldquo;Why?\u0026rdquo; 만 좋아하는 것이 아니라 \u0026ldquo;Why not?\u0026ldquo;도 매우 좋아한다. \u0026ldquo;왜 안되겠어. 당연히 되지. 😁\u0026rdquo;\n퍼스트 프로젝트 HiBye ⋯ #우선 4번 팁(어떤 문제를 만나서 어떻게 해결했는지를 적어라.)을 고려해서 이 프로젝트에서 내가 마주쳤던 문제들을 살펴봤다. 그 중에서 6번 팁(작성한 이력이 실질적으로 어떤 의미를 지니는지를 고민해라.)을 만족할 수 있는 문제는 하나 뿐이었다.\n해당 문제는 새로고침을 할 경우 로그인 시 저장하는 사용자 정보가 모두 사라지는 문제였는데, 내가 담당한 부분이 아니었기 때문에 병합 후 확인해보기 전까지 몰랐었다. 병합 전에 코드리뷰에서 알아차렸어야 했는데 사실 퍼스트 프로젝트 때는 디스코드에 모여서 그냥 팀장이 \u0026ldquo;별 문제 없었죠?\u0026rdquo; 하고 병합 했었다 . (지금 생각하면 참\u0026hellip;😱) 그나마 발표 직전 내가 이것 저것 테스트를 해보다가 문제를 발견을 했고, state의 특징을 잘 알고있던 나는 빠르게 문제의 원인을 파악하고 발표 전에 해결할 수 있었다.\n이 경험은 팀원이 파악하지 못한 문제를 파악했고 (어필을 위해선 추가 설명이 필요해서 이력서에서는 뺌), 긴급한 상황에서도 침착하고 신속하게 문제를 해결한 점을 어필할 수 있다고 생각해 이력서에 적었다.\n그다음은 팀원들이나 페어들에게 학습 능력이 빠르다는 소리를 많이 들어서 그 점을 어필하고 싶었다. 새로운 스택을 도입할 때 단기간에 혼자만 사용법을 익혀서, 사용법을 팀원들에게 알려준 경험이 빠른 학습 능력을 어필하기에 적합하다고 생각했다.\n마지막으로는 위에서 언급한 \u0026ldquo;왜?\u0026ldquo;를 좋아한 덕분에 팀의 문제를 쉽게 해결할 수 있었던 경험을 적었다.\n사실 처음 적었던 경험은 10개를 넘어간다. 어필하고 싶은 건 많은데 이것들을 추려야 하니 매우 어려웠다. 하지만 실질적인 의미를 가지는 것들만 남기고, 그 실질적 의미가 비슷하게 겹치는 것들을 제외하다 보니 3개로 추릴 수 있었다.\n파이널 프로젝트 Debate Ducks ⋯ #파이널 프로젝트는 나름 어려운 도전을 해서 수많은 문제들을 만날 수 이었다. 하지만 그중에 내가 선택해서 이력서에 적은 문제는 비교적 아주 쉽게 해결할 수 있었던 문제들이다. 문제의 어려움 보다는 해당 문제의 해결 과정에서 무엇을 어필할 수 있는지에 집중했기 때문이다. 또한 팀적인 도움을 준 내용은 퍼스트 프로젝트에서 이미 어필했으니 전부 빼버렸다.\n우선 첫 번째 문제는 React에서 clearInterval이 제대로 작동하지 않는 문제이다. 이 문제는 구글링으로 아주 쉽게 해결할 수 있었는데, 단순히 문제 해결로 끝나지 않고 문제 해결 과정에서 새로운 배움을 얻고 그 배움을 이후에 활용했다는 점을 어필할 수 있다고 생각했다. (간접적으로 검색 능력도 어필)\n다음으로 비디오가 사용자의 뷰에서 벗어났을 때 캔버스에 그려지지 않는 문제인데, 문제를 자바 스크립트 코드가 아닌 CSS로 쉽게 해결한 점이 신선하다고 생각해서 어필하고 싶었다. 또한 해당 문제를 구글링 해봐도 나오지 않아 문제 자체도 신선하다고 생각했다.\n마지막으로는 나만의 학습법이 명확하게 있다는 점을 어필하고 싶었다. 이미 \u0026ldquo;왜?\u0026ldquo;를 끊임없이 묻는 학습법을 이야기했지만 좀 더 구체적인 학습법을 어필하고 싶었다. 그래서 WebRTC와 Socket.io라는 새로운 스택을 어떻게 학습했는지를 적었다.\n나만의 학습법을 자세히 설명하자면 우선 공식 문서를 살펴보고, 이후에는 적절한 강의가 있는지 유튜브에 찾아본다. 그 후 구글링을 통해 해당 스택이 사용된 프로젝트들을 다운로드해서 하나하나 직접 실행시켜 보면서 조금씩 수정해 본다. 이 과정을 거치고 나면 실제로 해당 스택들이 어떻게 활용되는지를 알 수 있어서 내 프로젝트에 적용할 때 많은 도움이 된다.\n개선 프로젝트 Debate Ducks 2.0 ⋯ #우선 새로운 스택을 대거 적용한 만큼 많은 문제를 만났지만 이번에는 개발 과정을 상세하게 기록한 덕분에 오히려 쉽게 적을 수 있었다.\n첫 번째로는 토론이나 댓글 목록 조회에서 정렬 순서 변경 시 재요청 함수를 작동 시켰으나 변경되지 않은 요청이 가는 문제를 적었다. 새로운 스택인 React-query의 특징을 잘 이해하고 있다는 점을 간접적으로 어필하면서, JavaScript의 비동기 처리 방식을 잘 이해하고 있어서 문제를 해결할 수 있었다는 점을 어필하기 위해서이다.\n두 번째로는 녹화 재시작 시 영상이 깨지는 문제를 적었다. 문제의 원인 파악이 중요하고, 잘못 파악했을 때는 모르는 것보다 더 치명적일 수 있다는 걸 경험으로 알고 있다는 점을 어필하기 위해서이다.\n세 번째로는 WebRTC 재연결 불가능 문제를 적었다. 이 문제는 이전 프로젝트에서도 발생했던 문제인데 그때는 해결하지 못해서 강제로 리다이렉트 시키고 뒤로 가기를 못하게 막는 방식으로 회피했었다. 하지만 이번에는 해결할 수 있었다는 점을 들어서 나의 성장성을 어필했다.\n네 번째로는 이전 프로젝트 때 받았던 피드백에 대해서 적었다. 받은 피드백을 충실히 반영했으며 거기서 그치지 않고 더 생각해서 추가적인 조치를 취한 점을 어필하기 위해서이다.\n마지막으로 개선 프로젝트의 목적을 설명했다. 이력서를 보는 사람의 입장에서 해당 내용이 적혀있지 않으면 개선 프로젝트의 당위성이 떨어질 것이라 생각해 적어주었다.\n코드스테이츠 (부트캠프) #우선은 어떤 것들을 배웠는지 언어 하나와 대표적인 두 스택으로 설명했다.\n그리고 그 당시에는 매우 어려웠던 Advanced와 Nightmare 난이도의 과제를 시간이 얼마나 걸려도 해결 할 때까지 도전해서 결국은 모든 과제를 해결한 점으로 나의 집요함과 도전정신을 어필했다.\n다음으로는 코드스테이츠에서 수없이 강조한 자기 주도적 학습이다. 나는 원래부터 자기 주도적 학습을 해왔고, 나만의 학습법을 지니고 있어서 자기 주도적 학습 자체는 어렵지도 않았고 전혀 새로울 것도 없었다.\n하지만 이제까지 하던 공부는 명확하게 교재나 범위라는 대상이 있었는데 개발이라는 세계는 명확한 교재(그나마 공식 문서)도 애매하고 범위가 너무 광범위 하다 보니 공부해야 하는 대상을 특정하는 것이 어려웠다. 하지만 부트캠프 과정을 거치면서 이 점을 익힐 수 있었고 이를 어필했다.\n마지막으로 다시한번 나의 빠른 학습 능력을 어필하면서, 페어 프로그래밍을 통해 커뮤니케이션 능력을 키웠다는 점을 어필했다.\nPs. 이력서에 따로 어필하기는 애매하지만 어필하고 싶었던 것이 팀 프로젝트 동안 팀원이 바뀌지 않았다는 점이다. 많은 팀들이 프로젝트를 거치면서 불화가 생기고 팀 멤버가 바뀌었다. 하지만 우리 팀은 취업이 아닌 다른 이유로는 팀원이 이탈하지 않았다. 즉 팀 전원이 성격이 모나지 않고, 커뮤니케이션에 문제도 없다는 것을 어느 정도 뒷받침할 수 있는 근거가 된다. 이를 간접적으로 어필하기 위해서 프로젝트에 팀 이름을 적었다. 🤣\n부산대학교 #우선 이력서를 보는 입장에서 가장 중요한 내용을 적었다. 아직 졸업을 하지 않았지만 학점은 이미 총 학점을 넘었고 (예정에 없던 교환 학생으로 학점을 초과해버림), 남은 과목은 자격증 대체 과목이라 수업에 참여하지 않고도 졸업을 할 수 있다는 내용이다.\n다음으로 낮지 않은 학점이 어느 정도 성실성를 어필할 수 있다고 생각해서 적었다. 과 2등인 것도 적어서 학점을 쉽게 딸 수 있기 때문에 4점을 넘은 것이 아니란 것이나, 전공 학점은 4.22로 더 높다는 것도 적을까 하다가 3번 팁(개발자 역량을 위주로 관련 없는 건 빼라.)을 일부 받아들여서 적지 않았다.\n현장 실습은 개발과 관련되지는 않았지만 적어도 인턴으로서 일을 해본 점을 어필하기 위해서 적었다. 또 혹시 면접 때 해당 내용을 물어볼 경우 단기간 인턴임에도 회사에 도움이 되고 스스로에게도 유의미한 시간이 되었으면 해서 자발적으로 회의 내용을 바탕으로 프레젠테이션을 준비해 대표님께 보여드리고 결국 대표님 마음에 들어서 신규 프로젝트를 담당하게 되었던 일화를 말해, 적극적으로 회사와 함께 성장해 나가기를 원하는 인재라고 어필할 수도 있다고 생각했다.\n마지막으로 교환학생 경험을 적어서 영어에 어느 정도 익숙함을 어필했다.\n마무리 #\u0026ldquo;뭐 뭐 뭐 쓸 줄 알고, 뭐 뭐 뭐해봤음.\u0026rdquo; 식의 이력서를 적고 싶지 않았다. 또 내가 가진 장점을 \u0026ldquo;저한테 이런 장점이 있습니다.\u0026ldquo;라고 서술하는 것이 아닌 경험에 녹여서 보여주고 싶었다. 그러다 보니 주변 친구들과는 많이 다른 이력서가 만들어졌다.\n지금 이력서를 제출하는 시점에서 현직 개발자나 인사업무 경험자의 피드백을 받아보지 못한 게 조금 아쉽다. 하지만 주변 예비 개발자 동료들의 반응은 좋아서 조금 안심이다. (현제 부트캠프 커리어코칭 신청 후 대기 중)\n피드백 후 이력서 (피드백 내용은 시간이 나면 추가하겠다.) 마지막으로 이력서 작성의 일등 공신은 꾸준한 블로깅이다. 내가 개발자로서 성장하는 모든 과정이 블로그에 기록되어 있기 때문에 블로그를 통해서 나를 돌아볼 수 있었다. 또한 자세한 내용을 참조 링크를 통해 블로그에서 볼 수도 있다고 생각하니 간략화 단계에서 중요한 내용만 남기는데 많은 도움이 되었다.\nPs. 이력서에 적지 않은 내용 #일부 계산 작업 자동화 #커리어 코치님께서 군대 이야기는 웬만하면 적지 말라고 강의하셨다. 그래서 이력서에는 적지 않았지만 이 경험은 내가 개발자라는 직업을 선택하게 된 이유 중에 한 부분을 차지하기 때문에 여기에라도 적는다.\n군대에서는 인원 파악이 매우 중요하다. 그래서 수시로 인원 체크를 하는데 인원을 하나하나 체크한 다음 생활관 별로, 분대별로, 소대별로, 마지막으로 중대별로 총계를 작성해야 했다. 이때 각 정보를 일일히 직접 더하다보니 귀찮기도 했고 가끔 계산이 틀리기도 했다.\n그래서 이 작업을 편하고, 빠르고, 정확하게 할 수 없을까 고민하다가 엑셀로 자동화해보기로 결정한다. 그 뒤로 당직을 설 때마다 해당 작업을 진행했고 결국은 많은 시행착오를 거쳐서 인원 체크만 하면 모든 총계가 나오게 완성했다. (당시 엑셀을 처음 써보는데 군대 내에서는 인터넷도 안돼서 하나하나 함수를 확인해가면서 함) 특히 전역 1년 후에도 아직 쓰고 있다는 말을 들었을 때 엄청난 보람을 느꼈다.\n이때의 긍정적인 경험이 개발자가 되기로 결정하는데 작지 않은 영향을 미쳤다.\n추가로 이때의 경험을 바탕으로 현장 실습을 할 때 매입 매출표를 일부 자동화했었고 (실제 파일을 건드리지는 않고 복사본에 자동화 기능을 넣은 다음 복붙함), 신규 프로젝트 상품의 예상 매출액 및 순이익 계산을 자동화했었다.\n아이디어 채택 #코드스테이츠 두 번의 프로젝트, 대학시절 두 번의 조별 과제, AT(한국농수산식품유통공사) 주관 창업 아이디어 경진 대회의 공통점이 있다. 모두 내 아이디어가 투표를 통해서 채택되었다는 점이다. 그리 많지는 않지만 지금까지 내가 했던 모든 팀 활동에서는 내 아이디어가 채택되었다.\n나는 그 이유가 나의 집요함에 있다고 생각한다. 일단 팀 활동이 시작되면 해당 활동에 적합한 아이디어가 생각날 때까지 끊임없이 고민한다. 그리고 적합한 아이디어가 생각난 다음에는 해당 아이디어가 채택되기 위해서는 어떤 점을 팀원들에게 어필해야 할까를 또 끊임없이 생각한다. 그 과정에서 아이디어는 장점을 강화하고 단점을 보완하면서 더욱 탄탄해지고 그 덕에 더욱 설득력을 갖는다.\n","date":"4 August 2022","permalink":"/posts/diaries/1/","section":"Posts","summary":"이력서 구글 드라이브 링크","title":"첫 이력서 작성 후기"},{"content":"토론 생성 및 수정 페이지 # 원래는 유효성 검사 실패 여부를 작성 버튼을 누른 후에 뜨게 했었다. 하지만 사용자의 입장에서 이미 작성을 다 한 다음 틀렸다고 안내받고 다시 작성하는 것보다 틀리는 시점에 안내받는 것이 더 좋을 것이라고 판단했다. 그래서 유효성 검사를 실패할 때마다 유효성 검사 실패 안내가 뜨게 만들었다.\n그러자 한글을 입력할 때 계속 유효성 검상 실패 안내가 뜨는 문제가 생겼다. 유효성 검사에서 낱자를 거르기 때문이다. 그래서 낱자 조건은 유효성 검사 실패 안내 조건에서는 빼고 실제 조건에는 넣어서 따로 메시지로 안내하게 만들었다.\nPs. 가운데 정렬\nposition: absolute; top: 50%; left: 50%; transform: translateX(-50%) translateY(-50%); 토론 게시물 - 기본 내용 및 팩트 체크 # 토론자 정보 부분은 토론 목록의 토론자 정보 부분을 공용 컴포넌트로 변경해서 사용했다. 이 때 토론 게시물 내부에서 크기를 줄였을 때 배치가 이상해지는 문제가 발생했다.\n문제의 원인은 반응형을 적용할 때 %를 활용했는데 박스의 크기가 너무 작아지게 돼서 생기는 문제였다. 그래서 min-width로 배치가 무너지는 것을 막았다. *참조와 같은 원리\n토론 게시물 - 투표 # 막대 그래프 #투표 결과에 따라 그래프가 변하는 기능은 SCSS로 처리하고 싶었지만 당장 방법을 떠올리지 못해 일단 인라인 스타일로 처리했다.\nconst calcPercent = (cnt: number) =\u0026gt; { return ( (cnt / ((debate.data?.vote.prosCnt || 0) + (debate.data?.vote.consCnt || 0))) * 100 ); }; ... return ( ... \u0026lt;div className={`${styles.chart} ${styles.chart_pros} ${ calcPercent(debate.data?.vote.prosCnt || 0) === 100 ? styles.chart_100 : \u0026#34;\u0026#34; }`} style={{ width: `${calcPercent(debate.data?.vote.prosCnt || 0)}%` }} \u0026gt;\u0026lt;/div\u0026gt; ... ) 커서 디테일 #사용자가 눌렀을 때 이벤트가 발생하는 모든 요소에 pointer: cursor 스타일을 줬다. 이미 투표한 버튼의 경우는 추가 이벤트가 발생하지 않으므로 pointer: default 스타일을 줬다.\n별건 아니지만 포인터 커서는 눌러서 이벤트를 발생시킬 수 있다는 일관성을 지키기 위한 작은 노력이다. 이런 디테일에서 완성도가 결정되고 감동을 줄 수 있다고 나는 믿는다.\n토론 게시물 - 댓글 # useQueryInfinite를 사용할 때는 각 요소의 바깥에서 한 번 더 묶어서 width를 줘야 한다. 왜냐하면 각 page안에 배열로 정보들이 들어있는 형태라서 그렇다.\n.comment_box { width: 100%; .comment { ... } } .comment_box에 width를 주지 않았을 때, 각 댓글 요소가 밖으로 삐져 나감. (빨간색 테두리)\n.comment_box에 width를 줬을 때, 각 댓글 요소가 잘 위치함. (빨간색 테두리)\n토론 카드 수정 #이전 프로젝트에서 받았던 피드백을 바탕으로 토론 상태를 한글로 더 직관적이게 바꿨다. 추가로 상태도 표시해 줬었는데 직관적이긴 했지만 조금 촌스러워 보였다. 그리고 참가 가능한 토론은 이미 \u0026ldquo;비어있음\u0026quot;으로 충분히 알 수 있었고, 투표가 가능한 토론인지 아닌지만 사용자에게 알려주면 됐기 때문에 \u0026ldquo;투표 가능\u0026quot;만 따로 표시해 줬다.\n추가로 원래는 토론의 분류를 카드 이미지로만 구분해 줬었다. 만드는 입장에서 이미 각 이미지에 익숙해서 분류를 바로 알 수 있었기 때문에 사용자의 입장에서 이미지로 분류를 명확히 구분할 수 없을 것이라는 판단을 하지 못했었다. 이를 깨닫고 사용자의 입장에서 직관적으로 알 수 있게 분류도 따로 표시해 줬다.\n기존 토론 상태 현재 토론 상태 기존 토론 카드 중간 수정 토론 카드 최종 수정 토론 카드 숫자 자릿수 표시 #천명이 넘는 사람이 좋아요를 누를 일은 당장 없지만 언젠가 많은 사람이 사용할 날을 생각하며 콤마(,)로 자릿수를 구분해 줬다.\nexport const thousandDigit = (num: number) =\u0026gt; { const str = String(num); if (str.length \u0026lt;= 3) return str; return str .split(\u0026#34;\u0026#34;) .reverse() .map((el, idx) =\u0026gt; { if (idx !== 0 \u0026amp;\u0026amp; idx % 3 === 0) { return el + \u0026#34;,\u0026#34;; } return el; }) .reverse() .join(\u0026#34;\u0026#34;); }; useQuery의 enabled #좋아요를 누른 토론일 경우 따로 표시를 해준다. 해당 정보를 토론 정보에 담을 수 있으면 좋겠지만 백 앤드에서 해당 정보를 담아서 주는 게 당장은 어렵다고 해서 따로 좋아요 여부를 받는 API를 팠다.\n하지만 이때 문제가 발생했다. 유저 아이디를 해당 API에 쿼리 파라미터로 보내줘야 했는데, 받아온 유저정보를 해당 API로 보내는 훅 내부에서 읽지 못하는 것이었다.\n이 문제는 순간 이전에 리액트 쿼리를 공부할 때 봤던 내용이 떠오르면서 쉽게 해결할 수 있었다. 연속되는 호출 시 enabled를 사용하면 된다는 것이었다.\nconst user = useGetUser(); const debate = useGetDebate(debateId); const heart = useGetHeart( { target_debate_id: debateId, target_user_id: user.data?.id || \u0026#34;\u0026#34;, }, { enabled: !!user.data?.id, } ); 이전에 유저 정보 요청과 토큰 문제, 토론 게시물 요청 시 undefined 문제 등을 다른 방식으로 회피했는데 올바른 해결법을 알았으니 다시 수정해 줬다.\nexport const useGetUser = (options?: UseQueryOptions\u0026lt;User, AxiosError\u0026gt;) =\u0026gt; { const token = typeof window !== \u0026#34;undefined\u0026#34; ? localStorage.getItem(\u0026#34;debate-ducks-token\u0026#34;) : null; const query = useQuery\u0026lt;User, AxiosError\u0026gt;( [queryStr.users], () =\u0026gt; getUser(token), { enabled: !!token, ...options, } ); return query; }; const debate = useGetDebate(debateId, { enabled: !!debateId, }); Ps. 이미 배웠던 내용이지만 다른 방식으로 문제를 해결해서 enabled를 떠올리지 못했었다. 이번에 떠올린 이유는 다른 방법으로 해결하지 못했기 때문이다. 앞으로는 해결한 문제도 이게 최선의 해결책인지 더 깊이 고민할 것이다.\n배포 준비 #타입 에러 #빌드 시 컴파일 시에는 감지하지 못했던 타입 에러가 발생했다.\n해당 부분에 타입을 명시하는 것으로 쉽게 해결했다.\nonError: ( err: AxiosError\u0026lt;{ message: string }\u0026gt;, _, rollback: (() =\u0026gt; Debate) | undefined, ) =\u0026gt; { if (rollback) rollback(); toast.error( `${err.response?.data?.message || \u0026#34;네트워크 에러가 발생했습니다.\u0026#34;}`, ); }, Image Optimization Error #기본 이미지 로더와 next export의 호환성 에러가 발생했다.\nnext-optimized-images 설치 후 next.config에서 로더를 \u0026ldquo;akamai\u0026quot;로 설정해서 해결했다.\n/** @type {import(\u0026#39;next\u0026#39;).NextConfig} */ const nextConfig = { reactStrictMode: true, images: { loader: \u0026#34;akamai\u0026#34;, path: \u0026#34;/\u0026#34;, }, }; module.exports = nextConfig; *참조\nSSR 기능 제거 #배포를 담당하는 팀원이 서버는 EC2에 클라이언트는 S3에 올리려고 하는데, SSR 때문에 S3에 올릴 수 없다고 연락이 왔다. 사실 서버가 따로 있는 시점에서 SSR만을 위해서 EC2에 클라이언트를 올리는 것은 현재로서는 비효율 적이라고 판단해 SSR 기능을 제거했다.\nsrc의 요청 문제 #배포 후 이미지 태그나 비디오 태그가 우리가 지정하지 않은 경로로 Get 요청을 보내는 문제가 발생했다. 해당 문제는 환경 변수파일이 배포때 제데로 설정되지 않아서 발생 했었다. 즉 정확한 경로가 들어가지 않을 경우 src가 스스로 요청을 보내서 소스를 찾으려고 하는 것 이었다. 하지만 아직까지 추측일 뿐이고 정확한 래퍼런스를 찾지 못했다.\nCSS 작업에 대해 느낀 점 #반응형 디자인 직접 해보면서 점점 익히고 있는 중이다. 특히 \u0026ldquo;특정 부분에서 폰트 크기를 정해주고 그 후손들의 폰트 크기를 %로 적은 다음 미디어 쿼리를 적용할 때 기준이 되는 폰트 크기만 바꿔주면 후손들은 신경 쓸 필요 없이 쉽게 비율에 맞게 줄일 수 있다\u0026quot;는 발상이 많은 도움이 되고 있다.\n이번에는 디자인 요소를 명확하게 정하지 않고 작업에 들어가서 고생을 좀 하고 있다. 다음에는 HTML 요소들도 미리 구상하고 특히 클래스 명의 컨벤션을 잘 찾아보고 정해야겠다. 지금 나름대로 최선을 다해서 클래스명을 정하고 있으나 나 말고 다른 팀원이 알아보기 힘들어한다.\n","date":"1 August 2022","permalink":"/posts/projects/debate-ducks/18/","section":"Posts","summary":"토론 생성 및 수정 페이지 # 원래는 유효성 검사 실패 여부를 작성 버튼을 누른 후에 뜨게 했었다.","title":"[Debate-Ducks] 토론 생성, 수정 및 조회 페이지"},{"content":"토론 목록 #\r기존에는 기본 토론 목록과 좋아요가 된 토론 목록이 따로 작성되어 있었지만 공통 요소를 최대한 묶어서 하나의 컴포넌트로 만들었다. 그리고 각 토론 정보를 카드 안에 담아 보여줄 수 있게 만들었다.\n이전 프로젝트로 현직 프런트 앤드 신입 개발자에게 간단한 피드백을 받았었는데 필터에서 선택 사항들을 한 번에 취소할 수 있으면 좋을 거 같다는 피드백을 받았서 이를 반영했다. 추가로 직관성이 떨어져 보인다는 피드백도 있어서 토론의 상태를 한글로 직관적이게 바꾸고, 토론 카드에 토론의 상태도 표시 해줬다.\n추가 직관성 개선 *참조 Ps. v는 검색의 느낌이 부족해서 ⚲로 검색 이모지 변경\n반응형 작업 # 노가다 반응형 로직 제거 [참조] 특히 신경 쓴 부분이 반응형 작업이었다. 필터의 경우 각 버튼이 단순한 요소들이라 간단하게 처리할 수 있었지만 토론 카드의 경우 여러 요소들이 들어있어서 비율을 맞춰서 반응형을 설계하는 것이 힘들었다.\n뷰포인트가 작아질 때 마진이 먼저 줄어들다가 더이상 마진을 줄일 수 없을 때 카드의 크기 자체가 줄어들게 만들었는데, 이 과정에서 반복 작업을 깔끔하게 처리하는데 실패했다.\n그래서 우선은 일일히 뷰포인트를 줄여가며 break point를 찾아 크기와 마진을 변경해주었다. (디지털 노가다 😅😅😅) 추후 계산을 자동화하는 방법을 고려해서 깔끔한 코드로 만들 예정이다.\n@mixin media($mw) { @media screen and (max-width: $mw) { @content; } } @mixin mediaMargin($px, $m, $w: 22rem) { @include media($px) { margin-right: $m; margin-left: $m; width: $w; height: $w * (12 / 11); @content; } } // 노가다 코드 일부 @include mediaMargin(1184px, 0.9rem); @include mediaMargin(1174px, 0.8rem); @include mediaMargin(1164px, 0.7rem); @include mediaMargin(1155px, 0.6rem); @include mediaMargin(1145px, 0.5rem); @include mediaMargin(1135px, 0.4rem); @include mediaMargin(1127px, 0.3rem); @include mediaMargin(1117px, 0.2rem); @include mediaMargin(1107px, 0.1rem); @include mediaMargin(1098px, 1rem, 20rem) { font-size: 0.9rem; } @include mediaMargin(1088px, 0.9rem, 20rem); @include mediaMargin(1078px, 0.8rem, 20rem); @include mediaMargin(1068px, 0.7rem, 20rem); Ps. justify-content: space-between;등을 쓰려면 width 값이 있어야 한다.\n아쉬운점 #이전 프로젝트에서는 시간 부족으로 반응형 디자인을 전혀 고려하지 못했었다. 그래서 이번에 처음으로 반응형 작업을 하는데 현재까지는 아쉬움이 많이 남는다. 필터 부분의 경우 단순한 버튼의 나열만 있어서 flex-wrap 만으로 간단히 해결되었지만, 토론 카드의 경우 분명 깔끔하게 작성할 수 있는 방법이 있을 텐데 실력 부족으로 저런 코드를 짰다는 것에 스스로에게 너무 아쉽다.\n특히 이번 개선 프로젝트의 경우 세부적인 계획 없이 각자 이전 프로젝트에서 아쉬웠던 부분들을 새로운 스택을 활용해서 개선해 보자는 취지로 시작했기 때문에 반응형 작업을 디자인이 없는 상태로 알아서 해야 해서 조금 어려움이 있다.\n","date":"30 July 2022","permalink":"/posts/projects/debate-ducks/17/","section":"Posts","summary":"토론 목록 #\r기존에는 기본 토론 목록과 좋아요가 된 토론 목록이 따로 작성되어 있었지만 공통 요소를 최대한 묶어서 하나의 컴포넌트로 만들었다.","title":"[Debate-Ducks] 토론 목록 조회 페이지"},{"content":"로그인이 필요한 서비스 모달 # 기존에는 로그인이 필요한 서비스의 경우 안내 모달을 띄우고 사용자가 로그인을 원할 경우 로그인 페이지로 이동시켜줬다. 하지만 로그인 후 다시 해당 페이지의 해당 부분으로 돌아오려면 추가적인 처리가 필요했고, 또한 로그인이 필요한 서비스는 사용될 곳이 많아서 따로 모달로 만들기로 했다.\n팀원들에게 이 부분을 보여줬을 때 \u0026ldquo;본인이 로그인 안 했었으면 로그인하고 다시 찾아오면 되지 그런 거까지 신경 써줘야 하나요? 저는 웹 사이트들 사용할 때 사소한 불편함 들 많이 겪었지만 큰 생각은 없었어요. 유찬 님은 사용자를 너무 배려하는 거 같아요.\u0026ldquo;라는 피드백을 받았다. 하지만 나는 이런 사소한 디테일이 완성도를 결정하고 감동을 줄 수 있다고 믿는다. 그래서 앞으로도 내 일이 조금 더 많아지더라도 계속해서 사용자를 배려하는 개발을 할 것이다.\n로그인 후 새로고침을 하지 않을 경우 유저 정보가 업데이트되지 않는 문제가 발생했다. 해결을 위해 처음에는 invalidQueries를 사용했지만 원하는 데로 작동하지 않았고 refetch를 사용하자 잘 작동했다. 현재까지 겪은 바로는 useMutation 내부에서는 invalidQueries를 사용해야 했고, 컴포넌트에서는 refetch를 사용해 줘야 했다.\n로그인 페이지 개선으로 로그인 모달은 삭제 *참조 Axios 에러 메시지 타입 문제 #에러 발생 시 서버의 에러 메시지를 toast로 바로 보여주려고 했다. 서버에서 적어 넣은 메시지는 response의 data 내부의 message에 위치했다. 하지만 메시지를 호출하자 unknown 에러가 발생했다.\nonError: (err: AxiosError) =\u0026gt; { toast.error(`${err.response?.data.message}`); }, (property) AxiosResponse\u0026lt;unknown, any\u0026gt;.data: unknown Object is of type \u0026#39;unknown\u0026#39;. 제네릭을 이용해서 { message: string } 타입을 지정해 주자 해결됐다.\nonError: (err: AxiosError\u0026lt;{ message: string }\u0026gt;) =\u0026gt; { toast.error(`${err.response?.data.message}`); }, ","date":"29 July 2022","permalink":"/posts/projects/debate-ducks/16/","section":"Posts","summary":"로그인이 필요한 서비스 모달 # 기존에는 로그인이 필요한 서비스의 경우 안내 모달을 띄우고 사용자가 로그인을 원할 경우 로그인 페이지로 이동시켜줬다.","title":"[Debate-Ducks] 로그인 모달"},{"content":"개요 #스타일 초기화, 전역 변수 및 스타일 설정 후 스타일 작업 시작. (메모만 해뒀던 디테일 작업 병행)\nHead #처음에는 _app.tsx에 next/head로부터 가져온 Head 컴포넌트 내부에 작성했다.\n// _app.tsx import Head from \u0026#34;next/head\u0026#34;; ... \u0026lt;Head\u0026gt; \u0026lt;title\u0026gt;Debate Ducks\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;author\u0026#34; content=\u0026#34;SuSang-YuHee\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;Real-time debating platform.\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;/favicon.ico\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;./favicon.ico\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; href=\u0026#34;./favicon.ico\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/reset-css@5.0.1/reset.min.css\u0026#34; /\u0026gt; \u0026lt;/Head\u0026gt; 하지만 Do not add stylesheets using next/head. 경고가 떠서 이를 해결하기 위해 _document.tsx에 next/document로부터 가져온 Head 컴포넌트 내부에 작성했다. 하지만 이번에는 Titles should be defined at the page-level using next/head. 경고가 떴고 그래서 title은 next/head의 Head에 적고 나머지는 next/document의 head에 적었다.\n// _document.tsx import { Html, Head, Main, NextScript } from \u0026#34;next/document\u0026#34;; export default function Document() { return ( \u0026lt;Html lang=\u0026#34;ko\u0026#34;\u0026gt; \u0026lt;Head\u0026gt; \u0026lt;title\u0026gt;Debate Ducks\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;author\u0026#34; content=\u0026#34;SuSang-YuHee\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;Real-time debating platform.\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;/favicon.ico\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;./favicon.ico\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; href=\u0026#34;./favicon.ico\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/reset-css@5.0.1/reset.min.css\u0026#34; /\u0026gt; \u0026lt;/Head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;Main /\u0026gt; \u0026lt;NextScript /\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/Html\u0026gt; ); } 전역 스타일 및 공용 변수 #import \u0026#34;../styles/globals.scss\u0026#34;; @import \u0026#34;./variable.scss\u0026#34;; html, body { font-family: sans-serif; background-color: $c-white; } a { color: inherit; text-decoration: none; } * { box-sizing: border-box; } .inner { width: 1200px; /* 최대 넓이 */ max-width: 100%; /* 모바일용 */ margin: 0 auto; /* 가로 가운데 정렬 */ position: relative; } $c-white: #f8fbfd; $c-black: #292929; $c-gray_light: #eeeeee; $c-gray_dark: #cccccc; $c-pros: #ff9425; $c-cons: #6667ab; @mixin tablet { @media screen and (max-width: 899px) { @content; } } @mixin mobile { @media screen and (max-width: 599px) { @content; } } @mixin center { display: flex; justify-content: center; align-items: center; } 토론 목록 필터 # 처음으로 프로젝트 때 CSS(SCSS)를 직접 사용했다. 이전 프로젝트는 모두 Tailwind CSS를 사용했었다. 클래스 명을 정할 필요가 없고 바로바로 적어주면 돼서 작업 시간 단축에 많은 도움을 줬다. 하지만 JSX 파일에서 직접 스타일까지 입력하다 보니 아무래도 관심사 분리 면에서 단점이 있었다.\n하지만 SCSS로 작업하게 되니 스타일 작업 후에도 컴포넌트에 깔끔한 코드를 유지할 수 있었고, 구조를 직접 구성하면서 작업하다 보니 HTML 요소의 구조를 더 명확히 파악할 수 있었다. Tailwind CSS의 경우 바로 className 에 스타일을 적어 넣을 수 있어서 결과를 보면서 코딩했었지만, SCSS의 경우는 클래스 명을 정할 필요가 있어서 구조부터 미리 파악하고 구성한 뒤 스타일 작업에 들어갔기 때문이다.\n아직 SCSS에 익숙하지 않아서 많이 부족하지만 반복 요소들을 최대한 공통으로 묶어서 처리하기 위해 애쓰고 있다.\n@mixin btn($c, $b, $bc) { color: $c; border: 1px solid $b; background-color: $bc; } .container { @include center; flex-wrap: wrap; margin-top: 1rem; \u0026amp;:nth-child(1) { margin-top: 0; } \u0026amp;:nth-child(2) { margin-left: 12rem; margin-right: 12rem; @include tablet { margin-left: 3rem; margin-right: 3rem; } @include mobile { margin-left: 0.3rem; margin-right: 0.3rem; } } } .btn { \u0026amp;_category { @include btn($c-cons, $c-cons, $c-white); \u0026amp;_selected { @include btn($c-white, $c-cons, $c-cons); } } } \u0026lt;div className={`${styles.btn} ${ selected ? styles.btn_status_selected : styles.btn_status }`} /\u0026gt; 좋아요 버튼 및 공용 모달 컴포넌트 # 로그인이 되어있지 않을 때 좋아요 토론 목록 보기를 누를 경우 로그인이 필요하다는 안내 모달이 뜬다. 모달이 떴을 때 스크롤을 지금은 막지 않았지만 추후 useContext를 사용해서 막을 예정이다. 또한 지금은 로그인 후 메인 페이지로 가는데 추후 목록 페이지로 돌아오게 만들 것이다.\nPs. 최소 넓이 설정 #기존에는 flex: wrap과 padding을 이용해서만 필터 목록들을 관리했다. 브라우저에서 가장 좁게 만들거나 아이폰 미니 13으로 확인했을 때 별 이상이 없었다.\n하지만 브라우저에서 가장 좁게 만든 상태에서 개발자 모드를 켜서 더 좁게 만들었을 때 목록들이 일렬로 나열되어 너무 길어져서 보기 좋지 않았다. 그래서 최소 넓이를 줘서 일정 이상으로 줄어들게 되면 더 이상 형태가 변하지 않게 만들어 스타일의 안정성을 높혔다.\n","date":"28 July 2022","permalink":"/posts/projects/debate-ducks/15/","section":"Posts","summary":"개요 #스타일 초기화, 전역 변수 및 스타일 설정 후 스타일 작업 시작.","title":"[Debate-Ducks] 첫 스타일 작업"},{"content":" 목차 변경\nDetails, Problems, Etc 등의 구분을 없에고 주제별로 작성할 것이며 기타 내용의 경우 Ps.로 표시할 것이다. 개요 #토론과 관련된 기본 기능 마무리. (디테일은 메모에 남겨뒀고 디자인 작업과 병행 예정)\n요청에 대한 고민 #1. Optimistic update #기존에는 POST, PATCH, DELETE 후 쿼리를 invalid로 만드는 것으로 데이터를 업데이트했다. 하지만 그럴 경우 업데이트를 위해 GET 요청이 한 번 더 가는 상황이 발생했다. 그래서 onMutation 내부의 options에서 클라이언트의 데이터를 직접 업데이트해 줬다.\n이때 사용한 방식이 Optimistic update다. 요청을 보냄과 동시에 결과를 기다리지 않고 클라이언트의 데이터를 업데이트 시키고 요청이 실패하면 클라이언트의 데이터를 원래데로 롤백 시켜 사용자 경험을 향상 시킬 수 있다.\nexport const usePatchFactcheck = ( debateId: number, options?: UseMutationOptions\u0026lt;FactcheckPatch, AxiosError, FactcheckPatch\u0026gt; ): UseMutationResult\u0026lt;FactcheckPatch, AxiosError, FactcheckPatch\u0026gt; =\u0026gt; { const queryClient = useQueryClient(); return useMutation((factcheckPatch) =\u0026gt; patchFactcheck(factcheckPatch), { ...options, onMutate: (factcheckPatch) =\u0026gt; { // 기존 데이터 획득 const prevDebate: Debate | undefined = queryClient.getQueryData([ queryStr.debates, `${debateId}`, ]); if (prevDebate !== undefined) { // 데이터 등록 취소 queryClient.cancelQueries([queryStr.debates, `${debateId}`]); // 새로운 데이터 등록 queryClient.setQueryData([queryStr.debates, `${debateId}`], () =\u0026gt; { return { ...prevDebate, factchecks: prevDebate.factchecks.map((factcheck) =\u0026gt; { if (factcheck.id === factcheckPatch.id) { return { ...factcheck, description: factcheckPatch.description, reference_url: factcheckPatch.reference_url, }; } return factcheck; }), }; }); // Error 시 발동할 rollback 함수 return () =\u0026gt; { queryClient.setQueryData( [queryStr.debates, `${debateId}`], prevDebate ); }; } }, onError: (err, variables, rollback) =\u0026gt; { if (rollback) rollback(); toast.error(`${err.message}`); }, }); }; 2. 요청 통합 #처음에는 토론 게시물의 정보, 좋아요 표시 여부와 좋아요 수, 팩트체크, 투표 그리고 댓글을 모두 각각 useQuery로 요청하려고 했다. 왜냐하면 기존에는 데이터의 수정 시 서버에서 수정된 데이터를 요청해서 받기 때문이었다. 즉, 좋아요 하나만 눌러도 다른 모든 데이터를 다시 받아야 했다.\n하지만 데이터의 수정 시 클라이언트에서만 업데이트를 하게 된 다음에는 더 이상 추가 요청을 걱정할 필요가 없어졌다. 그렇기에 처음의 요청 수를 줄이는 편이 더 적절하다고 판단했다. 그래서 토론 게시물 안에 댓글을 제외한 다른 모든 정보를 담았다.\n댓글의 경우 무한 스크롤로 구현할 것이고 수정 페이지에서는 댓글의 정보를 요청할 필요가 없기 때문에 따로 요청했다. API를 따로 파는 방법도 있지만 우선은 이대로 진행하고 추후 수정 여부를 판단할 것이다.\n3. SSR #이렇게 요청을 통합하자 생각지 못했던 다른 문제가 발생했다. 좋아요 표시 여부와 투표 여부를 판단하기 위해서는 userId가 필요한데 SSR로 요청을 할 때는 userId를 가지고 있을 수 없기 때문에 undefined로 요청했다. 하지만 {staleTime: Infinity}라 정보가 항상 false로 나오는 문제가 있었다.\n하지만 추가 요청을 하게 만들 경우 SSR을 하는 의미가 없어지고, SSR을 사용하지 않을 경우 debateId가 undefined일 때 요청을 보내고 쿼리도 저장하게 되는 문제가 있었다. 그래서 우선은 좋아요 표시 여부와 투표 여부는 따로 빼서 요청하는 형태로 코드를 작성했다.\nenabled로 undefined 문제 해결 *참조\n배포 과정에서 SSR 기능 삭제 *참조 4. token과 유저 정보 요청 #현제 로그인 시 token을 받아서 local storage에 저장하고 해당 토큰으로 유저 정보를 요청하는 방식으로 되어있다. 하지만 token이 없을 때도 유저 정보를 요청하고 에러를 응답으로 받았다.\n요청의 수를 가능한 줄이고 싶었고 사용자의 잘못이 없는데 에러 메시지가 콘솔에 찍히는게 싫어서 이를 해결하려 했다. 하지만 useQuery는 조건부 설정이 불가능 했기 때문에 요청 API 내부에서 처리해 줬다.\nuseQuery에서 enabled 옵션을 사용해서 처리하게 변경. *참조 export const getUser = async () =\u0026gt; { const token = typeof window !== \u0026#34;undefined\u0026#34; ? localStorage.getItem(\u0026#34;debate-ducks-token\u0026#34;) : null; if (token) { const { data } = await axios.get( `${process.env.NEXT_PUBLIC_API_URL}/users`, { headers: { Authorization: `Bearer ${token}`, }, withCredentials: true, } ); return data; } return null; }; 정렬 시 재요청 문제 #정렬 시 재요청을 위해 처음에는 queryClient.invalidateQueries를 사용했으나 orderSelect.value가 바뀌어도 재요청을 보낼 때는 바뀌지 않은 값으로 재요청이 갔다.\nconst queryClient = useQueryClient(); const debates = useGetDebates(search.value, orderSelect.value); useEffect(() =\u0026gt; { queryClient.invalidateQueries([\u0026#34;debates\u0026#34;], { exact: true }); }, [queryClient, orderSelect.value]); 그래서 다음으로 refetch를 고려했다. 하지만 refetch는 useMutation으로 부터 나오는 것이라 useEffect와 함께 사용할 때 dependency에 자기 자신이 포함되어 무한히 재요청을 보내는 문제가 발생했다.\nconst debates = useGetDebates(search.value, orderSelect.value); useEffect(() =\u0026gt; { debates.refetch(); }, [debates, orderSelect.value]); 이제 useEffect를 사용할 수 없다는 것을 알아서 refetch를 onChange가 발생할 때 작동 시키기로 했다. useSelect도 useGetComments도 서로가 필요해서 JS의 호이스팅 기능을 이용했다.\nconst orderSelect = useSelect(COMMENT_ORDER[0], refetch); const comments = useGetComments( search.value, orderSelect.value === \u0026#34;최신순\u0026#34; ? \u0026#34;ASC\u0026#34; : \u0026#34;DESC\u0026#34; ); function refetch() { debates.refetch(); } 하지만 여기서 이전에도 유사하게 발생한 적 있는 작동 순서의 문제가 발생했다. 정렬 방식이 선택될 때 refetch가 발동함에도 불구하고 변경 이전의 정렬 방식이 적용된 채로 재요청이 일어나는 것이었다. 하지만 이번에는 JS의 비동기 처리 방식으로 해결할 수 있다는 아이디어가 떠올랐고 이를 통해 해결했다.\nfunction refetch() { setTimeout(() =\u0026gt; debates.refetch(), 1); } Ps. 서버에 요청해야 하는 값과 사용자에게 보여주는 값이 달라서 orderSelect.value === \u0026quot;최신순\u0026quot; ? \u0026quot;ASC\u0026quot; : \u0026quot;DESC\u0026quot;와 같이 작성을 했었는데 나중에 정렬 방식이 늘어날 경우 유지 보수성 면에서 좋지 않아, COMMENT_ORDER를 [ [\u0026quot;최신순\u0026quot;, \u0026quot;DESC\u0026quot;], [\u0026quot;오래된 순\u0026quot;, \u0026quot;ASC\u0026quot;], ]로 수정한 뒤 \u0026lt;option value={order[1]}\u0026gt;{order[0]}\u0026lt;/option\u0026gt;과 같은 방식으로 개선했다.\n카테고리 필터링 #이전에 한번 고민했던 내용인데 \u0026ldquo;무한 스크롤에서 카테고리로 하는 필터링의 경우 굳이 서버를 거칠 필요가 있는가?\u0026ldquo;이다. 기존 페이지네이션의 경우 한 페이지의 게시물 수가 정해져 있기 때문에 서버를 거칠 필요가 있지만 무한 스크롤의 경우 필터링 된 게시물이 부족하면 추가 요청을 보내면 되기 때문에 굳이 서버를 거칠 필요가 없다.\n위의 이유와 더불어 서버를 거치지 않는 편이 사용자 경험 면에서 효과적이고 서버 부담의 측면에서 효율적이라고 생각해 클라이언트에서 카테고리별 필터링 처리를 담당하기로 했다.\n{ debates.data?.pages.map((page, idx) =\u0026gt; ( \u0026lt;div key={idx}\u0026gt; {page.list.map((debate: DebateOfDebates) =\u0026gt; list.include(debate.category) ? ( \u0026lt;div key={debate.id}\u0026gt; \u0026lt;div\u0026gt;{debate.title}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) : ( \u0026lt;p\u0026gt;토론이 없습니다.\u0026lt;/p\u0026gt; ) )} \u0026lt;/div\u0026gt; )); } 하지만 이 경우 목록의 요소가 없을 때 게시물이 없다고 표시하는 것이 힘들었다. 서버에서 처리할 경우 받은 데이터가 없을 경우에만 해당 처리를 하면 됐다.\n하지만 클라이언트에서 처리할 경우 게시물이 pages.list 내부의 page에서 조건부 렌더링을 하다보니 딱 하나만 나오게 하는 것이 불가능 했다. 그래서 따로 checkEmpty라는 함수를 만들어서 처리했다.\nconst checkEmpty = () =\u0026gt; { return ( debates.data?.pages .map((page) =\u0026gt; page.list.filter((debate: DebateOfDebates) =\u0026gt; checkCategory(list, debate.category) ) ) .flat().length === 0 ); }; checkCategory(list, debate.category) ? 재랜더링 시 useState 초기화 문제 #토론 목록 페이지에서는 기본 목록 이외에도 사용자가 좋아요를 누른 토론 목록만 볼 수 있다. 이 둘은 조건부 렌더링을 통해서 전환되는데 이 과정에서 목록의 재요청을 발생시키지 않아서 좋지만 정렬 방식의 표시만 초기화되는 문제가 발생했다. 이유는 useSelect의 초기값이 COMMENT_ORDER[0][0]로 초기화 되기 떄문이다.\nconst orderSelect = useSelect(COMMENT_ORDER[0][0], refetch); 그래서 두 컴포넌트의 전환이 일어나도 값을 지니고 있을 수 있게 상위 컴포넌트에 값을 저장하고 하위 컴포넌트에서 값을 변경시키는 방식을 택했다.\n// 상위 컴포넌트 const [order, setOrder] = useState\u0026lt;string\u0026gt;(\u0026#34;DESC\u0026#34;); // 하위 컴포넌트 const orderSelect = useSelect(order, refetch, setOrder); // 변경 시 setOrder로 order의 값 변경 두 칸 이상의 공백과 한 줄 이상의 개행 제거 #이전에 한번 고민하고 도전했지만 실패했던 문제이다. *참조 1, 참조 2\n토론 게시물이기 때문에 공백과 개행에 있어서 너무 많은 자유도를 주고 싶지 않았지만, 사용자가 작성 시에는 신경 쓰게 하고 싶지 않았다. 그래서 처음에는 trim을 사용해서 공백과 개행을 제거해 줬지만 [참조 2]의 이유로 유효성 검사 내부로 이동시켜 줬다.\n하지만 여전히 한 줄만 작성하는 input 태그에서는 적절히 작동하지만 여러 줄을 작성하는 textarea에서는 적절히 작동하지 않았다. 내가 원하는 방식은 사용자가 작성 시에는 마음대로 작성하고 데이터 베이스에 저장될 때는 두 칸 이상의 공백과 한 줄 이상의 개행을 제거하는 것이다.\n정규 표현식으로 충분히 해결할 수 있는 문제라고 생각해서 이 사이트에서 열심히 연구했다. 기존에는 너무 한번에 해결하려고 했던게 문제라고 생각해 이번에는 단계별로 하나씩 처리하기로 했다. 우선 두칸 이상의 공백을 모두 제거한 뒤, 각 행의 시작과 끝의 공백을 제거하고 한 줄 이상의 개행을 제거했다.\nstr .replace(/\\s{2,}/g, \u0026#34; \u0026#34;) .replace(/^\\s|\\s$/gm, \u0026#34;\u0026#34;) .replace(/\\n{3,}/g, `\\n\\n`); 하지만 \\s는 공백을 포함하는 개행이라 위의 식이 내가 원하는 데로 잘 작동하지 않았다. 그래서 개행을 제외한 공백을 표현하는 정규식을 찾았지만 찾는데 실패했다. 그러던 와중 개행은 \\n로 따로 구분할 수 있으니 다른 정규식으로 치환했다가 다시 되돌린 후 제거하는 방식을 떠올렸다.\nreturn str .replace(/\\n/g, `\\0`) .replace(/\\s{2,}/g, \u0026#34; \u0026#34;) .replace(/^\\s|\\s$/gm, \u0026#34;\u0026#34;) .replace(/\\0/g, `\\n`) .replace(/\\n /g, `\\n`) .replace(/ \\n/g, `\\n`) .replace(/\\n{3,}/g, `\\n\\n`); 쿼리 파라미터의 타입 #무한 스크롤을 구현하기 위해서 마지막 페이지인지를 판단할 필요가 있었다. 쿼리 파라미터로 받은 페이지 값과 마지막 페이지를 비교해서 구현하려 했는데 제대로 작동하지 않았다.\nconst isLastPage = lastPage === query.page; 그래서 콘솔로 찍어보니 typeof query.page는 string 이었다. 숫자로 바꿔주기만 하면 되는 간단한 문제였지만 이 과정에서 이해하지 못할 현상과 마주쳤다. parseInt로 숫자화 시키려고 하자 query.page의 타입이 number라서 할당할 수 없다는 것이다. 그래서 Number를 사용하자 이상없이 작동했다.\n쿼리 파라미터 한글 깨짐 현상 #카테고리별 필터링 기능이 제대로 작동하지 않아 요청 주소를 살펴보니 한글이 인코딩 돼서 가고 있었다. decodeURI를 사용해서 간단히 해결했다.\nconst decodedCategory = decodeURI(`${dto.category}`); // 배열을 문자로 const decodedCategories = decodedCategory.split(\u0026#34;,\u0026#34;); // 문자를 배열로 Ps. 하지만 서버에 요청하는 카테고리 필터링 기능은 폐기했다. 😅😅😅\nreact-hot-toast 사용 #기존에는 에러 메시지를 커스텀 모달로 띄웠다. 하지만 서버에 요청을 하는 컴포넌트마다 모달 컴포넌트와 해당 모달을 관리하는 상태 관리 코드까지 필요해 코드가 너무 길어졌다. 또한 버튼을 눌러서 닫아야 하기 때문에 사용자에게 불필요한 추가 행위를 요구한다.\nreact-hot-toast를 사용하면 코드도 훨씬 간결해지고 사용자가 버튼을 눌러서 닫을 필요도 없기 때문에 에러 메시지를 띄우기 더 적절하다고 판단해 도입했다. 추가로 useMutation의 onError와 함께 사용해 서버에서 에러 메시지를 받아서 그대로 보여줄 수도 있다.\nconst [isSameModal, setIsSameModal] = useState\u0026lt;boolean\u0026gt;(false); ... { isSameModal ? ( \u0026lt;ConfirmModal title=\u0026#34;수정 실패\u0026#34; content=\u0026#34;변경된 내용이 없습니다.\u0026#34; firstBtn=\u0026#34;확인\u0026#34; firstFunc={() =\u0026gt; { setIsSameModal(false); }} /\u0026gt; ) : null; } ... { onError: (err) =\u0026gt; { toast.error(`${err.message}`); }; } Ps. 도입 과정에서 요청에 대한 에러가 에러로 오지 않고 string 메시지로 오고 있는 것을 발견했다. (서버가 꺼진게 아닌 이상 항상 성공 응답을 받음) 서버에서 return 에러 메시지를 한 것이 원인이었고, 클라이언트에서는 에러를 서버가 꺼진 경우로만 확인해서 발견하지 못했었다. 이제는 throw new HttpException을 사용해서 에러가 발생해야 하는 상황에 정상적으로 에러 처리가 된다.\n","date":"23 July 2022","permalink":"/posts/projects/debate-ducks/14/","section":"Posts","summary":"목차 변경","title":"[Debate-Ducks] 기본 기능 마무리"},{"content":"Summary #토론 게시물 생성, 조회, 수정, 삭제\nDetails #React Query 커스텀훅 #useQuery과 useMutation을 커스텀훅으로 만들어 재사용성과 안정성을 높였다. 성공 시와 에러 발생 시의 로직도 미리 작성해뒀다.\nPs. usePatchDebate의 isEdit으로 토론 게시물을 수정할 때와 토론에 참여할 때를 구분했다. (토론에 참여할 때 토론 테이블의 participant_id를 업데이트함)\n구분의 기준을 isEdit애서 넘겨주는 참가자 정보 여부로 변경 export const useGetDebate = ( debateId: number, options?: UseQueryOptions\u0026lt;Debate, AxiosError\u0026gt; ) =\u0026gt; { const router = useRouter(); const { isLoading, data } = useQuery\u0026lt;Debate, AxiosError\u0026gt;( [\u0026#34;debate\u0026#34;, `${debateId}`], () =\u0026gt; getDebate(debateId), { ...options, onError: () =\u0026gt; { router.push(\u0026#34;/\u0026#34;); //Todo: 에러 페이지로 이동 }, } ); return { isLoading, data }; }; export const usePostDebate = ( setIsErrorModalOn: Dispatch\u0026lt;SetStateAction\u0026lt;boolean\u0026gt;\u0026gt; ): UseMutationResult\u0026lt;DebatePost, AxiosError, DebatePost\u0026gt; =\u0026gt; { const router = useRouter(); const queryClient = useQueryClient(); return useMutation((debate) =\u0026gt; postDebate(debate), { onSuccess: (debateId) =\u0026gt; { queryClient.invalidateQueries([\u0026#34;debates\u0026#34;]); router.push(`/debates/${debateId}`); }, onError: () =\u0026gt; { setIsErrorModalOn(true); }, }); }; export const usePatchDebate = ( setIsErrorModalOn: Dispatch\u0026lt;SetStateAction\u0026lt;boolean\u0026gt;\u0026gt;, isEdit?: boolean ): UseMutationResult\u0026lt;DebatePatch, AxiosError, DebatePatch\u0026gt; =\u0026gt; { const router = useRouter(); const queryClient = useQueryClient(); return useMutation((debate) =\u0026gt; patchDebate(debate), { onSuccess: (debateId) =\u0026gt; { queryClient.invalidateQueries([\u0026#34;debate\u0026#34;, `${debateId}`]); if (isEdit) router.push(`/debates/${debateId}`); }, onError: () =\u0026gt; { setIsErrorModalOn(true); }, }); }; export const useDeleteDebate = ( setIsErrorModalOn: Dispatch\u0026lt;SetStateAction\u0026lt;boolean\u0026gt;\u0026gt; ): UseMutationResult\u0026lt;number, AxiosError, number\u0026gt; =\u0026gt; { const router = useRouter(); const queryClient = useQueryClient(); return useMutation((debateId) =\u0026gt; deleteDebate(debateId), { onSuccess: () =\u0026gt; { queryClient.invalidateQueries([\u0026#34;debates\u0026#34;]); router.push(`/debates`); }, onError: () =\u0026gt; { setIsErrorModalOn(true); }, }); }; 생성과 수정의 공통요소 #이번 작업에서 가장 신경 쓴 부분이 기능만 다를 뿐 똑같은 형태인 생성 페이지와 수정 페이지를 공통 요소로 최대한 묶는 것이었다. 처음에는 거의 모든 요소를 공통 컴포넌트에 넣은 다음 debateId를 지니고 있는 경우는 수정, 지니고 있지 않은 경우는 생성으로 나눴지만 몇 가지 문제를 만났다.\n첫 번째 문제는 React의 Hook은 조건부 렌더링을 할 수 없는 것이고, 두 번째 문제는 공통 요소의 타입을 Union Type으로 지정했으나 각각의 React Hook이 타입 에러를 뱉는 것이다. (다른 타입이 들어올 가능성이 생기기 때문) 그래서 우선 공통 기능을 함수로 묶고, 공통 HTML 요소는 컴포넌트로 묶었다. 그 이외의 남는 부분들은 각 페이지에 남겼다. 이 과정에서 기존에 내가 만든 커스텀훅들의 타입 정리가 필요했다. (props나 인자로 사용하기 위해서 필요)\n생성 페이지와 수정 페이지는 각 상태의 기본값과 API 및 body의 구성요소만 다르다.\nPs. 수정 페이지에서 기존 데이터와 입력값이 똑같을때 요청을 보내지 않고 안내 모달을 띄우는 로직 추가.\n// edit/[debateId].tsx export default function Edit() { const router = useRouter(); const param = router.query; const debateId = typeof param?.debateId === \u0026#34;string\u0026#34; ? parseInt(param?.debateId) : 0; const { data } = useGetDebate(debateId); const [isSameModal, setIsSameModal] = useState\u0026lt;boolean\u0026gt;(false); const [isErrorModalOn, setIsErrorModalOn] = useState\u0026lt;boolean\u0026gt;(false); const [isCancelModalOn, setIsCancelModalOn] = useState\u0026lt;boolean\u0026gt;(false); const titleRef = useRef\u0026lt;HTMLInputElement\u0026gt;(null); const [validateNotice, setValidateNotice] = useState\u0026lt;string\u0026gt;(\u0026#34;\u0026#34;); const titleInput = useInput(data?.title || \u0026#34;\u0026#34;, \u0026#34;\u0026#34;); const categorySelect = useSelect(data?.category || CATEGORIES[0]); const prosConsRadio = useRadio( data?.author_pros ? `${data?.author_pros}` : \u0026#34;false\u0026#34;, \u0026#34;prosCons\u0026#34; ); const contentsInput = useInput(data?.contents || \u0026#34;\u0026#34;, \u0026#34;\u0026#34;); const postDebate = usePatchDebate(setIsErrorModalOn, true); const debate: DebatePatch = { title: titleInput.value, author_pros: prosConsRadio.value, category: categorySelect.value, contents: contentsInput.value, id: data?.id || 0, }; const edit = () =\u0026gt; { if (!data) return; if ( // Edit 고유 로직 data.title === debate.title \u0026amp;\u0026amp; data.author_pros === debate.author_pros \u0026amp;\u0026amp; data.category === debate.category \u0026amp;\u0026amp; data.contents === debate.contents ) { setIsSameModal(true); } else { // 공통 함수 createOrEdit(titleRef, setValidateNotice, titleInput, () =\u0026gt; { postDebate.mutate(debate); }); } }; // 공통 HTML if (!data) return \u0026lt;\u0026gt;404\u0026lt;/\u0026gt;; return ( \u0026lt;div\u0026gt; {isSameModal ? ( \u0026lt;ConfirmModal title=\u0026#34;작성 실패\u0026#34; content=\u0026#34;변경 내용이 없습니다.\u0026#34; firstBtn=\u0026#34;확인\u0026#34; firstFunc={() =\u0026gt; { setIsSameModal(false); }} /\u0026gt; ) : null} \u0026lt;CreateOrEdit isErrorModalOn={isErrorModalOn} setIsErrorModalOn={setIsErrorModalOn} isCancelModalOn={isCancelModalOn} setIsCancelModalOn={setIsCancelModalOn} titleRef={titleRef} validateNotice={validateNotice} setValidateNotice={setValidateNotice} titleInput={titleInput} categorySelect={categorySelect} prosConsRadio={prosConsRadio} contentsInput={contentsInput} createOrEdit={edit} routerPush={() =\u0026gt; { router.push(`/debates/${debateId}`); }} /\u0026gt; \u0026lt;/div\u0026gt; ); } Problems #작동 순서 문제 #createOrEdit 함수 내에서 좌우 여백을 trim하고 debate를 변경한 다음 post 하는 로직을 만들었으나, postDebate.mutate(debate)를 콜백함수로 넘기는 시점에서 trim 되지 않은 debate가 넘어가서 원하는데로 작동하지 않았다. 그래서 우선은 createOrEdit 내에서 유효성 검사를 통해 걸러주는 방식을 선택했다.\nsetTimeout으로 해결 *참조 createOrEdit(titleRef, setValidateNotice, titleInput, () =\u0026gt; { postDebate.mutate(debate); // 내부에서 debate를 변경해도 이 시점에서 변경되기 이전의 debate가 넘어감 }); Etc #TypeScript 및 React Query #타입 스크립트가 가끔 귀찮은 상황을 만들기도 하지만 그만큼 안정적이라 기본 CRUD 작업에 들어간 다음에는 에러를 거의 못 보고 있다. 특히 타입이 명확히 정해져 있다 보니 오타로 인한 에러 방지에 탁월했다.\n또한 서버와 연동되는 작업을 시작하니 유용성을 더욱 느낄 수 있었다. 이전에는 API나 데이터베이스에 수정 사항 혹은 요청 사항이 있을 때 일일이 확인해도 가끔씩 문제가 발생했다. 하지만 타입 스크립트는 컴파일 과정에서 바로바로 에러를 뱉어주다 보니 문제가 생기기 전에 미연에 방지할 수 있었다.\n리액트 쿼리의 경우 직접 사용해 보기 이전에는 전역 상태 관리에 큰 장점이 있다고 생각했었다. 하지만 직접 사용해 보고 나니 특정 컴포넌트 내부에서만 사용 하더라도 충분히 사용할 가치가 있었다. 서버에서 받는 데이터를 관리할 때 필요한 여러 부가적인 상태들과 함수들을 따로 작성할 필요가 없이 쉽게 사용할 수 있기 때문이다.\n무엇보다 클라이언트에서 관리되야 하는 상태와의 구분히 명확해져서 코드가 이전보다 훨씬 직관적이다. 또한 여러 옵션들을 통해 다양한 기능들을 별도의 코드작성 없이 쉽게 사용할 수 있는 장점도 매우 크다.\n","date":"19 July 2022","permalink":"/posts/projects/debate-ducks/13/","section":"Posts","summary":"Summary #토론 게시물 생성, 조회, 수정, 삭제","title":"[Debate-Ducks] 토론 게시물 CRUD"},{"content":" 정리 필요 상태관리 #상태란? 주어진 시간에 대해 시스템을 나타내는 것으로 언제든지 변경될 수 있음 - 개발자 입장에서는 관리해야 하는 데이터\n모던 웹프런트엔드 개발 UI/UX 중요성과 함께 FE에서 수행하는 역할이 늘어남 -\u0026gt; 관리하는 상태가 많아짐\n상태관리란? 상태를 관리하는 방법에 대한 것 리액트는 단반향 바인딩이라 Props Drilling 이슈가 존재 Redux나 MobX같은 라이브러리로 이 문제를 해결하기도 함\n주문 FE 프로덕트를 보며 가진 고민 #너무 세분화 되어있었음 각각 레포가 다 달랐음 2021년 여름 이왕 할꺼 Repo 합치고 레거시도 치우고 신기술 검토도 하면서 주문 FE 아키텍처 통합해보자 Store는 전역 상태가 저장되고 관리되는 공간인데 상태 관리보다는 API 통신 코드로 보인다\n여기서 다 관리하는게 맞나? 반복되는 API 관련 상태 반복되는 비슷한 구조의 API 통신 코드\n서버에서 받아야하는 상태들에 특성 Client에서 제어하거나 소유되지 않은 원격의 공간에서 관리되고 유지됨 Fetching이나 Updating에 비동기 API가 필요함 다은 사람들과 공유되는 것으로 사용가자 모르는 사이에 변경될 수 있음 신경 쓰지 않는다면 잠재적으로 \u0026ldquo;out of data\u0026quot;가 될 가능성을 지님\n사실상 FE에서 이 값이 저장되어있는 state들은 일종의 캐시\n어쩌면 다른 관리방법이 있으면 좋을지도\n상태를 두가지로 나눔 Client State vs Server state\nOwnership이 클라이언트에 있냐 Server에 있냐 차이\n주문에서는 React Query 사용\nReact Query 살펴보기 #Overview #데이터 가져오기, 캐시, 동기화, 데이터 업데이트를 다룬다.\n세가지 컨셉 퀙 스타트에 잘 나와있음\nUse Query #Queries\n데이터 패칭용 Reading에만 사용 Query Key Query Function 프로미스를 반환하는 함수\n반환하는거 많음\ndata, error, isLoading, refetch, onSuccess, onError\nconfig 커스텀은? 뒤에 옵션\nenabled, refetchInterval, keepPreviousData, refetchInterval\n쿼리즈 파일 분리 추천 (스샷있음)\nQ. enabled 옵션을 state로 관리할지 아님 false로 두고 refetch()를 사용할지? refetch 쓰다가 ㅈㄴ 복잡한 컨디션 일때만 useState 사용\nMutation #쿼리 키를 넣어주면 devtools에서 볼 수 있음 없어도 됨\n반환, mutate, mutateAsync\n옵션 onMutate 본격적인 뮤테이선 동작전에 실행 Optimistic update 적용할 때 유용!!! Ex. facebook 좋아요 UI 실패하면 롤백\nInvalidation #메서드 호출하면 끝 해당 키를 가진 쿼리는 stale 취급되고 현재 랜더링 되는 쿼리들은 백그에서 리패치됨 키 없으면 전체\n자기소개 자랑에 비해서 부족하지 않음??\nCashing과 Synchronization #cacheTime 메모리에 얼마나 있을 지 (def 5분) staleTime (def 0)\n기본값들 저기 있음!!!\n똑같은 쿼리 가지 컴포가 생기면 다시 생성함!\n어디에서 값을 관리할까요? #전역 상태처럼 관리되는 데이터들!!!\nContext API\n이거 좋아요\n서버상태 관리 용이하며 직관적이 API 호출 코드\nAPI 처리에 관한 각종 인터페이스 및 옵션 제공\nClient Store가 FE에서 정말 필요한 전역 상태만 남아 Store 답게 사용 (Boilerplate 코드 매우 감소)\ndevtools 제공으로 원할한 디버깅\ncache 전략 필요할 떄\n고민 필요?\n컴포넌트가 비대해지는 문제 난이도가 높아짐 컴포넌트 유착 최소화\n트랜드 보다는 Why가 중요!!!!!\n","date":"18 July 2022","permalink":"/posts/studies/react/react-query/1/","section":"Posts","summary":"정리 필요 상태관리 #상태란?","title":"[React-query] React Query와 상태관리 (feat. 2월 우아한테크세미나)"},{"content":"Summary #리액트 쿼리 적용.\nDetails #Next.js \u0026amp; React Query #Next.js는 공부해 본 적은 있지만 간단한 체험만 해봤지 직접 사용하는 것은 처음이었고, React Query는 장단점에 대해서만 알아봐서 이번에 새로 공부해야 했다.\n처음에는 \u0026ldquo;Next.js + React Query\u0026quot;를 검색해서 적용 방법을 알아봤지만 각각의 개념을 잘 모르는 상태라서 이해가 어려웠다. 그래서 우선 Next.js에 대한 복습을 하고 React Query는 공문서와 유튜브를 통해 따로 학습했다.\n공부를 하면서 상태 관리에 대한 이해가 많이 부족한 것을 느꼈다. 이전 프로젝트에서 Redux-toolkit을 사용했는데 유저 정보 이외에는 상태 관리를 할 필요를 못 느껴서 유저 정보만 상태 관리를 했다. 하지만 상태 관리는 서버로의 요청을 줄이고 시키고 사용자 경험을 향상시키기 위해 필요한 것이었다. 이를 이해하자 Next.js의 SSR과 React Query를 왜 사용하는지도 이해할 수 있었고, 왜 사용하는지를 이해하자 어떻게 사용하는지도 이해할 수 있었다.\nPs. 단순 사용 방법은 금방 익혔으나 잘 사용하기 위한 고민에 많은 시간을 썼고 그럼에도 아직 명확하게 해결되지 않았다.\nHydration #공식 문서에 따르면 React Query는 initialData를 주는 방법과 Hydration을 하는 두 가지의 방법으로 prefetching을 지원한다. initialData를 주는 방법은 간단하지만 해당 데이터를 사용하는 컴포넌트까지 props로 넘겨주어야 하는 비효율적인 상황이 발생할 수 있다. 그래서 이번 프로젝트에서는 Hydration을 하는 방법을 선택했다. 이를 위해서는 _app.tsx에 다음과 같은 간단한 설정이 필요하다.\nOn the client, the HTML is used to show a fast non-interactive page, while React uses the JSON data and JavaScript instructions to make components interactive (for example, attaching event handlers to a button). This process is called hydration. // _app.tsx import type { AppProps } from \u0026#34;next/app\u0026#34;; import { useState } from \u0026#34;react\u0026#34;; import { Hydrate, QueryClient, QueryClientProvider } from \u0026#34;react-query\u0026#34;; import { ReactQueryDevtools } from \u0026#34;react-query/devtools\u0026#34;; function MyApp({ Component, pageProps }: AppProps) { const [queryClient] = useState( () =\u0026gt; new QueryClient({ defaultOptions: { queries: { staleTime: Infinity, // refetchOnMount: false, // refetchOnWindowFocus: false, // refetchOnReconnect: false, }, }, }) ); return ( \u0026lt;QueryClientProvider client={queryClient}\u0026gt; \u0026lt;Hydrate state={pageProps.dehydratedState}\u0026gt; \u0026lt;Component {...pageProps} /\u0026gt; \u0026lt;/Hydrate\u0026gt; \u0026lt;ReactQueryDevtools /\u0026gt; \u0026lt;/QueryClientProvider\u0026gt; ); } export default MyApp; Ps. staleTime은 데이터의 상태가 fresh에서 stale로 변경되는데 걸리는 시간.\nPs. stale 상태일 때 다음의 경우 refetch가 일어남. (fresh 상태일 때는 X)\n새로운 쿼리 인스턴스 mount (page 재방문) 브라우저 화면 이탈 후 다시 포커스 네트워크 재연결 refetchInterval SSR #SSR이 어떻게 작동하는지 눈으로 확인해 보기 위해 getServerSideProps를 주석 처리해 봤다. 그러자 마지막에 \u0026ldquo;10\u0026quot;을 한 번 더 요청하고 debateId가 undefined인 상태로 useQuery가 한번 작동하는 것을 확인할 수 있었다. (아래 그림 참조)\nimport type { GetServerSideProps } from \u0026#34;next\u0026#34;; import { useRouter } from \u0026#34;next/router\u0026#34;; import { dehydrate, QueryClient, useQuery } from \u0026#34;react Query\u0026#34;; import { getDebate } from \u0026#34;../../../api\u0026#34;; import { IDebateInfo } from \u0026#34;../../../types\u0026#34;; export default function Debates() { const router = useRouter(); const { debateId } = router.query; const { isLoading, error, data } = useQuery\u0026lt; Omit\u0026lt;IDebateInfo, \u0026#34;author_id\u0026#34;\u0026gt;, Error \u0026gt;([\u0026#34;debate\u0026#34;, debateId], () =\u0026gt; getDebate(debateId)); if (!data) router.push(`/debates`); if (isLoading) return \u0026lt;\u0026gt;loading...\u0026lt;/\u0026gt;; if (error) return \u0026lt;\u0026gt;error\u0026lt;/\u0026gt;; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Debate: {debateId}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{data?.id}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{data?.category}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{data?.author.name}\u0026lt;/p\u0026gt; \u0026lt;div\u0026gt;HELLO WORLD!\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export const getServerSideProps: GetServerSideProps = async (context) =\u0026gt; { const debateId = context.params?.debateId; const queryClient = new QueryClient(); await queryClient.prefetchQuery([\u0026#34;debate\u0026#34;, debateId], () =\u0026gt; getDebate(debateId) ); return { props: { dehydratedState: dehydrate(queryClient), // dehydratedState: JSON.parse(JSON.stringify(dehydrate(queryClient))), }, }; }; export const getDebate = async (debateId: string | string[] | undefined) =\u0026gt; { if (!debateId) return; const { data } = await axios.get( `${process.env.NEXT_PUBLIC_API_URL}/debates/${debateId}`, { withCredentials: true } ); return data; }; Why? #staleTime: Infinity라서 이미 데이터를 패치한 경우 다시 패치하지 않을 것으로 예상했으나 getServerSideProps가 있는 페이지를 방문할 경우 데이터를 다시 패치한다. 이 과정에서 다시 한번 본질적인 의문이 들었다. 만약 페이지를 방문할 때마다 데이터를 요청한다면 굳이 React Query로 서버 상태 관리를 할 필요가 있는가?\n우선 다시 한번 React Query의 필요성을 검토했다. 그 결과 useState로 data, isLoading, error등을 따로 관리하도 되지 않아도 된다는 장점과 서버 상태 관리가 필요한 부분이 있기 때문에 충분히 필요하다고 결론을 내렸다. 게시물 목록을 무한 스크롤로 관리하는 경우 목록을 가지고 있을 필요가 있고 또한 게시물 편집 페이지에서는 게시물 정보를 새로 가져올 필요가 없이 게시물 페이지로부터 가지고 오면 된다.\n","date":"17 July 2022","permalink":"/posts/projects/debate-ducks/12/","section":"Posts","summary":"Summary #리액트 쿼리 적용.","title":"[Debate-Ducks] React Query 기초"},{"content":"Summary #토론 생성 기능 추가. 공통 함수 및 컴포넌트 제작.\nDetails #확인용 모달 #첫 번째 버튼만 입력할 경우 확인만 가능하고, 두 번째 버튼까지 입력할 경우 취소 혹은 확인의 선택이 가능하다.\nexport default function ConfirmModal({ title, content, firstBtn, firstFunc, secondBtn, secondFunc, }: { title: string; content: string; firstBtn: string; firstFunc: () =\u0026gt; void; secondBtn?: string; secondFunc?: () =\u0026gt; void; }) { const handleCancel = () =\u0026gt; { firstFunc(); }; const handleConfirm = () =\u0026gt; { if (secondFunc) secondFunc(); }; return ( \u0026lt;div\u0026gt; {title} {content} \u0026lt;button onClick={handleCancel}\u0026gt;{firstBtn}\u0026lt;/button\u0026gt; {secondBtn ? \u0026lt;button onClick={handleConfirm}\u0026gt;{secondBtn}\u0026lt;/button\u0026gt; : null} \u0026lt;/div\u0026gt; ); } 입력 관련 커스텀훅 #컴포넌트에서 사용할 때 쉽게 사용할 수 있게 필요한 속성을 정리해서 return 해줬다.\nimport { useState, ChangeEvent } from \u0026#34;react\u0026#34;; export const useInput = (initialValue: string, placeholder: string) =\u0026gt; { const [value, setValue] = useState(initialValue); const onChange = ( ev: ChangeEvent\u0026lt;HTMLInputElement | HTMLTextAreaElement\u0026gt; ): void =\u0026gt; { setValue(ev.target.value); }; return { attribute: { value, placeholder, onChange }, value, setValue, }; }; export const useRadio = (initialValue: \u0026#34;true\u0026#34; | \u0026#34;false\u0026#34;, name: string) =\u0026gt; { const [value, setValue] = useState\u0026lt;string\u0026gt;(initialValue); const onChange = (ev: ChangeEvent\u0026lt;HTMLInputElement\u0026gt;) =\u0026gt; { if (ev.target.value !== value) setValue(ev.target.value); }; return { attributeTrue: { type: \u0026#34;radio\u0026#34;, name, value: \u0026#34;true\u0026#34;, checked: value === \u0026#34;true\u0026#34;, onChange, }, attributeFalse: { type: \u0026#34;radio\u0026#34;, name, value: \u0026#34;false\u0026#34;, checked: value === \u0026#34;false\u0026#34;, onChange, }, value: value === \u0026#34;true\u0026#34; ? true : false, setValue, }; }; export const useSelect = (initialValue: string) =\u0026gt; { const [value, setValue] = useState(initialValue); const onChange = (ev: ChangeEvent\u0026lt;HTMLSelectElement\u0026gt;) =\u0026gt; { if (ev.target.value !== value) setValue(ev.target.value); }; return { attribute: { value, onChange }, value, setValue, }; }; // example.tsx ... const titleInput = useInput(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;); const contentsInput = useInput(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;); const prosConsRadio = useRadio(\u0026#34;true\u0026#34;, \u0026#34;prosCons\u0026#34;); const categorySelect = useSelect(CATEGORIES[0]); return ( ... \u0026lt;input {...titleInput.attribute} ref={titleRef} /\u0026gt; \u0026lt;textarea {...contentsInput.attribute} /\u0026gt; \u0026lt;input {...prosConsRadio.attributeTrue} /\u0026gt; \u0026lt;input {...prosConsRadio.attributeFalse} /\u0026gt; \u0026lt;select {...categorySelect.attribute}\u0026gt; {CATEGORIES.map((category) =\u0026gt; ( \u0026lt;option key={category}\u0026gt;{category}\u0026lt;/option\u0026gt; ))} \u0026lt;/select\u0026gt; ... ) 유효성 검사 #처음에는 공백으로 시작하거나 끝날 때 혹은 공백이 연속으로 올 때를 유효성 검사로 따로 확인했으나, trim과 replace를 사용해서 사용자가 따로 신경 안 써도 되게 만들어 UX를 높였다.\ntrim은 두 칸 이상의 공백과 한 줄 이상의 개행 제거 함수로 대체 *참조 const title = titleInput.value.trim().replace(/ +/g, \u0026#34; \u0026#34;);; titleInput.setValue(title); if (/[^\\s\\w가-힣.,!?%\u0026amp;()]/.test(title)) { setValidateNotice( \u0026#34;제목은 한글, 영어, 숫자 및 특수문자【.,!?%\u0026amp;()_】만 포함 가능합니다.\u0026#34; ); titleRef.current?.focus(); return; } if () if (title.length \u0026lt; 5 || title.length \u0026gt; 80) { setValidateNotice(\u0026#34;제목은 5자 이상, 80자 이하여야 합니다.\u0026#34;); titleRef.current?.focus(); return; } setValidateNotice(\u0026#34;\u0026#34;); setValidateNotice는 useEffect로 입력 시 자동으로 꺼지게 만들었다.\nuseEffect(() =\u0026gt; { setValidateNotice(\u0026#34;\u0026#34;); }, [setValidateNotice, titleInput.value]); // dependency에 titleInput.value 필요 Ps. 특정 문자가 몇 자 이상인지 검사하는 함수\nfunction checkOverLimit(text: string, chars: string[], limit: number) { for (let i = 0; i \u0026lt; chars.length; i++) { const regexp = new RegExp(chars[i], \u0026#34;g\u0026#34;); const match = text.match(regexp); return match ? match.length \u0026gt; limit : false; } } Problems #CORS 문제 ## 문제\n서버와 요청을 주고받을 때 CORS 문제 발생.\n# 해결\n서버 측의 main.ts에 CORS 설정 추가.\napp.enableCors({ origin: true, // 해당 클라이언트 주소로 수정 예정 methods: [\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;OPTIONS\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;, \u0026#34;PATCH\u0026#34;], credentials: true, }); Etc #재사용성 #이전 프로젝트에서 재사용이 가능한 커스텀훅이나 컴포넌트를 만들 때 다양한 기능을 한 번에 처리할 수 있게 만들었다. 그래서 오히려 재사용성과 확장성을 잃어버렸다. 이번에는 기능별로 조금 더 작은 단위로 쪼개서 만들 것이다.\n예전에 책에서 \u0026ldquo;한 가지 함수는 한 가지 기능을 해야 한다.\u0026ldquo;라고 본 적이 있다. 이때까지는 여러 기능이 합쳐져서 한 가지 기능을 할 때 최종 기능만을 한 가지 기능으로 봤었다. 이제는 재사용성과 확장성을 고려해서 좀 더 낮은 단계의 기능들을 각각 한 가지 기능으로 볼 것이다.\n","date":"16 July 2022","permalink":"/posts/projects/debate-ducks/11/","section":"Posts","summary":"Summary #토론 생성 기능 추가.","title":"[Debate-Ducks] 토론 생성"},{"content":" 귀국, 입원 및 수술 등의 이유로 한 달 넘게 중지됐던 개발 재개 Summary #재연결 시 녹화 영상 유지 기능 구현 시도. (보류)\nDetails #Data channel #기존에는 서버에 녹화 영상을 저장하는 방식을 사용했으나 서버를 거치는 방식이 비효율적이라고 판단해 WebRTC의 Data channel을 통해 재연결 시 이미 연결되어 있는 사용자가 재연결한 사용자에게 기존의 녹화 영상을 전송해서 녹화영상이 유지되게 만들었다.\nconst blobs = blobsRef.current; blobs.reverse().forEach((blob) =\u0026gt; { new Response(blob).arrayBuffer().then((arrayBuffer) =\u0026gt; { peerRef.current?.send(arrayBuffer); }); }); simplePeer.on(\u0026#34;data\u0026#34;, (arrayBuffer) =\u0026gt; { const blob = new Blob([new Uint8Array(arrayBuffer)], { type: \u0026#34;video/webm\u0026#34;, }); blobsRef.current.unshift(blob); }); 녹화 영상 유지 기능 삭제 #녹화 영상 유지 기능을 삭제했기 때문에 토론 중에 한쪽의 연결이 끊겼을 경우 남아있는 사용자가 해당 시점까지 진행된 토론의 녹화 영상을 올리고 토론을 종료시킬지 아니면 토론을 처음부터 다시 시작할지 선택할 수 있게 만들었다.\nPs. 스킵을 1분 미만일 때만 가능하게 변경했다. 매초 재랜더링이 일어나는 것을 방지하기 위해 시간은 useRef로 관리하며 스킵이 가능하지 않을 때는 따로 안내하게 만들었다. (버튼 비활성화를 위해서는 useState로 변경을 추적해야 해서 비효율적)\nProblems #녹화 영상 깨짐 현상 ## 문제\n토론이 중단된 후 재시작 됐을 때 재시작 이후의 녹화 영상이 깨지는 현상이 발생한다.\n# 원인\nrecorder가 변경됐을 때 녹화를 중지하고 다시 시작하게 했으나, 이미 recorder는 변경되어 record 내부의 기존 recorder는 종료되지 않고 계속 작동하기 때문에 문제가 발생한다.\nfunction record({ canvasRef, mergedAudio, setRecorder, blobsRef, }: Pick\u0026lt; IDebateroom, \u0026#34;canvasRef\u0026#34; | \u0026#34;mergedAudio\u0026#34; | \u0026#34;setRecorder\u0026#34; | \u0026#34;blobsRef\u0026#34; \u0026gt;) { const canvasStream = canvasRef.current?.captureStream(30); if (!canvasStream || !mergedAudio) return; const mergedTracks = canvasStream.getVideoTracks().concat(mergedAudio); if (!mergedTracks) return; const mergedStream = new MediaStream(mergedTracks); if (!mergedStream) return; const recorder = new MediaRecorder(mergedStream, { mimeType: \u0026#34;video/webm\u0026#34;, }); if (!recorder) return; recorder.ondataavailable = (ev) =\u0026gt; { blobsRef.current?.push(ev.data); }; setRecorder(recorder); } useEffect(() =\u0026gt; { if (!isStart) return; if (recorder?.state === \u0026#34;recording\u0026#34;) { recorder?.stop(); } recorder?.start(1000 / 30); }, [isStart, recorder]); # 해결\nrecorder를 변경하기 전에 recorder?.stop();을 먼저 실행해서 해결했다.\nPs. 굉장히 쉬운 문제였지만 원인을 잘못 파악해 해결에 많은 시간이 걸렸다. Blob에 대한 공부가 부족해 Blob을 합칠 때 발생하는 문제라고 생각했었다. (Blob을 합치는 것은 이 문제가 아닌 다른 문제를 발생 시킨다. 😢😢😢)\n녹화 영상 시간 점프 현상 ## 문제\n재시작 이후의 녹화 영상에서 재시작 되는 부분이 건너뛰어지는 문제가 발생한다.\n# 원인 및 문제 해결을 위한 시도\n처음에는 녹화의 대상(MediaRecorder)이 변경 될 때 딜레이가 생기게 원인이라고 생각했다. 그래서 useEffect의 조건을 수정하고 재연결 시 setTimeout을 통해 약간의 지연 시간을 주었지만 해결되지 않았다.\n그 후 재연결 이전의 녹화 영상과 재연결 이후의 녹화 영상을 확인했고, 각각은 이상이 없는 것을 확인해 Blob을 합치는 것이 원인이라고 판단했다. MediaRecorder에서 생성되는 Blob은 헤더 청크에 각각의 정보를 포함하고 있고, 단순히 Blob을 연결하는 것만으로는 하나의 영상으로 합쳐지지 않는 것이었다. Blob에 대한 공부가 부족해서 알지 못했었다.\n각기 다른 영상을 합쳐줘야 해서 ffmpeg.wasm를 이용하기로 했고 공식 문서를 보면서 임시로 코드를 작성했다. (공식 문서는 ffmpeg.FS(\u0026quot;writeFile\u0026quot;, \u0026quot;concat_list.txt\u0026quot;, textUnit8Array);에 textUnit8Array 대신 문자열이 직접 들어 있었으나 Argument of type 'string' is not assignable to parameter of type 'Uint8Array'. 에러가 발생해 임의로 변경)\nimport { createFFmpeg, fetchFile } from \u0026#34;@ffmpeg/ffmpeg\u0026#34;; import { Blob } from \u0026#34;buffer\u0026#34;; export const mergeVideo = async (results: Blob[][]) =\u0026gt; { const ffmpeg = createFFmpeg({ log: true, }); await ffmpeg.load(); let text = \u0026#34;\u0026#34;; results.forEach(async (blobs, idx) =\u0026gt; { const blob = new Blob(blobs, { type: \u0026#34;video/webm\u0026#34;, }); ffmpeg.FS(\u0026#34;writeFile\u0026#34;, `recording${idx}.webm`, await fetchFile(blob)); text += text.length === 0 ? `file recording${idx}.webm` : `\\nfile recording${idx}.webm`; }); const textUnit8Array = new TextEncoder().encode(\u0026#34;¢\u0026#34;); ffmpeg.FS(\u0026#34;writeFile\u0026#34;, \u0026#34;concat_list.txt\u0026#34;, textUnit8Array); await ffmpeg.run( \u0026#34;-f\u0026#34;, \u0026#34;concat\u0026#34;, \u0026#34;-safe\u0026#34;, \u0026#34;0\u0026#34;, \u0026#34;-i\u0026#34;, \u0026#34;concat_list.txt\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;copy\u0026#34;, `output.webm` ); const result = ffmpeg.FS(\u0026#34;readFile\u0026#34;, \u0026#34;output.webm\u0026#34;); console.log(); }; 하지만 해당 부분을 확인하기 이전에 Blob에 관한 에러가 발생했다.\nArgument of type \u0026#39;Blob\u0026#39; is not assignable to parameter of type \u0026#39;string | Buffer | Blob | File\u0026#39;. Type \u0026#39;Blob\u0026#39; is missing the following properties from type \u0026#39;File\u0026#39;: lastModified, name, webkitRelativePath 해당 문제는 stackoverflow의 답변을 확인했을 때 import { Blob } from \u0026quot;buffer\u0026quot;;을 제거해주면 된다고 하는데 제거할 경우 ReferenceError: Blob is not defined 에러가 발생한다.\n# 보류 결정\nBlob 에러의 해결 방법을 찾지 못했고 해결이 되더라도 위 코드가 정상적으로 작동한다는 확신도 없다. \u0026ldquo;Blob을 영상 파일로 각각 먼저 만들고 합칠까?\u0026rdquo; 하는 등의 몇 가지 아이디어도 있지만 프로젝트의 완성이 우선이고, 해당 문제의 해결을 시도하는데 이미 많은 시간이 지체돼서 해결을 보류하고 프로젝트 완성 후 Blob과 ffmpeg에 대한 추가 학습을 하고 해결을 시도하기로 결정했다. 하지만 해결된다고 해서 해당 기능을 포함할지는 현재는 미지수다. 결국 서버의 부담이 늘어나게 될 것이기 때문이다.\nReflections #이번 개선 프로젝트에서 개인적으로 가장 신경 썼던 부분이 재연결이었다. 이전 프로젝트에서 해당 문제를 해결하지 못해 뒤로 가기를 못하게 막는 등의 방식으로 문제를 회피했었기 때문이다.\n재연결 시 발생하는 문제는 원인을 잘 파악하고 해결했지만 영상 녹화 기능이 추가되자 많은 문제들이 추가로 발생했고 결국 해결하지 못했다. 이 과정에서 크게 두 가지를 배웠다.\n우선 문제가 발생했을 때 원인을 정확하게 파악해야 한다는 것이다. 당연한 소리지만 생각보다 어려웠다. 특히 원인을 모를 때 보다 원인을 잘못 파악했을 때 손해가 컸다. 여러번 원인을 잘못 파악해서 잘못된 해결 시도로 많은 낭비가 있었다.\n두 번째는 우선 순위와 보류 여부를 잘 판단해야 한다는 것이다. 이번에는 프로젝트에 기한을 정해두지 않아 작업 과정에서 우선 순위를 크게 신경쓰지 않았다. 그래서 문제가 해결되지 않을 때 빠르게 보류 여부를 판단하지 못했고 프로젝트의 완성이 지연됬다.\n물론 끊임없이 시도한 끝에 정확한 원인은 파악했지만 다른 우선순위 기능들을 완성하지 못한 시점에서는 적합하지 않은 행동이었다. (결국 해결도 못했고 😢😢😢, 매우 반성합니다. 🙏🙏🙏)\n끈질김은 좋지만 정확한 원인 파악 후 해결에 걸리는 시간과 난이도를 잘 판단하고, 우선순위가 높은 다른 문제를 먼저 해결한 뒤 발휘하겠다. 🔥🔥🔥\nEtc #isPros 변경 #기존에는 isPros(임시 변수)를 버튼을 통해 변경할 수 있는 변수로 관리했으나, 실사용 시와 좀 더 유사하게 사용할 수 있도록 쿼리를 통해 변경되지 않는 props로 관리하게 변경했다.\n코드 정돈 #컴포넌트 props의 타입은 Pick으로 뽑아서 사용하고 있었지만 함수는 각 인자와 타입을 따로 적어서 사용하고 있었다. Pick으로 뽑아서 사용할 인자를 중괄호로 묶어서 객체 형태로 만들어 주면 된다는 간단한 사실을 늦게 떠올렸다.\n// Example export const screenShare = async ({ peerRef, stream, videoRef, screenStreamRef, setIsScreenOn, }: Pick\u0026lt; IDebateroom, \u0026#34;peerRef\u0026#34; | \u0026#34;stream\u0026#34; | \u0026#34;videoRef\u0026#34; | \u0026#34;screenStreamRef\u0026#34; | \u0026#34;setIsScreenOn\u0026#34; \u0026gt;) =\u0026gt; { ... } Ps. 필요 없는 코드들이 여전히 발견된다. 코드 한 줄 한 줄을 보면서 \u0026ldquo;이 코드가 왜 필요한지? 또 이게 최선인지?\u0026ldquo;를 생각해 보는 시간을 통해서 이를 줄여나가고 있다.\n","date":"6 July 2022","permalink":"/posts/projects/debate-ducks/10/","section":"Posts","summary":"귀국, 입원 및 수술 등의 이유로 한 달 넘게 중지됐던 개발 재개 Summary #재연결 시 녹화 영상 유지 기능 구현 시도.","title":"[Debate-Ducks] Debateroom - 개발 재개 및 보류"},{"content":"Summary #토론 녹화 및 임시 다운로드 기능 추가.\n다음과 같은 이유로 폐기 * 참조 Details #토론 시 매 순간 서버로 blob을 보내서 저장해 재연결 시에도 녹화가 유지되게 했다. (안정성과 효율성 중 안정성을 선택)\n연결이 끊어진 경우 해당 유저의 연결을 끊은 횟수를 세서 일정 수 이상이 되면 해당 유저의 패배로 토론이 끝나게 만들었다. 또한 타이머 함수를 이용해 일정 시간 이내에 재연결을 하지 않을 경우 접속하지 않은 유저의 패배로 토론이 끝나게 만들었다.\n그리고 토론 종료 시 서버의 blobs를 클라이언트로 전달한 다음 하나로 합치고 해당 영상을 다운로드할 수 있게 만들었다. (임시 확인용)\nProblems #변수가 할당되기 전에 사용됨 #조건부로 변수에 값을 할당하고 해당 변수를 다음 변수에 활용했다. 이때 변수가 할당되기 전에 사용된다는 에러가 떴다. 해당 변수의 타입에 undefined를 포함하면 해결되는 간단한 문제였다.\nVariable \u0026#39;mergedStream\u0026#39; is used before being assigned. 최초 연결 시 마이크 꺼짐 #마이크는 켜진 상태로 연결되게 했었는데 최초 연결 시 꺼져있었다. 이유는 간단했다. 단계 전환 시 자신의 차례일 때는 마이크를 켜고 아닐 때는 꺼지게 해뒀는데 최초의 단계는 찬반 양측 모두에게 자신의 턴이 아니라 마이크가 꺼진 것이었다. 그래서 최초의 차례일 때를 조건에 추가해 해결했다.\n// Good!! useEffect(() =\u0026gt; { if (turn === \u0026#34;none\u0026#34;) { } else if (isPros) { if (turn === \u0026#34;pros\u0026#34; || turn === \u0026#34;prosCross\u0026#34;) { toggleMic(stream, true, setIsMicOn); } else { toggleMic(stream, false, setIsMicOn); } } else { if (turn === \u0026#34;cons\u0026#34; || turn === \u0026#34;consCross\u0026#34;) { toggleMic(stream, true, setIsMicOn); } else { toggleMic(stream, false, setIsMicOn); } } offScreen(peerRef, stream, videoRef, screenStreamRef, setIsScreenOn); }, [stream, turn, isPros]); 재연결 시 비디오 및 화면 공유 오작동 #우선 재연결 시 상대방 비디오의 현재 상태와 상관없이 useRef(false)로 인해 꺼져있는 상태로 인식하는 문제가 있었다. 이 문제는 비디오의 상태를 보내는 useEffect의 dependency에 peerStream을 추가하는 것으로 쉽게 해결했다.\n화면 공유의 경우는 재연결 시 상대방 화면 공유가 켜져 있어도 인식하지 못하는 문제와 이 상태에서 화면 공유를 끌 경우 Error: Cannot replace track that was never added. 에러가 발생하는 문제가 있었다.\n그래서 상대방 재연결 시 화면 공유를 꺼주는 방식으로 해결해야겠다고 생각했다. 처음에는 offScreen 함수를 peerStream이 변경될 때 적용하는 방식을 사용했지만 화면 종료 시 발생하는 에러가 여전히 발생했다.\n// Bad1!! useEffect(() =\u0026gt; { offScreen(peerRef, stream, videoRef, screenStreamRef, setIsScreenOn); }, [stream, peerStream]); 이번에는 자신의 화면을 끄는 부분만 peerStream이 변경될 때 적용했다. 그러자 상대방의 마지막 공유 화면이 상대방의 비디오를 대체하는 문제와 자신의 비디오를 표시하지 못하는 문제가 동시에 발생했다.\n// Bad2!! useEffect(() =\u0026gt; { if (stream \u0026amp;\u0026amp; screenStreamRef.current \u0026amp;\u0026amp; videoRef.current) { screenStreamRef.current.getTracks()[0].stop(); videoRef.current.srcObject = stream; setIsScreenOn(false); screenStreamRef.current = undefined; } }, [stream, peerStream]); 이유는 화면 공유 시 .onended에 peerRef.current?.replaceTrack()이 등록되는 것이었다. 처음 화면 공유를 켤때는 상대방이 없어서 replaceTrack이 작동하지 않지만 .onended의 replaceTrack이 작동하는 시점에는 상대방이 있어서 문제가 생겼다.\n그래서 화면 공유 함수 자체에서 상대방이 있을 때와 없을 때로 조건을 나누어 문제를 해결했다.\n// Good!! export const screenShare = async ( ... ) =\u0026gt; { try { const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false, }); // * Peer가 있을 때 if (peerRef.current) { ... // * Peer가 없을 때 } else { ... } } catch (err) { console.log(err); } }; Reason for feature deletion #서버에 Blobs 저장 #재연결 시 녹화의 안정적인 유지를 위해 서버에 Blobs를 저장했는데 최종적으로 AWS의 S3에 저장되기 때문에 서버를 거치는 것이 비효율적인 방법이라고 생각해 수정할 예정이다. (클라이언트에서 바로 처리하면서도 안정성을 높일 방법 고안 필요)\n녹화 영상 깨짐 현상 #토론이 중단된 후 재시작 됐을 때 재시작 이후의 녹화 영상이 깨지는 현상이 발생한다.\n재연결 과정에서 녹화의 대상이 변경되기 때문에 발생하는 문제라 추측되나 아직은 잘 모르겠다. *해결법\nEtc #useState와 useRef #저장해둔 값이 변경될 때 useState는 재랜더링을 일으키고 useRef는 재랜더링을 일으키지 않는다. 나는 이 프로젝트를 진행할 때 기본적으로는 재랜더링을 일으키지 않는 useRef를 사용했고 재랜더링이 필요할 경우 useState를 사용했다.\n작성된 코드에는 이유가 필요하다 #좋은 코드를 작성하기 위한 하나의 노력으로 코드를 한 줄 한 줄 복기하면서 \u0026ldquo;왜 이 코드가 필요한가?\u0026ldquo;를 스스로 생각해 보는 시간을 가졌다. 그러자 중간에 기능을 수정하면서 필요 없어진 부분들이 하나 둘 발견됐다. 또한 쓸데없이 복잡하게 작성된 부분들도 있었다. 이를 수정하면서 코드에 대한 이해가 한층 깊어짐을 느꼈다. 앞으로도 주기적으로 내가 작성한 코드를 복기하는 데 시간을 투자할 것이다.\n","date":"1 June 2022","permalink":"/posts/projects/debate-ducks/9/","section":"Posts","summary":"Summary #토론 녹화 및 임시 다운로드 기능 추가.","title":"[Debate-Ducks] Debateroom - Record"},{"content":"Summary #토론 시작, 일시 중단, 단계별 안내 및 권한 설정.\nDetails #토론 시작 및 유지 #준비 버튼을 누르면 해당 정보가 서버의 roomDebates 객체에 저장되고, 찬반 양측이 모두 준비 상태가 되면 토론이 시작된다. (isProsReady와 isConsReady로 구분) 토론 중에는 단계와 남은 시간이 상단에 표시되며 찬성 측 차례인지 반대 측 차례인지에 따라 색으로 구분된다.\n이전에는 한쪽의 연결이 끊기면 토론을 종료 시켰으나 이번에는 토론이 한번 시작되면 재연결을 해도 토론이 계속 진행되게 하고 싶었고, 토론이 시작되는 시점에 서버에 토론의 시작 여부를 저장해서 재연결을 해도 토론이 계속 진행될 수 있게 했다.\n처음에는 한쪽이 나갈 경우 토론을 중지 시키는 방식을 생각했으나, 토론이 불리하게 진행되었다고 나가버리는 경우를 고려해 한쪽이 남아있을 경우 토론이 계속 유지되게 했다.\n일시 중단은 실수로 새로 고침이나 뒤로 가기를 누르는 등의 상황에서 최소한의 방어책으로 작동하는 기능이다. 그래서 \u0026ldquo;토론은 네트워크가 안정된 환경에서 진행해 주시고, 네트워크 문제로 인해 생기는 불이익은 사용자가 책임져야 한다\u0026quot;고 사전 공지할 것이다.\nPs. 상대측이 나갔을 경우 토론이 끝날 때까지 혼자 진행을 하게 할지, 일정 시간 이내에 상대측이 재접속 하지 않으면 토론을 종료 시킬지 고민이 필요하다.\n토론의 유지기능은 녹화 영상의 문제로 보류. *참조 토론 진행 방식 #처음에는 양측에 발언시간을 주고 Push \u0026amp; Talk 방식으로 발언시간을 소모하여 발언하는 방식을 생각했다. 주로 대선 후보 토론에서 사용하는 방식이다. 사회자에게 질문을 받으면 주어진 발언시간 이내에 답변을 해야하며 다른 후보에게 질문도 할 수 있다. 그렇기에 사회자가 없는 1 대 1 온라인 토론 배틀에는 적합하지 않은 방식이다.\n다음은 토론의 단계와 단계별 시간을 토론 생성 시 설정할 수 있게 하려고 했다. 하지만 대부분의 단체나 대회는 각자 정형화된 토론 방식이 존재했고 해당 방식으로만 토론을 진행하고 있었다. 또한 정형화된 방식이 있는 편이 토론자 입장에서 토론을 준비하고 진행할 때, 그리고 시청자 입장에서 토론 결과를 판단할 때 더 도움이 된다고 판단하였다. (추후 자유토론이나 몇 가지 정형화된 방식을 추가할 수도 있음)\nDebate Ducks에서 사용할 정형화된 토론 방식은 CEDA(Cross Examination Debate Association) 토론 방식을 참고하여, 처음 발언하는 사람이 인상에 남는 초두 효과와 마지막에 발언하는 사람이 인상에 남는 최신 효과를 고려하여 다음과 같이 구성했다.\n토론 단계 시간 1. 찬성 측 입론 4분 2. 반대 측 교차 조사 3분 3. 반대 측 입론 4분 4. 찬성 측 교차 조사 3분 5. 찬성 측 반론 및 요약 3분 6. 반대 측 반론 및 요약 3분 입론 단계에서는 논제에 대해 자신의 주장 및 근거를 말한다. 새로운 주장을 펼치는 것은 오직 입론 단계에서만 가능하다.\n교차 조사 단계에서는 상대측이 입론 단계에서 주장한 내용의 논리적 허점을 지적하고, 지적을 받은 상대는 이에 대해 답변을 해야한다. 답변이 길어지는 경우 질문자는 중단 후 다음 질문을 계속할 수 있다.\n반론 및 요약 단계에서는 상대측의 주장에 대한 반론을 펼치고, 자신의 입론을 보강 및 정리한다. 그리고 자신이 토론에서 승리한 이유를 설명한다. 필요할 경우 상대측이 제기한 문제에 대해 추가적인 답변도 가능하다.\n토론 진행 #토론의 진행 단계를 미리 배열에 넣어둔 다음 타이머를 1씩 줄이고, 타이머가 0이 되었을 때 인덱스를 1 늘리는 방식으로 토론의 진행을 구현했다.\nexport const DEBATE_DEFAULT: TDebate = [ [\u0026#34;잠시 후 토론이 시작됩니다.\u0026#34;, 3], [\u0026#34;찬성 측 입론\u0026#34;, 240], [\u0026#34;반대 측 교차 조사\u0026#34;, 180], [\u0026#34;반대 측 입론\u0026#34;, 240], [\u0026#34;찬성 측 교차 조사\u0026#34;, 180], [\u0026#34;찬성 측 반론 및 요약\u0026#34;, 180], [\u0026#34;반대 측 반론 및 요약\u0026#34;, 180], [\u0026#34;토론이 종료되었습니다.\u0026#34;, 3], ]; export const debate = ( socket: Socket, debateId: string, roomDebates: IRoomDebates ) =\u0026gt; { const data = { notice: DEBATE_DEFAULT[roomDebates[debateId].turn][0], turn: roomDebates[debateId].turn, timer: roomDebates[debateId].timer, }; socket.emit(\u0026#34;debateProgress\u0026#34;, data); socket.to(debateId).emit(\u0026#34;debateProgress\u0026#34;, data); roomDebates[debateId].timer -= 1; if (roomDebates[debateId].timer \u0026lt; 1) { roomDebates[debateId].turn += 1; roomDebates[debateId].timer = DEBATE_DEFAULT[roomDebates[debateId].turn][1]; } }; 이전에는 각 토론 단계마다 socket 이벤트를 작성했었다. 서버 측에 14개, 클라이언트 측에 14개 총 28개의 이벤트 작성했었고, 유지 보수성을 전혀 고려하지 못했었다. 지금은 하나의 이벤트만 작성하면 되고, 변경 사항이 있을 시 배열의 값만 수정해서 간단히 변경 가능하다.\n// 이전 서버 측 코드 socket.on(\u0026#34;debate_start\u0026#34;, (data) =\u0026gt; { socket.to(data.debateId).emit(\u0026#34;debate_start\u0026#34;); }); socket.on(\u0026#34;debate_opening_pro\u0026#34;, (data) =\u0026gt; { startTimer(data, 60, \u0026#34;debate_opening_pro\u0026#34;, \u0026#34;debate_opening_con_pre\u0026#34;); }); socket.on(\u0026#34;debate_opening_con\u0026#34;, (data) =\u0026gt; { startTimer(data, 60, \u0026#34;debate_opening_con\u0026#34;, \u0026#34;debate_contention1_pro_pre\u0026#34;); }); ... socket.on(\u0026#34;debate_closing_pro\u0026#34;, (data) =\u0026gt; { startTimer(data, 60, \u0026#34;debate_closing_pro\u0026#34;, \u0026#34;debate_closing_con_pre\u0026#34;); }); socket.on(\u0026#34;debate_closing_con\u0026#34;, (data) =\u0026gt; { startTimer(data, 60, \u0026#34;debate_closing_con\u0026#34;, \u0026#34;debate_finish_pre\u0026#34;); }); socket.on(\u0026#34;debate_finish\u0026#34;, (data) =\u0026gt; { socket.to(data.debateId).emit(\u0026#34;debate_finish\u0026#34;); }); 토론 재시작 기능은 다음과 같이 구현했다. 토론 시작 시 roomDebates 객체에 setInterval로 토론 함수를 실행시키며 저장하고, 찬반 양측이 모두 방에서 나간 경우 clearInterval로 토론 함수를 중단 시킨다. 그 후 한 명이 재입장 할 경우 다시 같은 방식으로 토론 함수를 실행한다.\nroomDebates[data.debateId].debate = setInterval( debate, 1000, socket, data.debateId, roomDebates ); roomDebates[roomId].isPause = true; clearInterval(roomDebates[roomId].debate); 차례에 맞는 마이크 및 화면 공유 #기존에는 각자의 차례에만 공유 화면을 전체 화면으로 보여줬다. 하지만 교차 조사 같은 경우 답변자도 공유 화면을 전체 화면으로 보여줘야 하는 상황이 생길 수 있었다. 그래서 상대방이 화면 공유를 사용할 경우 자신의 화면 공유가 중단되게 만들었다.\n또한 입론과 반론 및 요약 단계에서의 발언권 보장을 위해 해당 단계에서 상대측의 마이크를 끄고, 마이크 버튼 및 화면 공유 버튼을 비활성화 시켰다. 그리고 각 단계가 전환될 때 화면 공유를 끄고, 차례에 맞게 마이크를 전환시켰다.\n처음에는 교차 조사 단계에서 질문자가 마이크를 껐을 경우에만 답변자의 마이크를 켜서 답변이 가능하게 했다. 하지만 질문자가 \u0026ldquo;답변 감사드립니다. 이제 다음 질문으로 넘어가겠습니다.\u0026ldquo;라고 양해를 구하고 답변을 종료 시키는 것이 마이크를 뚝 하고 끊어버리는 것보다 훨씬 낫다고 판단하여 마이크는 자유롭게 끄고 켜는 것이 가능하게 했다.\n남은 시간 생략 #발언이 일찍 끝난 경우 억지로 남은 시간 동안 더 발언하지 않고 넘어갈 수 있게 남은 시간 생략 기능을 만들었다.\n@SubscribeMessage(\u0026#34;skip\u0026#34;) handleSkip(@MessageBody() data: { debateId: string; isPros: boolean }) { if ( roomDebates[data.debateId].timer \u0026gt; 1 \u0026amp;\u0026amp; ((data.isPros \u0026amp;\u0026amp; (roomDebates[data.debateId].turn === 1 || roomDebates[data.debateId].turn === 4 || roomDebates[data.debateId].turn === 5)) || (!data.isPros \u0026amp;\u0026amp; (roomDebates[data.debateId].turn === 2 || roomDebates[data.debateId].turn === 3 || roomDebates[data.debateId].turn === 6))) ) { roomDebates[data.debateId].timer = 1; } } Ps. 남은 시간이 10초 일 때와 3초 일 때 경고음이 울리게 만들었다. 10초는 발언을 마무리하라는 신호이고, 3초는 차례가 곧 종료된다는 신호이다.\nProblems #토론 일시 중단 시 clearInterval 문제 #토론은 setInterval을 활용해 1초마다 토론 함수를 실행하는 것으로 진행된다. 일시 중단의 경우 찬반 양측이 모두 방에서 나간 경우 roomDebates.isPause를 true로 변경해 실행했다.\n하지만 이전에 WebRTC 재연결 시 발생하는 에러를 해결하기 위해 한 측의 연결이 끊기면 다른 측의 연결도 파괴한 뒤 재연결 되도록 했다. 그래서 한 측의 연결만 끊겨도 일시 중단이 반듯이 잠시라도 실행된다.\n즉, 한 측의 연결만 끊겼을 경우 isPause = true로 변경된 뒤 join 이벤트가 발생하면서 setInterval이 추가로 발생하고, isPause = false로 변경된다. 이 때문에 isPause = true 일 때만 발생하는 setInterval 내부의 clearInterval가 실행되지 않았다.\n이유를 간단히 설명하자면 JS에서 타이머 함수가 실행되면, 내부 함수는 백그라운드에서 딜레이만큼 기다린 후 Callback Queue로 이동한다. 그 후 Call Stack이 빈 경우에 Callback Queue에 있는 타이머 함수의 내부 함수가 실행된다.\n이 경우에는 타이머 함수의 내부 함수인 토론 함수가 실행되기 전 isPause = false로 변경되기 때문에 clearInterval가 실행되지 않는 것이다.\n// Bad!! export const debateProgress = ( socket: Socket, debateId: string, roomDebates: IRoomDebates, ) =\u0026gt; { const interval = setInterval(() =\u0026gt; { if (roomDebates[debateId].isPause) { clearInterval(interval); } else { ... } }, 1000); }; 결국 이 문제를 해결하기 위해서는 clearInterval을 setInterval 외부에서 실행해 줘야 한다. 그래서 우선 토론 함수를 따로 정의한 다음 setInterval로 타이머 함수를 생성한 다음 roomDebates.debate에 저장했다.\n이제 찬반 양측이 모두 방에서 나간 경우 roomDebates.isPause를 true로 변경하며 clearInterval을 실행하여 토론을 일시 중단 시켰고 문제가 말끔히 해결 되었다.\n// Good!! roomDebates[roomId].isPause = true; clearInterval(roomDebates[roomId].debate); 준비 후 토론 시작 시 발생하는 문제 #토론 준비 후 시작 시 서로의 미디어를 연결하지 못하는 문제가 있었다.\n이유는 아주 간단했다. isStart 변수가 wsConnect를 실행시키는 useEffect의 dependency에 포함되어 있어서였다. 이를 제거하자 문제가 말끔히 해결됬다. 대신 isStart로 토론의 주제를 보여줄지 \u0026ldquo;곧 토론이 재시작합니다.\u0026ldquo;를 보여줄지 결정하는 기능은 빠졌다.\n","date":"27 May 2022","permalink":"/posts/projects/debate-ducks/8/","section":"Posts","summary":"Summary #토론 시작, 일시 중단, 단계별 안내 및 권한 설정.","title":"[Debate-Ducks] Debateroom - Debate"},{"content":"Summary #WebRTC 재연결 시 발생하는 여러 문제들 해결.\nProblems #WebRTC 재연결 문제 #WebRTC가 이미 연결되어 있는 상태에서 한쪽이 재접속을 시도할 때 cannot signal 에러가 발생했다. 이전 프로젝트 때도 발생했던 에러인데 그때는 문제가 발생하는 이유조차 제대로 이해할 수 없고 시간도 부족했다. 그래서 뒤로 가기를 막고, 한쪽 연결이 끊겼을 때 다른 쪽의 연결도 끊고 종료 시켜버리는 방식으로 문제를 회피했었다. 보통의 영상 통화라면 위의 방식으로도 충분했겠지만 토론을 진행하며 녹화까지 하는 프로젝트의 특징상 안정성을 위해서 해결되어야 할 문제였다.\nError cannot signal after peer is destroyed 소켓과 리액트의 구조에 대해서 어느 정도 이해하고 있는 지금은 소켓의 이벤트에 연결이 끊어진 쪽의 peer가 남아있어서 생기는 문제라는 것을 금방 파악했다.\n우선 한쪽의 연결이 끊어졌을 때 다른 쪽에 이벤트를 발동시키기 위해 handleDisconnect를 사용했다. 이때 이전의 코드를 살펴보니 이 부분이 엄청나게 잘못되어 있었다. 한쪽이 나갔을 때 모든 방에 peerDisconnect 이벤트를 발동 시키게 되어 있었다. 테스트를 할 때 동시에 하나 이상의 토론을 진행한 적이 없어서 발견하지 못했던 문제였다.\n처음에는 this.server.sockets.adapter.rooms에 forEach를 사용해 정보를 찾으려고 했다. 하지만 handleDisconnect는 연결이 끊어진 후 발동하는 이벤트라 해당 socket.id는 WebSocket 서버에 남아있지 않았고 정보를 찾기는 어려웠다.\n그래서 join 이벤트가 발동할 때 해당 socket.id에 방의 정보를 담아서 서버 측에 저장해 두고 handleDisconnect에서 정보를 할당한 다음 삭제하는 방식으로 변경하였다.\n그 후 peerDisconnect 이벤트에서 peer.destroy()로 peer를 삭제한 뒤 setPeer(undefined)로 peer를 초기화 시키는 방식으로 접근하였으나 새로운 에러가 발생했다.\nDOMException: Failed to execute \u0026#39;setRemoteDescription\u0026#39; on \u0026#39;RTCPeerConnection\u0026#39;: Failed to set remote answer sdp: Called in wrong state: stable 이번에는 소켓의 연결이 그대로 남아있는 게 문제의 원인이어서 peerDisconnect 이벤트에서 socket.current.disconnect()로 소켓의 연결을 끊은 다음 새로운 소켓을 연결한 뒤 join 이벤트를 발동시켰다. 그러자 또 새로운 에러가 발생했다.\nError: Connection failed. at Peer._onConnectionStateChange at RTCPeerConnection.Peer._pc.onconnectionstatechange 새로 생성된 소켓에 peer를 연결하는 이벤트가 작성되어 있지 않기 때문이었다. 그래서 peerDisconnect 이벤트에서 setReConnect(!reConnect)로 reConnect의 값이 변하게 하고, useEffect의 dependency에 reConnect를 추가하는 방식으로 재연결이 가능하게 만들었다.\nPs. 빈 배열 dependency를 가지는 useEffect를 따로 사용해 첫 연결 시에는 비디오 화면이 꺼진 상태로 연결되고, 상대방이 재연결을 시도했을 때는 현제의 비디오 상태가 유지된다.\n화면 공유 중 재연결 문제 #화면 공유 상태에서 다른쪽이 재연결을 시도하면 에러가 발생했다. 공유 화면의 종료 함수에 이미 종료된 peer가 남아있어서 발생하는 문제였다. 그래서 공유 화면의 스트림을 useRef에 저장하여 peerDisconnect 이벤트에서 screenStreamRef.current.getTracks()[0].stop()으로 종료 시켜 해결했다.\nPs. peerDisconnect 이벤트에서 저장해둔 peer의 정보들도 함께 초기화 시켜줬다.\nEtc #작업 방식 제안 #*Suggestion Issue\n다른 팀원들의 개인 사정으로 인해 현재 나만 개발을 진행하고 있다. 그러던 중 백엔드를 담당하는 팀원이 곧 개발을 시작할 수 있는데, 기본적인 로그인 기능부터 우선으로 작업할 거 같다며 로그인 기능을 먼저 같이 개발하자고 제안했다. 이전 프로젝트에서 주로 이런 식으로 서버 측과 클라이언트 측이 동시간대에 같은 기능을 작업했는데 개인적으로 몇 가지 불편함을 느꼈었다.\n우선 개발하면서 생기는 변경 사항으로 인한 끊임없는 수정이다. 의사소통에 신경 쓰면서 개발을 해도 실시간으로 바뀌는 수정 사항으로 인해 \u0026ldquo;이렇게 하기로 한거 아니었냐? 나는 이미 이렇게 했다.\u0026rdquo; 하는 문제로 시간을 꽤나 소모했다.\n또한 같은 기능을 동시간대에 작업하다 보니 각자 테스트 코드를 따로 만들어서 작업해야 하는 불편함도 있었다.\n마지막으로 상대방과 실시간으로 대화하면서 개발하다 보니 코드를 읽는 능력을 기르는 연습이 되지 않았다.\n그래서 나는 서버와 클라이언트가 같은 기능을 동시간대에 개발하기보다는 한쪽이 기본적인 기능을 개발한 뒤 명확한 명세가 나오면, 다른 쪽이 해당 코드를 보고 바로바로 테스트하면서 개발하는 방식을 제안했다. 그 과정에서 이미 개발된 코드의 수정이 필요하다면 hotfix로 수정하면서 개발하면 된다.\n특히 이번에 TypeScript를 사용하는데, 주석이나 별다른 설명 없이도 코드의 구조를 명확하게 파악할 수 있는 TypeScript의 장점을 잘 활용할 수 있는 방식이라고 생각했다.\n사실 기획부터 기능 및 각종 명세들을 아주 세세하게 짜고 들어가면 크게 상관없는 불편함이다. 하지만 현제 우리 프로젝트에서는 제안한 방식이 더 효율적일 것이라 생각해 제안했고, 팀원들도 적극적으로 동의했다.\n","date":"25 May 2022","permalink":"/posts/projects/debate-ducks/7/","section":"Posts","summary":"Summary #WebRTC 재연결 시 발생하는 여러 문제들 해결.","title":"[Debate-Ducks] Debateroom - Reconnect"},{"content":"npm i @reduxjs/toolkit react-redux next-redux-wrapper npm i -D @types/react-redux redux/store.ts #import { Action, configureStore, ThunkAction } from \u0026#34;@reduxjs/toolkit\u0026#34;; import example from \u0026#34;./modules/example\u0026#34;; const store = configureStore({ reducer: { example, }, }); export default store; export type AppDispatch = typeof store.dispatch; export type RootState = ReturnType\u0026lt;typeof store.getState\u0026gt;; export type AppThunk\u0026lt;ReturnType = void\u0026gt; = ThunkAction\u0026lt; ReturnType, RootState, unknown, Action\u0026lt;string\u0026gt; \u0026gt;; redux/modules/example.ts #import { RootState } from \u0026#34;../store\u0026#34;; import { createSlice } from \u0026#34;@reduxjs/toolkit\u0026#34;; export interface IExample { value: string; } const initialState: IExample = { value: \u0026#34;...\u0026#34;, }; const exampleSlice = createSlice({ name: \u0026#34;example\u0026#34;, initialState, reducers: { actionCreator: (state, action) =\u0026gt; { // action.payload는 actionCreator의 params // state 변경은 mutable, immutable 둘 다 가능 // state=value로 직접 변경은 안됨 }, }, }); export default exampleSlice.reducer; export const exampleSelector = (state: RootState) =\u0026gt; state.example.value; export const { actionCreator } = exampleSlice.actions; utils/useReduxToolkit.ts #import { TypedUseSelectorHook, useDispatch, useSelector } from \u0026#34;react-redux\u0026#34;; import type { AppDispatch, RootState } from \u0026#34;../redux/store\u0026#34;; export const useAppDispatch = () =\u0026gt; useDispatch\u0026lt;AppDispatch\u0026gt;(); export const useAppSelector: TypedUseSelectorHook\u0026lt;RootState\u0026gt; = useSelector; pages/_app.ts #import type { AppProps } from \u0026#34;next/app\u0026#34;; import { Provider } from \u0026#34;react-redux\u0026#34;; import store from \u0026#34;../redux/store\u0026#34;; function MyApp({ Component, pageProps }: AppProps) { return ( \u0026lt;Provider store={store}\u0026gt; \u0026lt;Component {...pageProps} /\u0026gt; \u0026lt;/Provider\u0026gt; ); } export default MyApp; Usage #import { useState } from \u0026#34;react\u0026#34;; import { useAppSelector, useAppDispatch } from \u0026#34;../utils/useReduxToolkit\u0026#34;; import { exampleSelector, actionCreator } from \u0026#34;../redux/modules/example\u0026#34;; export default function Example() { const dispatch = useAppDispatch(); const count = useAppSelector(exampleSelector); const event = () =\u0026gt; { dispatch(actionCreator(/*action.payload*/)) } return ... } Ref. Introduction to using Redux Toolkit in Next.js and TypeScript\n","date":"23 May 2022","permalink":"/posts/studies/react/redux/redux-toolkit-next.js-ts/","section":"Posts","summary":"npm i @reduxjs/toolkit react-redux next-redux-wrapper npm i -D @types/react-redux redux/store.","title":"[Redux] Redux-toolkit in Next.js and TypeScript"},{"content":"","date":null,"permalink":"/tags/redux/","section":"Tags","summary":"","title":"Redux"},{"content":"Summary #캔버스에 비디오 및 공유 화면를 포함한 여러 요소들을 그리고 녹화할 수 있게 만듦.\nDetails #캔버스 및 비디오 크기 #이전 프로젝트에서 동일한 동영상 퀄리티를 위해 캔버스에 고정 크기를 사용했다. 그래서 화면을 줄이거나 모바일에서 보게 되면 캔버스가 잘리는 문제가 있었다. 이번에는 이런 문제를 해결하고 싶었다. 그래서 스타일(임시로 인라인 스타일 사용)로 보여지는 캔버스의 크기를 바꾼 다음 녹화 테스트를 하자 보여지는 캔버스의 크기와는 상관 없이 캔버스의 고정 크기에 맞게 녹화되었다.\n(이전에는 Canvas 요소를 도입할 계획이 있던게 아니라 녹화를 위해 급하게 도입했다. 시간 부족 상태에서 녹화가 잘 진행되자 추가적인 개선 사항을 알아보지 않고 바로 다음 단계로 넘어갔다. 🙏🙏🙏)\n\u0026lt;canvas ref={canvasRef} width=\u0026#34;1280px\u0026#34; height=\u0026#34;720px\u0026#34; style={{ border: \u0026#34;2px solid red\u0026#34;, width: \u0026#34;100vw\u0026#34; }} \u0026gt;\u0026lt;/canvas\u0026gt; 이전 프로젝트에서 비디오는 캔버스 내부의 drawImage에서 크기를 조정해서 사용했다. 그래서 사용자 카메라의 종류에 따라 화면이 늘어나는 문제가 있었다. 하지만 다른 팀원들의 비디오를 연결해 봤을 때 크게 늘어나지 않았고, 시간도 부족하여 그냥 넘어 갔었다. 이번에는 사용자의 비디오를 획득할 때 애초에 고정된 크기에 맞게 받아서 늘어남 문제를 원천 차단하였다.\n.getUserMedia({ video: { facingMode: \u0026#34;user\u0026#34;, width: 500, height: 500 }, audio: { echoCancellation: true, noiseSuppression: true }, }) 이전 프로젝트에서는 화면 가운데 보이지 않는 비디오를 고정하는 방식으로 뷰 바깥의 요소를 캔버스가 그리지 못하는 문제를 해결했었는데 이번에는 sticky를 활용해 좀 더 간단히 해결하였다.\n\u0026lt;video ref={videoRef} muted autoPlay playsInline width={0} height={0} style={{ position: \u0026#34;sticky\u0026#34;, top: 0 }} \u0026gt;\u0026lt;/video\u0026gt; 카메라 연결 상태 #이전 프로젝트에서는 사용자의 카메라가 꺼지면 .enable=false 상태의 검은 화면만 보였다. 이번에는 소켓을 통해 카메라 on/off 여부와 화면공유 on/off 여부를 전달하고, 현재의 연결 상태 및 진행 상태를 고려하여 각각 다른 화면이 보이게 했다.\nuseEffect(() =\u0026gt; { if (peer) { socket?.emit(\u0026#34;peerVideo\u0026#34;, { debateId, isVideoOn }); socket?.emit(\u0026#34;peerScreen\u0026#34;, { debateId, isPeerScreenOn }); } }, [socket, peer, debateId, isVideoOn, isPeerScreenOn]); drawText( canvasRef, \u0026#34;#F8FBFD\u0026#34;, \u0026#34;bold 32px san-serif\u0026#34;, peer ? \u0026#34;Camera Off\u0026#34; : isPros ? \u0026#34;Camera Off\u0026#34; : \u0026#34;Not connected\u0026#34;, 300, 380 ); 캔버스에 그리기 #이전 프로젝트에서는 사용자의 비디오를 그리는 함수, 찬성 측 화면 공유 함수 그리고 반대 측 화면 공유로 함수로 나눠서 작성했었다. 처음에는 요소별로 그리는 함수를 만들어 조건을 걸었지만 한번 interval이 등록된 함수를 삭제하지 않으면 중첩으로 그려지는 문제가 발생하기 때문이었다.\n이번에는 interval을 중지하고 다시 시작하는 부분은 useEffect()의 dependency로 처리하고, 그리기 함수 내부에서 조건에 따라 다른 화면을 그리게 처리하여 가독성과 유지보수의 편리성을 늘렸다.\nuseEffect(() =\u0026gt; { drawStop(); drawStart(); }, [ drawStart, drawStop, peer, isVideoOn, isPeerVideoOn, isScreenOn, isPeerScreenOn, ]); 또한 캔버스에 그리는 과정도 종류(사각형, 텍스트, 비디오)별로 함수를 작성한 다음 파라미터를 이용해 원하는 것을 그릴 수 있게 만들어 가독성과 유지 보수의 편리성을 늘렸다.\nconst drawSquare = ( canvasRef: MutableRefObject\u0026lt;HTMLCanvasElement | null\u0026gt;, color: string, dx: number, dy: number, w: number, h: number ) =\u0026gt; { const ctx = canvasRef.current?.getContext(\u0026#34;2d\u0026#34;); if (ctx) { ctx.fillStyle = color; ctx.fillRect(dx, dy, w, h); } }; 공유 화면 그리기 #자신의 차례일 때만 공유 화면이 크게 그려지며, 그려지는 공유 화면은 공유 대상의 비율에 맞춰서 화면에 그려지게 만들었다.\n// prosTurn: \u0026#34;none\u0026#34; | \u0026#34;true\u0026#34; | \u0026#34;false\u0026#34; if (isScreenOn \u0026amp;\u0026amp; String(isPros) === prosTurn) {...} Props 타입 정리 #Props를 넘길 때마다 Props의 타입을 하나하나 작성해 줘야 해서 귀찮았다. Props의 타입을 interface로 미리 작성해두고 Pick으로 뽑아서 사용하니 편리하고 시간도 절약되었다.\nexport default function Buttons({ peer, streamRef, videoRef, isAudioOn, setIsAudioOn, isVideoOn, setIsVideoOn, setIsScreenOn, }: Pick\u0026lt; IDebateroomProps, | \u0026#34;peer\u0026#34; | \u0026#34;streamRef\u0026#34; | \u0026#34;videoRef\u0026#34; | \u0026#34;isAudioOn\u0026#34; | \u0026#34;setIsAudioOn\u0026#34; | \u0026#34;isVideoOn\u0026#34; | \u0026#34;setIsVideoOn\u0026#34; | \u0026#34;setIsScreenOn\u0026#34; \u0026gt;) {...} Ps. 색상도 따로 객체 형태로 만들어 유지 보수의 편리성을 높혔다.\nProblems #PR 커밋 중첩 문제 ## 문제\nPR이 쌓이게 되면 커밋과 변경된 파일이 중첩되는 문제가 있었다. 바로바로 리뷰 후 Merge를 하면 문제가 발생하지 않지만 현실적으로는 쉽지 않다. (bcs 주말, 새벽 PR 등) 또 중첩이 될 경우 앞의 PR은 반려하고 뒤의 PR만 Merge 하는 방법도 있지만, PR은 변경 사항을 쉽게 파악할 수 있어야 하기 때문에 너무 많아지거나 다양한 기능이 있는 건 지양해야 한다.\n# 해결\n앞의 PR을 Merge 한 뒤, 다음 PR을 Merge 하기 전에 Edit을 통해 브랜치를 재설정 해주면 PR이 중첩되지 않고 해당 PR의 변경 사항만 기록된다.\nuseRef 할당 불가능 문제 #캔버스에 사용자의 미디어와 공유 화면을 각각 그리기 위해 useInterval Hook 작성 중 Cannot assign to 'current' because it is a read-only property. 에러가 발생하였다. 이유는 초깃값으로 null을 지닐 때 제네릭에 null을 포함하지 않으면 변경할 수 없는 객체를 생성하기 때문이다.\nRef. (useRef) Cannot assign to \u0026lsquo;current\u0026rsquo; because it is read-only property\nReflections #아직 많이 부족하지만 중복 작성되는 요소들을 최대한 공통으로 묶어서 빼는 노력을 통해 코드의 가독성과 유지 보수의 편리성이 많이 늘어났다. 또한 만나는 이슈나 개발과정의 기록을 통해 코드를 이전보다 더 확실하게 이해하게 됬다. 특히 이전에는 내가 작성한 코드를 팀원에게 설명해 줄 때 많은 어려움을 겪었는데, 기록을 하면서 코드를 인간의 언어로 설명하는 과정을 연습할 수 있게 되었고 (이전에는 인간의 언어를 코드로 작성하는 부분만 집중적으로 함), 이제는 팀원들에게 내 코드를 설명하는데 큰 어려움이 없다.\n","date":"22 May 2022","permalink":"/posts/projects/debate-ducks/6/","section":"Posts","summary":"Summary #캔버스에 비디오 및 공유 화면를 포함한 여러 요소들을 그리고 녹화할 수 있게 만듦.","title":"[Debate-Ducks] Debateroom - Canvas"},{"content":"Summary #마이크 및 비디오 끄기/켜기 기능 및 화면 공유 기능 추가.\nProblems #useRef 전달 문제 #useRef로 streamRef에 사용자의 스트림을 저장해서 사용했다. 그리고 비디오 끄기/켜기 버튼을 하위 컴포넌트로 사용하면서 stream={streamRef.current}로 props를 넘겨줬다.\n끄기/켜기 기능은 stream이 있는 경우에만 작동하게 해뒀는데, 이미 사용자의 스트림을 받아서 비디오로 표시하고 있음에도 제대로 작동하지 않았다. 콘솔을 찍어보니 여전히 stream이 undefined였다. useRef의 변경은 재랜더링을 일으키지 않기 때문이었다.\n그래서 streamRef={streamRef}로 직접 넘겨준 뒤 하위 컴포넌트에서 stream.current로 사용하자 문제가 말끔히 해결됬다.\nPs. 다른 이유로 재랜더링이 일어날 경우 코드는 정상 작동한다. 그래서 이 기능을 독립적으로 확인해 보기 전까지는 정상적으로 작동한다는 착각을 하게 되었다. 안전성을 위해서 useRef를 하위 요소로 넘길 때는 ref.current가 아닌 ref 자체를 넘기는 것을 추천한다.\nIf 조건문 Type Error 2 #화면 공유 기능을 개발할 때 if (peerRef.current \u0026amp;\u0026amp; myStreamRef.current \u0026amp;\u0026amp; myVideoRef.current) {...}로 한번 falsy 일 가능성을 제거해 줬음에도 screenStream.getTracks()[0].onended 내부의 ... Ref.current가 falsy 일 가능성이 있다고 타입 에러가 떴다.\n// Bad!! navigator.mediaDevices.getDisplayMedia().then((screenStream) =\u0026gt; { if (peerRef.current \u0026amp;\u0026amp; myStreamRef.current \u0026amp;\u0026amp; myVideoRef.current) { peerRef.current.replaceTrack( myStreamRef.current.getVideoTracks()[0], screenStream.getVideoTracks()[0], myStreamRef.current ); myVideoRef.current.srcObject = screenStream; } screenStream.getTracks()[0].onended = () =\u0026gt; { peerRef.current.replaceTrack( screenStream.getVideoTracks()[0], myStreamRef.current.getVideoTracks()[0], myStreamRef.current ); myVideoRef.current.srcObject = myStreamRef.current; }; }); 같은 문제가 이전에 발생했었는데 한 번 더 같은 문제가 다른 형태로 발생하니 이유를 알 수 있었다. 이미 if 조건문으로 falsy 일 가능성을 없앴어도 .onended에 추가하는 함수는 독립적으로 작동하기 때문이다. 즉, .onended에 추가하는 함수 내부에서도 falsy 일 가능성을 다시 없애주어야 한다.\n// Better!! navigator.mediaDevices.getDisplayMedia().then((screenStream) =\u0026gt; { if (peerRef.current \u0026amp;\u0026amp; myStreamRef.current \u0026amp;\u0026amp; myVideoRef.current) { peerRef.current.replaceTrack( myStreamRef.current.getVideoTracks()[0], screenStream.getVideoTracks()[0], myStreamRef.current ); myVideoRef.current.srcObject = screenStream; } screenStream.getTracks()[0].onended = () =\u0026gt; { if (peerRef.current \u0026amp;\u0026amp; myStreamRef.current \u0026amp;\u0026amp; myVideoRef.current) { peerRef.current.replaceTrack( screenStream.getVideoTracks()[0], myStreamRef.current.getVideoTracks()[0], myStreamRef.current ); myVideoRef.current.srcObject = myStreamRef.current; } }; }); Ps. 위 코드의 경우 WebRTC 연결을 하지 않았을 때 화면 공유를 하지 못한다는 문제가 추가로 발생했고, 조건문 안의 peerRef.current를 빼서 해결했다.\n화면공유 시스템 거절 문제 #문제 2의 코드로 화면 공유를 실행 했을 때 Chrome 탭 공유는 정상적으로 실행 되지만 전체 화면과 창 공유는 정상적으로 실행되지 않았다.\nsystem denied 문제라서 우선은 크롬의 설정을 하나씩 살펴봤다. 하지만 모든 권한은 허가 또는 요청으로 되어 있었고, 인터넷 사용 기록을 삭제해 봐도 문제가 해결되지 않았다.\n다음으로는 코드를 살펴봤다. .getDisplayMedia에 옵션도 넣어보고 콘솔도 찍으면서 확인해 봤지만 여전히 해결의 기미가 보이지 않았다.\n마지막으로 내 컴퓨터의 문제는 아닐까 생각해서 관련 권한들을 살펴봤다. 화면 기록 권한에 크롬이 체크해제되어 있는 것을 보고 순간 이거다 싶었고 정답이었다. 아마 내가 예전에 권한을 거절한 적이 있었고 그래서 권한 요청 조자 오지 않고 시스템이 알아서 거절한 것이었다. 다른 사용자도 비슷한 경험을 할 수 있기 때문에 이 내용은 따로 안내될 것이다.\n","date":"21 May 2022","permalink":"/posts/projects/debate-ducks/5/","section":"Posts","summary":"Summary #마이크 및 비디오 끄기/켜기 기능 및 화면 공유 기능 추가.","title":"[Debate-Ducks] Debateroom - Stream"},{"content":"Summary #WebRTC(simple-peer)로 사용자를 1 대 1로 연결해 서로의 미디어를 빠르게 주고받을 수 있게 만듦.\nDetails #클라이언트 WebRTC 코드 #기존에 한 파일에 작성했던 코드를 외부 파일로 이동해 가독성을 높였다. 또한 useRef를 적극 활용해 불필요한 재랜더링을 방지했다.\nsocket.on(\u0026#34;guestJoin\u0026#34;, () =\u0026gt; { connectHostPeer( debateId, socket, peerRef.current, myStreamRef.current, peerStreamRef.current, peerVideoRef.current ); }); export const connectHostPeer = ( debateId: string | string[], socket: Socket, peer: Peer.Instance | undefined, myStream: MediaStream | undefined, peerStream: MediaStream | undefined, peerVideo: HTMLVideoElement | null ) =\u0026gt; { const simplePeer = new Peer({ initiator: true, trickle: false, config: { iceServers: [ { urls: \u0026#34;stun:stun.l.google.com:19302\u0026#34; }, { urls: \u0026#34;stun:stun1.l.google.com:19302\u0026#34; }, { urls: \u0026#34;stun:stun2.l.google.com:19302\u0026#34; }, { urls: \u0026#34;stun:stun3.l.google.com:19302\u0026#34; }, { urls: \u0026#34;stun:stun4.l.google.com:19302\u0026#34; }, { urls: \u0026#34;stun:stun.nextcloud.com:443\u0026#34; }, ], }, stream: myStream, }); peer = simplePeer; simplePeer.on(\u0026#34;signal\u0026#34;, (signal) =\u0026gt; { socket.emit(\u0026#34;offer\u0026#34;, { debateId, signal }); }); simplePeer.on(\u0026#34;stream\u0026#34;, (stream) =\u0026gt; { peerStream = stream; if (peerVideo) { peerVideo.srcObject = stream; } }); simplePeer.on(\u0026#34;error\u0026#34;, (err) =\u0026gt; { console.log(\u0026#34;error\u0026#34;, err); }); socket.on(\u0026#34;answer\u0026#34;, (signal: Peer.SignalData) =\u0026gt; { simplePeer.signal(signal); }); }; Problems #방 입장 시 발생하는 문제 2 # 이전에 작성한 코드에서 WebRTC를 적용하기 위해 추가로 코드를 작성했는데 제대로 작동하지 않았다.\n이 프로젝트에서 WebRTC의 연결 과정은 다음과 같다. 사용자가 웹 소켓 서버와 연결됨과 동시에 방에 입장을 요청하고, 인원이 다 차지 않았을 경우 방에 입장한다. 이때 먼저 방에 입장해있는 호스트에게 게스트가 입장했다고 알려주고, 호스트는 연결을 제안한다. 게스트는 제안을 받은 뒤 응답을 보내면 게스트와 호스트는 1 대 1로 연결이 된다.\n그러나 실제로 실행했을 때 \u0026ldquo;게스트가 제안을 받지 못하는 문제\u0026quot;가 발생했다. 우선 클라이언트에서 이벤트를 수신하지 못하는지 알아보기 위해 서버 측의 제안 코드를 이동해 봤다. 그러자 클라이언트 측에서는 정상적으로 제안을 받았다. 다음으로는 서버 측에 콘솔을 찍어보았는데, 서버 측에서도 정상적으로 제안을 받았다. 결국 서버 측에서 제안을 보내는 부분에 문제가 있다는 소리였다.\n그래서 서버 측 코드를 handleConnection 안으로 옮겨도 보고, handleOffer 코드도 여러번 수정했다. 이 과정에서 문제를 해결하지는 못했으나 문제의 원인은 파악했다. 게스트가 방에 추가로 입장해야 하는데 그러지 않고 이미 있던 호스트를 덮어쓰는 것이 원인이었다.\n그제서야 서버 측 코드가 아니라 클라이언트 측 코드가 문제라는 것을 깨닫고 클라이언트 측 코드를 유심히 살펴봤다. \u0026ldquo;join\u0026quot;을 \u0026ldquo;connect\u0026rdquo; 내부에서 emit한 것이 문제였다. 이 때문에 새로운 연결 후 방에 입장하게 되어 방을 덮어쓰는 것처럼 작동하는 것 같다. 하지만 아직 정확한 이유는 파악하지 못하였다. (이유를 알게 되면 추가로 작성할 예정)\n정확한 이유는 공문서에 나와 있었다. 이미 한번 사용해본 스택이라 공문서를 꼼꼼히 확인하지 않은 것을 반성한다. (이전에는 예제를 따라하면서 쉽게 넘어갔던 부분이라 따로 확인하지 않았음) 공식 문서에는 소켓이 재연결 될때 마다 새 핸들러가 등록되어서 핸들러 자체에 핸들러를 등록하면 안된다고 경고한다.\n*참조\n// Bad!! socket?.on(\u0026#34;connect\u0026#34;, () =\u0026gt; { socket.emit(\u0026#34;join\u0026#34;, debateId); console.log(\u0026#34;connect\u0026#34;, socket.id); }); 그래서 외부의 \u0026ldquo;connect\u0026quot;를 제거해 주니 정상적으로 제안을 주고받았다. 하지만 아직 연결이 여러 번 되는 문제가 남아 있었다.\n이 문제의 이유는 명확했다. useEffect의 dependency에 들어있는 debateId와 socket의 값이 변하기 때문에 재랜더링이 일어나 생기는 문제였다.\n처음에는 debateroom/[debateId].tsc 페이지에서 Room.tsx 컴포넌트를 연결할 때 조건을 debateId와 socket 모두 undefined가 아닐 때로 했다. 그래도 문제는 해결되지 않았고, useRef를 사용해서 debateId를 관리하였을 때도 마찬가지였다. 결국은 debateId를 useRouter로 받는 과정에서 재랜더링이 한 번 이상은 발생하기 때문이었다.\n그래서 이번에는 Room.tsc 컴포넌트의 useEffect 내부에서 if 문을 통해 소켓 이벤트 발동 및 추가의 조건을 debateId와 socket 모두 undefined가 아닐 때로 했다. 그러자 문제가 말끔히 해결 되었다.\nIf 조건문 Type Error 1 #addTrack 내부의 myStreamRef.current에 타입 에러가 발생했다.\nconst myStreamRef = useRef\u0026lt;MediaStream\u0026gt;(); ... if (myStreamRef.current) { myStreamRef.current.getTracks().forEach((track) =\u0026gt; { peerRef.current?.addTrack(track, myStreamRef.current); }); } Argument of type \u0026#39;MediaStream | undefined\u0026#39; is not assignable to parameter of type \u0026#39;MediaStream\u0026#39;. Type \u0026#39;undefined\u0026#39; is not assignable to type \u0026#39;MediaStream\u0026#39;. 아래와 같이 if 조건문으로 한 번 더 undefined 일 가능성을 없애주면 더 이상 에러가 나지 않는다. 하지만 이미 밖에서 if 조건문으로 undefined 일 가능성을 없애주었는데 왜 한 번 더 묶어줘야 하는지 아직 모르겠다. 그래서 Issue를 통해 팀원들과 공유하고, 동시에 Stackoverflow에도 질문을 게시했다. (이유를 알게 되면 추가로 작성할 예정 같은 문제가 한 번 더 발생하였고 이유를 찾았으니 참고 바람)\nconst myStreamRef = useRef\u0026lt;MediaStream\u0026gt;(); ... if (myStreamRef.current) { myStreamRef.current.getTracks().forEach((track) =\u0026gt; { if (myStreamRef.current) { peerRef.current?.addTrack(track, myStreamRef.current); } }); } Etc #Simple-peer 사용 이유 #npm i simple-peer npm i -D @types/simple-peer 기본 WebRTC로 코드를 작성했을 때, 연결이 될 때까지 \u0026ldquo;IceCandidate\u0026quot;를 socket을 통해 여러번 주고받아야 했다. (물론 해결 방법이 있겠지만 나는 구현하는데 실패하였다. 😢😢😢) 그래서 조금 더 효율적으로 코드를 작성하기 위해 관련 라이브러리를 찾아봤다. 그중 \u0026ldquo;simple-peer\u0026quot;를 선택하였는데 그 이유는 우선 가장 많이 설치된 라이브러리이고, 또 공식 문서를 확인하였을 때 사용 방법을 가장 쉽게 이해할 수 있었기 때문이다.\nTypeScript 사용 후기 #TypeScript를 사용하면서 장점들을 체감했고 매우 마음에 들었다. 단순히 데이터의 타입을 정해둘 뿐이지만 이 덕분에 코드의 구조와 작동 원리를 더 쉽고 명확하게 파악할 수 있었다. TypeScript가 아니었다면 수많은 에러들을 모르고 지나쳤을 것이다. (이전 코드에 문제가 많았지만 JS에서는 오류를 확인하지 못하여서 넘어갔음)\n특히 서버 코드와 클라이언트 코드를 각각 작성할 때 TypeScript의 이점이 두드러졌다. 사실 지금 WebSocket 기능을 혼자서 구현하고 있기 때문에 엄청 큰 이점으로 작용하지는 않지만, 그럼에도 구조를 헷갈리지 않고 서버 코드와 클라이언트 코드를 좀 더 쉽게 연동시킬 수 있었다. 서버와 클라이언트를 각각 작업하게 되는 상황에서는 훨씬 유용할 것이다.\n❗️ 추천 이유: 안정성 up, 작업시간 down 👍👍👍\n","date":"20 May 2022","permalink":"/posts/projects/debate-ducks/4/","section":"Posts","summary":"Summary #WebRTC(simple-peer)로 사용자를 1 대 1로 연결해 서로의 미디어를 빠르게 주고받을 수 있게 만듦.","title":"[Debate-Ducks] Debateroom - WebRTC"},{"content":" 힙은 특정한 규칙을 가지는 트리로, 힙을 이용해서 우선순위 큐를 구현할 수 있습니다.\n출제 빈도 난이도 보통 쉬움 개념 정리 # Heap 이란?\n부모 노드의 값이 자식 노드의 값보다 항상 크거나 작은 완전 이진 트리\nPs. 중복된 값 허용 Heap의 종류 최대 힙: 부모 노드의 값이 자식 노드의 값보다 크거나 같은 완전 이진 트리 최소 힙: 부모 노드의 값이 자식 노드의 값보다 작거나 같은 완전 이진 트리 Heap의 구현 주로 0번 인덱스를 비운 배열로 구현 부모 인덱스 = parseInt(자식 인덱스 / 2)\n왼쪽 자식 인덱스 = 부모 인덱스 x 2\n오른쪽 자식 인덱스 = 부모 인덱스 x 2 + 1 Heap의 삽입과 삭제 삽입 마지막 노드 추가 부모 노드와 조건 비교 후 교환 루트 노드에 도달하면 중지 삭제 루트 노드 삭제 후 마지막 노드를 루트 노드로 이동 자식 노드 둘과 조건 비교 후 교환 자식 노드가 없으면 중지 문제 #1. 디스크 컨트롤러(Lv.3)^ #SJF(Shortest Job First) 알고리즘\n\u0026ldquo;하드디스크가 작업을 수행하고 있지 않을 때에는 먼저 요청이 들어온 작업부터 수행\u0026rdquo;\n-\u0026gt; 현재 수행 중인 작업이 없을 경우 들어온 작업 수행\n-\u0026gt; 현재 수행 중인 작업이 있을 경우 작업 시간이 짧은 순으로 대기목록에 추가\n-\u0026gt; 대기 목록의 순서데로 작업 수행\nHeap class MinHeap { constructor() { this.heap = [null]; } size() { return this.heap.length - 1; } getMin() { return this.heap[1] ? this.heap[1] : null; } swap(a, b) { [this.heap[a], this.heap[b]] = [this.heap[b], this.heap[a]]; } heapPush(value) { this.heap.push(value); let curIdx = this.heap.length - 1; let parIdx = parseInt(curIdx / 2); while (curIdx \u0026gt; 1 \u0026amp;\u0026amp; this.heap[parIdx][1] \u0026gt; this.heap[curIdx][1]) { this.swap(parIdx, curIdx); curIdx = parIdx; parIdx = parseInt(curIdx / 2); } } heapPop() { const min = this.heap[1]; if (this.heap.length \u0026lt;= 2) this.heap = [null]; else this.heap[1] = this.heap.pop(); let curIdx = 1; let leftIdx = curIdx * 2; let rightIdx = curIdx * 2 + 1; if (!this.heap[leftIdx]) return min; if (!this.heap[rightIdx]) { if (this.heap[leftIdx][1] \u0026lt; this.heap[curIdx][1]) { this.swap(leftIdx, curIdx); } return min; } while ( this.heap[leftIdx][1] \u0026lt; this.heap[curIdx][1] || this.heap[rightIdx][1] \u0026lt; this.heap[curIdx][1] ) { const minIdx = this.heap[leftIdx][1] \u0026gt; this.heap[rightIdx][1] ? rightIdx : leftIdx; this.swap(minIdx, curIdx); curIdx = minIdx; leftIdx = curIdx * 2; rightIdx = curIdx * 2 + 1; if (leftIdx \u0026gt;= this.size()) break; } return min; } } function solution(jobs) { const cnt = jobs.length; const minHeap = new MinHeap(); jobs.sort((a, b) =\u0026gt; a[0] - b[0]); let time = 0; let complete = 0; let total = 0; while (jobs.length || minHeap.size()) { while (jobs.length) { if (jobs[0][0] === time) { minHeap.heapPush(jobs.shift()); } else break; } if (minHeap.size() \u0026amp;\u0026amp; time \u0026gt;= complete) { const task = minHeap.heapPop(); complete = task[1] + time; total += complete - task[0]; } time += 1; } return parseInt(total / cnt); } Sort function solution(jobs) { // 새로운 다중 정렬!! jobs.sort(([a, b], [c, d]) =\u0026gt; a - c || b - d); const waiting = []; const total = jobs.length; let processedTime = 0; let time = 0; while (jobs.length || waiting.length) { let task; // 요청 시간이 현재 이전일 때, 대기에 집어넣음 (한번에 넣는 개념)!! while (jobs.length \u0026amp;\u0026amp; jobs[0][0] \u0026lt;= time) { waiting.push(jobs.shift()); } // 대기가 있을 때, 작업시간이 가장 짧은거 작업! // 대기가 없을 때, 다음 작업 시간으로 점프!!! if (waiting.length) { task = waiting.sort(([a, b], [c, d]) =\u0026gt; b - d || a - c).shift(); } else { task = jobs.shift(); time = task[0]; } // 작업 시간만큼 점프 (bcs, 작업 중에는 어차피 다른 작업 시작 못함)!!! time += task[1]; processedTime += time - task[0]; } return parseInt(processedTime / total); } Ref. 프로그래머스 고득점 Kit - 힙(Heap)\n","date":"19 May 2022","permalink":"/posts/algorithm/practice-kit/heap/","section":"Posts","summary":"힙은 특정한 규칙을 가지는 트리로, 힙을 이용해서 우선순위 큐를 구현할 수 있습니다.","title":"[Practice Kit] 힙(Heap)"},{"content":"","date":null,"permalink":"/categories/algorithm/","section":"Categories","summary":"","title":"\u003cAlgorithm\u003e"},{"content":"","date":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm"},{"content":"","date":null,"permalink":"/tags/practice-kit/","section":"Tags","summary":"","title":"Practice Kit"},{"content":"Summary #WebSocket에서 방을 생성하고, 사용자가 방에 입장할 수 있게 함. (한 방에 최대 2명)\nDetails #서버 방 입장 코드 #import { SubscribeMessage, WebSocketGateway, WebSocketServer, OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect, ConnectedSocket, MessageBody, } from \u0026#34;@nestjs/websockets\u0026#34;; import { Server, Socket } from \u0026#34;socket.io\u0026#34;; @WebSocketGateway({ cors: { origin: \u0026#34;*\u0026#34; } }) export class EventsGateway implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect { @WebSocketServer() public server: Server; // 클라이언트에서 \u0026#34;connect\u0026#34; 후 방(debateId)에 \u0026#34;join\u0026#34; 시도 @SubscribeMessage(\u0026#34;join\u0026#34;) handleJoin( @ConnectedSocket() socket: Socket, @MessageBody() debateId: string ) { // 현제 방에 몇명이 있는지 파악 const roomSize = this.server.sockets.adapter.rooms.get(debateId)?.size || 0; // 2명 (찬성, 반대) 미만일 때 입장 // 2명 이상이면 입장 거절 if (roomSize \u0026lt; 2) { socket.join(debateId); socket.to(debateId).emit(\u0026#34;guestJoin\u0026#34;); } else { socket.emit(\u0026#34;overcapacity\u0026#34;); } } afterInit(): void { console.log(\u0026#34;WebSocket Server Init\u0026#34;); } handleConnection(@ConnectedSocket() socket: Socket): void { console.log(\u0026#34;connected\u0026#34;, socket.id); } handleDisconnect(@ConnectedSocket() socket: Socket): void { console.log(\u0026#34;disconnected\u0026#34;, socket.id); } } 클라이언트 방 입장 코드 #// debateroom/[debateId].tsx import { useRouter } from \u0026#34;next/router\u0026#34;; import { useEffect, useRef } from \u0026#34;react\u0026#34;; import { io, Socket } from \u0026#34;socket.io-client\u0026#34;; import Room from \u0026#34;../../../components/debateroom/Room\u0026#34;; export default function Debateroom() { const router = useRouter(); const { debateId } = router.query; const socketRef = useRef\u0026lt;Socket\u0026gt;(); useEffect(() =\u0026gt; { socketRef.current = io(`${process.env.NEXT_PUBLIC_API_URL}`); }, []); return ( \u0026lt;\u0026gt; \u0026lt;Room debateId={debateId} socket={socketRef.current} /\u0026gt; \u0026lt;/\u0026gt; ); } // Room.tsx import { useEffect } from \u0026#34;react\u0026#34;; import { Socket } from \u0026#34;socket.io-client\u0026#34;; interface IRoom { debateId: string | string[] | undefined; socket: Socket | undefined; } export default function Room({ debateId, socket }: IRoom) { useEffect(() =\u0026gt; { // \u0026#34;connect\u0026#34; 후 방(debateId)에 \u0026#34;join\u0026#34; 시도 socket?.on(\u0026#34;connect\u0026#34;, () =\u0026gt; { socket.emit(\u0026#34;join\u0026#34;, debateId); console.log(\u0026#34;connect\u0026#34;, socket.id); }); socket?.on(\u0026#34;overcapacity\u0026#34;, () =\u0026gt; { console.log(\u0026#34;overcapacity\u0026#34;); }); socket?.on(\u0026#34;guestJoin\u0026#34;, () =\u0026gt; { console.log(\u0026#34;room\u0026#34;, debateId); }); }, [debateId, socket]); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Room\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } Problems #방 입장 시 발생하는 문제 1 #처음에는 useEffect 내부에서 setState로 socket을 받아서 저장했다. 그러자 한 번의 입장에 여러 번의 연결 시도를 하는 문제가 있었다. (bcs, 재랜더링)\n두 번째에는 useEffect 내부에서 바로 const로 socket을 저장한 다음 내부에서 바로 socket의 event를 작성 했다. 하지만 useState를 사용했을 때와 같은 문제가 여전히 발생 하였고, 두 번째 브라우저에서 입장하자 이미 정원을 초과했다.고 입장을 거절당하는 추가적인 문제도 발생했다.\n그래서 cleanUp으로 연결 해제 처리를 해주었더니 위에서 언급한 문제는 모두 해결됬다. 하지만 연결을 하기 전에 해제된다는 경고가 뜨기 시작했다.\n마지막으로 useState 대신에 useRef를 사용했다. (bcs, useRef는 재랜더링이 일어나지 않음) 그러자 모든 문제가 말끔히 해결됬다.\nReflections #이전에 한번 만든 적 있는 기능이다 보니 이전의 코드를 참조하면서 만들고 있다. 참조만 하고 더 많이 생각하며 발전시킨 코드를 작성해야 하는데 이전의 코드를 답습하며 현재의 스택에 맞게 적용만 하고 있었다.\n이제부터는 지난 프로젝트 이후에 배운 내용들을 활용하고 더 많이 생각하며 발전된 코드(가독성, 안정성 그리고 효율성 면에서)를 작성할 것이다. 🔥🔥🔥\n","date":"18 May 2022","permalink":"/posts/projects/debate-ducks/3/","section":"Posts","summary":"Summary #WebSocket에서 방을 생성하고, 사용자가 방에 입장할 수 있게 함.","title":"[Debate-Ducks] Debateroom - Room"},{"content":"Summary #socket.io를 사용해 WebSocket 서버를 구축하고 클라이언트에서 접속 가능하게 만듦.\nDetails #WebSocket 서버 #*\u0026quot;[Socket.io] Nest.js에서 Socket.io 연결 기초\u0026quot; 참조\n새로운 스택인 Nest.js에 대한 지식 없이 Socket.io를 적용시키려고 하니 어려움을 겪었다. 그래서 공식 문서를 통해 Nest.js에 대한 기본적인 학습을 하고, Youtube에 올라와 있는 강의를 바탕으로 WebSocket 서버를 구축했다.\nWebSocket 클라이언트 #새로운 스택인 Next.js를 사용하였지만 이미 충분히 학습하였고, React의 사용법과 크게 다르지 않아 쉽게 적용할 수 있었다. 다만 TypeScript를 실전에서 처음 써봐서 아직은 적응이 덜 됬다.\nimport { useRouter } from \u0026#34;next/router\u0026#34;; import { useEffect, useState } from \u0026#34;react\u0026#34;; import { io, Socket } from \u0026#34;socket.io-client\u0026#34;; export default function Debateroom() { const router = useRouter(); const { debateId } = router.query; const [socket, setSocket] = useState\u0026lt;Socket | undefined\u0026gt;(); useEffect(() =\u0026gt; { setSocket(io(`${process.env.NEXT_PUBLIC_API_URL}`)); }, []); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Debateroom: {debateId}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } *환경 변수로 NEXT_PUBLIC_\u0026hellip; 사용\nProblems #WebSocket CORS Error #처음 Youtube의 강의만 보고 서버를 구축했을 때 CORS 에러가 발생했다. 기본 express에서는 new Server에 { cors: { origin: \u0026quot;...\u0026quot; } }을 설정해서 해결했던 문제였다. Nest.js에서는 @WebSocketGateway에 { cors: { origin: \u0026quot;...\u0026quot; } }을 설정해서 해결했다.\nReflections #이전 프로젝트 때 package-lock.json이 자주 충돌이 났다. package-lock.json이 package.json의 보조하는 역할이라고 대충 알고 있던 우리는 package-lock.json을 버전 관리에서 제외했다. 그 후 프로젝트를 진행 하는데 아무런 이상이 없었다. 그래서 이번에도 package-lock.json을 버전 관리에서 제외했다.\n하지만 이번에는 어떤 역할을 하는지 정확히 모르는데 버전 관리에서 제외하는 게 맞는 걸까 싶었고 관련 정보를 찾아봤다. package-lock.json은 의존성 트리를 정확히 저장하여 메이저 미만의 업데이트 시 혹시 모를 문제를 대비하는 역할을 했다. 그래서 급하게 다시 package-lock.json을 버전 관리에 추가했다.\n다음부터는 어떤 결정을 내리기 전에 미리 꼼꼼히 확인하고 결정을 내릴 것이다. 또한 한 번 이상이 없었다고 계속 이상이 없을 것이라는 안일한 생각을 버릴 것이다. 대충 알고 있을 때 \u0026ldquo;왜?\u0026rdquo; 라고 묻는 것을 멈추는 것을 경계하자!\n❗️ 대충 알고 있을 때 \u0026ldquo;왜?\u0026ldquo;라고 묻는 걸 멈추는 것을 경계하자 ❗️\nRef. package-lock.json은 왜 필요할까?\n","date":"17 May 2022","permalink":"/posts/projects/debate-ducks/2/","section":"Posts","summary":"Summary #socket.","title":"[Debate-Ducks] Debateroom - Init"},{"content":"설치 #npm i @nestjs/websockets @nestjs/platform-socket.io npm i -D @types/socket.io 기본 설정 #npx nest g module events npx nest g ga events events.gateway.ts 및 events.gateway.spec.ts를 events로 이동 app.module.ts의 providers에서 EventsGateway 삭제 events.module.ts의 provider와 exports에 EventsGateway 추가 Why?\nEventsGateway를 여러 곳에서 provider 하면 매번 서버가 새로 생성\n그래서 EventsModule에서 한 번만 provider 하고 exports 한 뒤 여러 곳에서 사용 1. EventsModule #import { EventsGateway } from \u0026#34;./events.gateway\u0026#34;; import { Module } from \u0026#34;@nestjs/common\u0026#34;; @Module({ providers: [EventsGateway], exports: [EventsGateway], }) export class EventsModule {} 2. EventsGateway #import { WebSocketGateway, WebSocketServer, SubscribeMessage, OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect, ConnectedSocket, MessageBody, } from \u0026#34;@nestjs/websockets\u0026#34;; import { Server, Socket } from \u0026#34;socket.io\u0026#34;; import { onlineMap } from \u0026#34;./onlineMap\u0026#34;; // # namespace: 같은 namespace에 있는 socket들만 소통 가능 // 일종의 대기실 개념이며 default는 \u0026#34;/\u0026#34; 이고, 정규 표현식 사용 가능 // # cors: { origin: \u0026#34;*\u0026#34; }은 접근 가능한 url @WebSocketGateway({ namespace: /\\/ws-.+/, cors: { origin: \u0026#34;*\u0026#34; } }) // # implements: 필수 구현요소 검사용 export class EventsGateway implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect { // # @WebSocketServer: WebSocket의 서버 (io) @WebSocketServer() public server: Server; // # @SubscribeMessage: WebSocket의 이벤트 리스너 (on 1) @SubscribeMessage(\u0026#34;test\u0026#34;) // # handle...: WebSocket의 custom 이벤트 함수 (on 2) // # @MessageBody: body로 받는 데이터 handleTest(@MessageBody() data: string) { console.log(\u0026#34;test\u0026#34;, data); } @SubscribeMessage(\u0026#34;login\u0026#34;) handleLogin( @MessageBody() data: { id: number; channels: number[] }, // @ConnectedSocket: 연결된 socket @ConnectedSocket() socket: Socket ) { const newNamespace = socket.nsp; console.log(\u0026#34;login\u0026#34;, newNamespace); onlineMap[socket.nsp.name][socket.id] = data.id; newNamespace.emit(\u0026#34;onlineList\u0026#34;, Object.values(onlineMap[socket.nsp.name])); data.channels.forEach((channel) =\u0026gt; { console.log(\u0026#34;join\u0026#34;, socket.nsp.name, channel); socket.join(`${socket.nsp.name}-${channel}`); }); } afterInit(server: Server): any { console.log(\u0026#34;websocket server init\u0026#34;, server); } handleConnection(@ConnectedSocket() socket: Socket): any { console.log(\u0026#34;connected\u0026#34;, socket.nsp.name); if (!onlineMap[socket.nsp.name]) { onlineMap[socket.nsp.name] = {}; } socket.emit(\u0026#34;hello\u0026#34;, socket.nsp.name); } handleDisconnect(@ConnectedSocket() socket: Socket): any { console.log(\u0026#34;disconnected\u0026#34;, socket.nsp.name); const newNamespace = socket.nsp; delete onlineMap[socket.nsp.name][socket.id]; newNamespace.emit(\u0026#34;onlineList\u0026#34;, Object.values(onlineMap[socket.nsp.name])); } } export const onlineMap = {}; Ref. Nest.js WebSockets Official Document\nRef. Nest.js + Socket.io(EventsGateway) 강좌\n","date":"16 May 2022","permalink":"/posts/studies/socket.io/socket.io-nest.js/","section":"Posts","summary":"설치 #npm i @nestjs/websockets @nestjs/platform-socket.","title":"[Socket.io] Nest.js에서 Socket.io 연결 기초"},{"content":"","date":null,"permalink":"/tags/nest.js/","section":"Tags","summary":"","title":"Nest.js"},{"content":"","date":null,"permalink":"/tags/socket.io/","section":"Tags","summary":"","title":"Socket.io"},{"content":" 부분적인 최적해가 전체적인 최적해가 되는 마법.\n출제 빈도 난이도 낮음 어려움 개념 정리 # 순간마다 최적의 답을 선택해 적합한 결과 도출 부분의 최적해 집합이 곧 전체 문제의 해답이 될 때 사용 문제 #1. 체육복(Lv.1)^ #function solution(n, lost, reserve) { const clothes = new Array(n).fill(1); const lostArr = lost.map((el) =\u0026gt; el - 1); const reserveArr = reserve.map((el) =\u0026gt; el - 1); for (let i = 0; i \u0026lt; n; i++) { if (lostArr.includes(i)) clothes[i] -= 1; if (reserveArr.includes(i)) clothes[i] += 1; } for (let i = 0; i \u0026lt; n - 1; i++) { if (clothes[i] === 0 \u0026amp;\u0026amp; clothes[i + 1] === 2) { clothes[i] += 1; clothes[i + 1] -= 1; } if (clothes[i] === 2 \u0026amp;\u0026amp; clothes[i + 1] === 0) { clothes[i] -= 1; clothes[i + 1] += 1; } } return clothes.filter((el) =\u0026gt; el \u0026gt; 0).length; } 2. 조이스틱(Lv.2)^ #// 처음에는 연속되는 A 중 가장 긴 것을 찾아서 되돌아갈지 말지 결정하려 했음. // A로 끝나거나 끝에서 가까운 거리에 있는 경우 등 예외가 있었음. // Idea: A를 마주칠 때 마다 돌아가는게 나은지 쭉 가는게 나은지 다 비교해서 해결!!! function solution(name) { const len = name.length; const chars = name.split(\u0026#34;\u0026#34;); let upDownCnt = 0; chars.forEach((char, idx) =\u0026gt; { const alphabet = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;; const upDownIdx = alphabet.indexOf(char); upDownCnt += Math.min(upDownIdx, 26 - upDownIdx); }); let leftRightArr = [len - 1]; chars.forEach((char, idx) =\u0026gt; { // 1) 다음 값이 A 인지 아닌지 확인 if (name[idx + 1] === \u0026#34;A\u0026#34;) { let aIdx = idx + 1; // 2) 다음 값이 A가 아닐 때까지 반복!! (마지막 aIdx는 A가 아님!) while (name[aIdx] === \u0026#34;A\u0026#34;) aIdx += 1; const right = len - aIdx; // 끝에서 마지막 A까지 이동 수 leftRightArr.push(idx * 2 + right); // A를 만나면 뒤돌아 감! leftRightArr.push(right * 2 + idx); // 처음부터 뒤돌아감!! } }); return upDownCnt + Math.min(...leftRightArr); } 3. 큰 수 만들기(Lv.2) ^ #function solution(number, k) { const nums = [...number].map((num) =\u0026gt; parseInt(num)); let stack = [0]; let deleteCount = -1; for (let num of nums) { // Idea: deleteCount 조정! while (deleteCount \u0026lt; k \u0026amp;\u0026amp; num \u0026gt; stack[stack.length - 1]) { stack.pop(); deleteCount += 1; } // Edge: deleteCount가 k보다 작게 남았을 경우!!! if (stack.length \u0026lt; number.length - k) stack.push(num); } return stack.join(\u0026#34;\u0026#34;); } Ex. \u0026ldquo;98675\u0026rdquo;, 2\nEdge Case를 처리했을 경우\nVariable num 0 9 8 6 7 5 stack [0] [9] [9, 8] [9, 8, 6] [9, 8, 7] [9, 8, 7] deleteCount -1 0 0 0 1 1 Edge Case를 처리하지 않았을 경우\nVariable num 0 9 8 6 7 5 stack [0] [9] [9, 8] [9, 8, 6] [9, 8, 7] [9, 8, 7, 5] deleteCount -1 0 0 0 1 1 4. 구명보트(Lv.2)^ #function solution(people, limit) { people.sort((a, b) =\u0026gt; a - b); let cnt = 0; while (people.length \u0026gt; 0) { /* if (people[0] + people[people.length - 1] \u0026lt;= limit) { people.pop(); people.shift(); } else { people.pop(); } cnt += 1; */ let person = people.pop(); person += people[0]; if (person \u0026lt;= limit) people.shift(); cnt += 1; } return cnt; } 5. 섬 연결하기(Lv.3)^ #// # 최소 비용 신장 트리(MST) // # Union-Find in 그루스칼(Kruskal) 알고리즘 // Ps. 간선(Edge; E)의 수는 노드(Node; N)의 수 - 1 function solution(n, costs) { // 1. x의 최상위 노드(기원)를 찾는 함수 // 재귀 함수로 최상위 노드를 찾을 때까지 부모 노드 탐색 const getOrigin = (parent, x) =\u0026gt; { if (parent[x] === x) return x; return (parent[x] = getOrigin(parent, parent[x])); }; // 2. 최상위 노드를 같은 값으로 병합하는 함수 // 최상위 노드가 다를 경우 더 낮은 값으로 최상위 노드 병합 const unionParent = (parent, a, b) =\u0026gt; { const n1 = getOrigin(parent, a); const n2 = getOrigin(parent, b); if (n1 \u0026lt; n2) return (parent[n2] = n1); else return (parent[n1] = n2); }; // 3. 최상위 노드가 같은지 판단하는 함수 const findParent = (parent, a, b) =\u0026gt; { const n1 = getOrigin(parent, a); const n2 = getOrigin(parent, b); if (n1 === n2) return true; else return false; }; let result = 0; // 1) 자기 자신을 부모로 가지는 최상위 노드 생성 const parent = []; for (let i = 0; i \u0026lt; n; i += 1) { parent.push(i); } // 2) 최소 비용이라 가중치가 낮은 순으로 정렬 costs.sort((a, b) =\u0026gt; a[2] - b[2]); // 3) 가중치가 낮은 순으로 연결 후 가중치 저장 // 전부 연결되는 순간 더이상 if문 작동 안함 for (const cost of costs) { if (!findParent(parent, cost[0], cost[1])) { result += cost[2]; unionParent(parent, cost[0], cost[1]); } } return result; } 6. 단속카메라(Lv.3)^ #function solution(routes) { // 진입 시점을 기준으로 오름차순 정렬 routes.sort((a, b) =\u0026gt; a[0] - b[0]); // 첫 카메라는 무조건 설치 let camera = 1; // 첫 진출 시점 let out = routes[0][1]; for (let route of routes) { // Idea: // 현재의 진입 시점이 마지막 진출 시점 이후라면 // 카메라 추가 설치 및 마지막 진출 시점 갱신 if (out \u0026lt; route[0]) { camera += 1; out = route[1]; } // Edge: // 마지막 진출 시점이 현재의 진출 시점 이후라면 // 마지막 진출 시점 갱신 // 그래야 앞의 경로가 뒤의 경로를 덮어도 // 내부에서 카운팅 가능 if (route[1] \u0026lt; out\u0026gt;) { out = route[1]; } } return camera; } function solution(routes) { let cnt = 0; // Idea: 카메라가 설치되어 있지 않을 때 let camera = -30001; // 진출 시점을 기준으로 오름차순 정렬 routes.sort((a, b) =\u0026gt; a[1] - b[1]); for (let route of routes) { // 현재의 진입 시점이 마지막 카메라 이후라면 // 카메라 추가 설치 및 마지막 카메라 갱신 if (camera \u0026lt; route[0]) { cnt++; camera = route[1]; } } return cnt; } Ref. 프로그래머스 고득점 Kit - 탐욕법(Greedy)\n","date":"12 May 2022","permalink":"/posts/algorithm/practice-kit/greedy/","section":"Posts","summary":"부분적인 최적해가 전체적인 최적해가 되는 마법.","title":"[Practice Kit] 탐욕법(Greedy)"},{"content":" LIFO, FIFO, push \u0026amp; pop! 스택과 큐를 이용해서 문제를 풀어보세요.\n출제 빈도 난이도 보통 쉬움 개념 정리 # Stack Queue 후입선출(LIFO) 선입선출(FIFO) push \u0026amp; pop push \u0026amp; shift 문제 #1. 기능개발(Lv.2)^ #function solution(progresses, speeds) { let day = 0; const result = {}; while (progresses.length \u0026gt; 0) { day += 1; progresses = progresses.map((el, idx) =\u0026gt; el + speeds[idx]); for (let i = 0; i \u0026lt; progresses.length; i++) { if (progresses[i] \u0026lt; 100) break; if (progresses[i] \u0026gt;= 100) { // 같은 day(타입)에 추가 해줌. result[day] = result[day] ? result[day] + 1 : 1; } } progresses.splice(0, result[day]); speeds.splice(0, result[day]); } return Object.values(result); } 2. 프린터(Lv.2)^ #// Idea: location 조정!! function solution(priorities, location) { let cnt = 0; while (priorities.length \u0026gt; 0) { const maxPriority = Math.max(...priorities); const priority = priorities.shift(); if (priority === maxPriority) { cnt += 1; if (location === 0) return cnt; } else { priorities.push(priority); } location -= 1; // 제일 뒤로 보냄. if (location === -1) { location = priorities.length - 1; } } } 3. 다리를 지나는 트럭(Lv.2)^ #// Buffer function solution(bridge_length, weight, truck_weights) { const len = truck_weights.length; let time = 0; const buffer = new Array(bridge_length).fill(0); let bufferWeights = 0; const passedTrucks = []; while (passedTrucks.length \u0026lt; len) { time += 1; // buffer 맨앞 빼서, 0이 아닐 경우 passedTrucks에 저장. const passedTruck = buffer.shift(); bufferWeights -= passedTruck; if (passedTruck !== 0) { passedTrucks.push(passedTruck); } // truck_weights 맨앞 빼서, weight 안넘을 경우 buffer에 저장. if (bufferWeights + truck_weights[0] \u0026lt;= weight) { const newTruck = truck_weights.shift(); bufferWeights += newTruck; buffer.push(newTruck); } else { buffer.push(0); } } return time; } // better performance function solution(bridge_length, weight, truck_weights) { const queue = [[0, 0]]; // [truckWeight, time] let time = 0, weightOnBridge = 0; while (queue.length \u0026gt; 0 || truck_weights.length \u0026gt; 0) { // 현재 시간과 나갈 시간이 같으면 내보냄. if (queue[0][1] === time) weightOnBridge -= queue.shift()[0]; if (weightOnBridge + truck_weights[0] \u0026lt;= weight) { weightOnBridge += truck_weights[0]; // Idea: 나갈 시간을 미리 입력! queue.push([truck_weights.shift(), time + bridge_length]); } else { // Idea: 새로운 트럭이 추가되지 않으면, 시간을 건너뜀!!! (뒤에서 +1이라 여기서 -1) if (queue[0]) time = queue[0][1] - 1; } time += 1; } return time; } Ref. 프로그래머스 고득점 Kit - 스택/큐\n","date":"10 May 2022","permalink":"/posts/algorithm/practice-kit/stack-queue/","section":"Posts","summary":"LIFO, FIFO, push \u0026amp; pop!","title":"[Practice Kit] 스택/큐(Stack/Queue)"},{"content":"개요 # 새로운 스택을 적극 활용해 기존 프로젝트를 개선한 새로운 버전의 Debate-Ducks 프로젝트 시작.\nPs1. 원래는 조금 더 일찍 시작해야 했으나 내가 증상이 심한 코로나에 한번 더 걸려 후유증에 오래 시달리고, 또 각자의 일정이 있어서 이제야 시작. 🤧🤒🤕\nPs2. 팀원중 한분은 바로 취업하셔서 4인 프로젝트에서 3인 프로젝트로 변경. 👏👏👏\n목적 #1. 프로젝트의 목적 # 기존 프로젝트에서 완성하지 못했던 기능 완성 및 아쉬웠던 기능 개선. 아쉬웠던 UI/UX 개선. 코드의 가독성 및 유지 보수성 개선. 기간의 압박으로 도입하지 못했던 새로운 스택들 도입. 협업의 방식을 효율적으로 개선. 2. 새로운 스택 사용 목적 # TypeScript를 사용하여 코드의 안정성과 가독성 향상. 정적 타입 컴파일 단계에서 오류 포착 가능 개발자의 의도를 코드로 명확히 표시 가능 Next.js를 사용하여 기능 및 편의성 향상. 파일 시스템 기반 라우팅 등의 장점 React-query를 사용하여 외부 데이터 효율적 처리. 캐싱, 중복 호출 허용, 시간 조절등의 장점 SCSS를 사용하여 관심사 분리. 중첩, 변수 선언, 연산자등의 장점 Nest.js를 사용하여 효율성, 안정성, 확장성 향상. 규칙 설정 #1. Communication Rules #부트 캠프의 프로젝트 때는 거의 모든 의사소통을 영상 회의를 통해 했다. 그러다 보니 회의에 너무 많은 시간을 소비했다. 그래서 이번에는 정규 회의를 매주 월요일에 진행하고, 메시지와 Comment를 적극적으로 활용하며, 회의가 필요한 경우에만 목적을 명확히 하고 임시 회의를 진행 하기로 했다.\n2. Git Message Convention #기존의 Type 분류가 명확하지 않아 헷갈리던 부분을 개선했다. (Ex. Add의 경우 파일 추가를 기준으로 했었는데 기능 추가 없이 단순히 파일만 늘어나게 되는 경우 애매했음) 또한 예시를 추가하여 명확성을 높혔다.\n[Type] Title # ---------- # [Add] 기능 추가 / Ex. 로그인 기능 추가 # [Update] 기능 개선 / Ex. 로그인 기능에 유효성 검사 추가 # [Delete] 기능 삭제 / Ex. 로그인 기능 삭제 # [Change] 기능 수정 / Ex. 유효성 검사 조건 변경 # [Modify] 오타 수정 및 코드 정돈 / Ex. 로그인 기능 코드 정돈 # [Fix] 문제 해결 / Ex. 로그인 기능에 중복 아이디 생성 문제 해결 # [Setting] 설정 / Ex. Redux-toolkit 초기 설정 # [Style] 스타일 관련 작업 / Ex. 로그인 버튼 스타일 적용 # [Docs] 문서 관련 작업 / Ex. README 문서에 변경 사항 추가 # [Test] 테스트 관련 작업 / Ex. 로그인 기능 테스트 코드 변경 # ---------- # 개조식으로 작성 # 내용이 필요할 경우 제목에서 한 줄 띄우고 작성 # 내용이 여러 줄일 때는 \u0026#34;-\u0026#34;로 구분 # \u0026#34;어떻게\u0026#34; 보다는 \u0026#34;무엇을\u0026#34;, \u0026#34;왜\u0026#34;를 설명 Github 세팅 #1. Labels #부트 캠프의 프로젝트 때는 라벨링을 팀 단위로 철저히 적용하지는 않았다. 개인적으로는 닫힌 Issue나 PR을 확인할 때 라벨을 통해 쉽게 필터링이 가능하다는 장점이 마음에 들어 적극 활용했었다. 이번에는 이 장점을 적극 어필하였고 라벨링을 팀 단위로 철저히 적용하기로 했다.\n엑세스 토큰 발급\nhttps://github.com/settings/tokens scopes에서 repo 선택 labels.json 파일 생성\n[ { \u0026#34;name\u0026#34;: \u0026#34;Problem\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;3B170B\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34; }, ... ] github-label-sync 사용\nnpx github-label-sync --access-token [액세스 토큰] --labels labels.json [계정명]/[저장소 이름] Issue Labels: Problem, Suggestion, Urgent Pull Request Labels: Git message의 Type과 일치 2. Issue Template #부트 캠프의 프로젝트 때는 Issue를 주로 Task Card로 활용했었다. 하지만 Issues 탭을 봤을 때 Task Card로 가득하여 정작 어떤 이슈들이 있었는지 알아보기 힘들었고, Task Card도 결국 PR과 중복되는 내용이라 크게 의미가 없었다. 그래서 Issue는 정말 이슈가 있을 때만 발행하고, 작업 관리의 경우 다른 툴을 활용하기로 결정했다. (이번에는 Client와 Server의 저장소를 분리해서 Issues에서 통합 관리가 되지 않는 문제도 있었음)\n.github/ISSUE_TEMPLATE/problem-template.md\n--- name: Problem Template about: 문제가 발생했을 때 발행하는 이슈입니다. title: \u0026#34;\u0026#34; labels: \u0026#34;Problem\u0026#34; assignees: \u0026#34;\u0026#34; --- \u0026lt;!-- 어떤 문제이며 어떤 상황에서 발생하는지 명시 --\u0026gt; \u0026lt;!-- 원하는지 결과 명시 --\u0026gt; \u0026lt;!-- 해결을 위해 사용해 본 방법 명시 --\u0026gt; \u0026lt;!-- 에러 코드가 있을 경우 첨부 --\u0026gt; \u0026lt;!-- 필요할 경우 Screenshot 및 Gif 첨부 --\u0026gt; \u0026lt;!-- 해결된 문제의 경우 해결 방법 명시 --\u0026gt; .github/ISSUE_TEMPLATE/suggestion-template.md\n--- name: Suggestion Template about: 제안이 있을 때 발행하는 이슈입니다. title: \u0026#34;\u0026#34; labels: \u0026#34;Suggestion\u0026#34; assignees: \u0026#34;\u0026#34; --- \u0026lt;!-- 제안과 제안의 이유 명시 --\u0026gt; \u0026lt;!-- 구체적인 실현 방법이 있을 경우 명시 --\u0026gt; \u0026lt;!-- 참고 자료가 있을 경우 첨부 --\u0026gt; 3. Pull Request Template #부트 캠프의 프로젝트 때는 어떤 브랜치에서 어떤 브랜치로 PR을 보내는지 직접 작성하였는데 Github에서 기본적으로 명시해 주는 내용이라 더 이상 작성하지 않기로 했다.\n.github/pull_request_template.md \u0026lt;!-- 제목의 경우 [Type] 사용하지 않기 --\u0026gt; \u0026lt;!-- 변경 사항을 개조식으로 작성 --\u0026gt; \u0026lt;!-- 변경 사항이 여러 개일 경우 \u0026#34;-\u0026#34;로 구분 --\u0026gt; \u0026lt;!-- \u0026#34;어떻게\u0026#34; 보다는 \u0026#34;무엇을\u0026#34;, \u0026#34;왜\u0026#34;를 설명 --\u0026gt; \u0026lt;!-- 결과물에 대한 Screenshot 및 Gif 추가 가능 --\u0026gt; \u0026lt;!-- Reviewers 등록 --\u0026gt; \u0026lt;!-- Assignees 등록 --\u0026gt; \u0026lt;!-- 포함되는 Commit의 Label 등록 --\u0026gt; Client 초기 세팅 #1. Next.js + TypeScript #npx create-next-app --typescript debate-ducks --use-npm tsconfig.json \u0026#34;target\u0026#34;: \u0026#34;es6\u0026#34;, 2. EsLint + Prettier #npm i -D eslint prettier eslint-config-prettier @typescript-eslint/eslint-plugin .eslintrc.json\n{ \u0026#34;plugins\u0026#34;: [\u0026#34;@typescript-eslint\u0026#34;], \u0026#34;extends\u0026#34;: [ \u0026#34;next/core-web-vitals\u0026#34;, \u0026#34;plugin:@typescript-eslint/recommended\u0026#34;, \u0026#34;prettier\u0026#34; ], \u0026#34;rules\u0026#34;: { \u0026#34;react/react-in-jsx-scope\u0026#34;: 0, \u0026#34;@typescript-eslint/no-unused-vars\u0026#34;: 2, \u0026#34;@typescript-eslint/no-explicit-any\u0026#34;: 2 } } .prettierrc.json\n{ \u0026#34;arrowParens\u0026#34;: \u0026#34;always\u0026#34;, \u0026#34;bracketSpacing\u0026#34;: true, \u0026#34;htmlWhitespaceSensitivity\u0026#34;: \u0026#34;css\u0026#34;, \u0026#34;insertPragma\u0026#34;: false, \u0026#34;jsxBracketSameLine\u0026#34;: false, \u0026#34;jsxSingleQuote\u0026#34;: false, \u0026#34;printWidth\u0026#34;: 80, \u0026#34;proseWrap\u0026#34;: \u0026#34;preserve\u0026#34;, \u0026#34;quoteProps\u0026#34;: \u0026#34;as-needed\u0026#34;, \u0026#34;requirePragma\u0026#34;: false, \u0026#34;semi\u0026#34;: true, \u0026#34;singleQuote\u0026#34;: false, \u0026#34;tabWidth\u0026#34;: 2, \u0026#34;trailingComma\u0026#34;: \u0026#34;all\u0026#34;, \u0026#34;useTabs\u0026#34;: false, \u0026#34;vueIndentScriptAndStyle\u0026#34;: false } .vscode/settings.json\n{ \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.fixAll.eslint\u0026#34;: true }, \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34;, \u0026#34;css.lint.unknownAtRules\u0026#34;: \u0026#34;ignore\u0026#34; } ","date":"9 May 2022","permalink":"/posts/projects/debate-ducks/1/","section":"Posts","summary":"개요 # 새로운 스택을 적극 활용해 기존 프로젝트를 개선한 새로운 버전의 Debate-Ducks 프로젝트 시작.","title":"[Debate-Ducks] 개선 프로젝트 시작"},{"content":" 깊이/너비 우선 탐색을 사용해 원하는 답을 찾아보세요.\n출제 빈도 난이도 높음 어려움 문제 #1. 타겟 넘버(Lv.2)^ #// DFS(재귀) function solution(numbers, target) { let cnt = 0; const dfs = (depth, sum) =\u0026gt; { if (depth === numbers.length) { if (sum === target) { cnt++; } return; } // 타겟을 발견할떄까지 깊이를 더하며 탐색. dfs(depth + 1, sum + numbers[depth]); dfs(depth + 1, sum - numbers[depth]); }; dfs(0, 0); return cnt; } // DFS(스택) // lower performance function solution(numbers, target) { const stack = [[0, 0]]; let cnt = 0; while (stack.length \u0026gt; 0) { const [prevNum, curIdx] = stack.pop(); if (curIdx === numbers.length - 1) { if (prevNum === target) cnt += 1; continue; } stack.push([prevNum + numbers[curIdx], curIdx + 1]); stack.push([prevNum - numbers[curIdx], curIdx + 1]); } return cnt; } 2. 네트워크(Lv.3)^ #// DFS(재귀) function solution(n, computers) { let cnt = 0; const isVisited = new Array(n).fill(false); // 연결된 모든 네트워크를 방문하는 재귀함수. const dfs = (i) =\u0026gt; { isVisited[i] = true; computers[i].forEach((computer, idx) =\u0026gt; { if (computer === 1 \u0026amp;\u0026amp; !isVisited[idx]) { dfs(idx); } }); }; // 연결된 모든 네트워크를 방문하면 카운트 후 넘어감. computers.forEach((_, idx) =\u0026gt; { if (!isVisited[idx]) { dfs(idx); cnt++; } }); return cnt; } 3. 단어 변환(Lv.3)^ #// BFS(큐) function solution(begin, target, words) { if (!words.includes(target)) return 0; const queue = [[begin, 0]]; const isVisited = words.map((word) =\u0026gt; false); const isSameOne = (str1, str2) =\u0026gt; { let cnt = 0; for (let i = 0; i \u0026lt; str1.length; i++) { if (str1[i] !== str2[i]) cnt++; } return cnt === 1; }; while (queue.length \u0026gt; 0) { const [curWord, curCnt] = queue.shift(); if (curWord === target) return curCnt; words.forEach((word, idx) =\u0026gt; { if (isVisited[idx]) return; if (isSameOne(curWord, word)) { queue.push([word, curCnt + 1]); isVisited[idx] = true; } }); } return 0; } /* let equal = 0; curWord.split(\u0026#34;\u0026#34;).forEach((char) =\u0026gt; { if (word.includes(char)) equal++; }); if (equal === word.length - 1) { ... } 로 처음에 풀었는데 중복 char를 처리해주지 못해서 에러. */ 4. 여행경로(Lv.3)^ #// DFS(재귀) function solution(tickets) { // 문자는 `.sort()`로 오름차순 정렬 가능. tickets.sort(); // 1) 결과 저장소 const result = []; // 2) 중복 체크 const isVisited = tickets.map((ticket) =\u0026gt; false); const len = tickets.length; // 3) 재귀 함수 const dfs = (node, depth) =\u0026gt; { // ㄱ. 결과 저장!!! result.push(node); // ★☆★유효 경로 O (마지막 node 도착)★☆★ if (depth === len) { return true; } // 반복문 for (let i = 0; i \u0026lt; len; i++) { // 중복 체크 if (isVisited[i]) continue; // 및 조건 확인 if (tickets[i][0] === node) { // ㄴ. 중복 저장!! isVisited[i] = true; // 조건을 만족한다면 다음 node에서 재귀 지속! // 조건을 만족하지 못하면 false를 반환하고 재귀 종료! // ★☆★탈출 조건에서 true를 반환하는 순간 순차적으로 true 반환★☆★ if (dfs(tickets[i][1], depth + 1)) { return true; } // ㄴ. 중복 취소!! isVisited[i] = false; } } // ㄱ. 결과 취소!!! result.pop(); // 유효 경로 X return false; }; dfs(\u0026#34;ICN\u0026#34;, 0); return result; } My Tips #DFS/BFS 구분 👍 # DFS BFS 스택, 재귀 함수 큐 탐색 시 가중치 혹은 제약, 완전 탐색 최단 탐색만 고려 시간 복잡도 # Big- O O(logn) 정렬, 이진 탐색 O(n) 반복문 O(n²) 재귀 O(2ⁿ) 이중 반복문 Ref. 프로그래머스 고득점 Kit - 깊이/너비 우선 탐색(DFS/BFS)\n","date":"8 May 2022","permalink":"/posts/algorithm/practice-kit/dfs-bfs/","section":"Posts","summary":"깊이/너비 우선 탐색을 사용해 원하는 답을 찾아보세요.","title":"[Practice Kit] 깊이/너비 우선 탐색(DFS/BFS)"},{"content":" 무식해 보여도 사실은 최고의 방법일 때가 있지요.\n출제 빈도 난이도 높음 쉬움 문제 #1. 모의고사(Lv.1)^ #function solution(answers) { const one = [1, 2, 3, 4, 5]; const two = [2, 1, 2, 3, 2, 4, 2, 5]; const three = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]; const func = (answers, nums) =\u0026gt; { // Idea: 나머지로 반복되는 값 처리 가능. return answers.filter((answer, idx) =\u0026gt; answer === nums[idx % nums.length]) .length; }; const result = [ [1, func(answers, one)], [2, func(answers, two)], [3, func(answers, three)], ]; result.sort((a, b) =\u0026gt; b[1] - a[1]); return result.filter((el) =\u0026gt; el[1] === result[0][1]).map((el) =\u0026gt; el[0]); } 2. 소수 찾기(Lv.2)^ #function solution(numbers) { const isPrime = (num) =\u0026gt; { if (num \u0026lt; 2) return false; for (let i = 2; i \u0026lt;= Math.floor(Math.sqrt(num)); i++) { if (num % i === 0) return false; } return true; }; const getPermutation = (arr) =\u0026gt; { const result = []; arr.forEach((head, idx, arr) =\u0026gt; { result.push([head]); const rest_arr = arr.filter((_, i) =\u0026gt; i !== idx); const rest_permutation = getPermutation(rest_arr); result.push(...rest_permutation.map((tail) =\u0026gt; [head, ...tail])); }); return result; }; const nums = numbers.split(\u0026#34;\u0026#34;); const permutations = getPermutation(nums) .map((el) =\u0026gt; el.join(\u0026#34;\u0026#34;)) .map((el) =\u0026gt; parseInt(el)); const uniquePermutations = [...new Set(permutations)]; return uniquePermutations.filter((num) =\u0026gt; isPrime(num)).length; } 3. 카펫(Lv.2)^ #function solution(brown, yellow) { const getDivisors = (num) =\u0026gt; { const result = []; for (let i = 1; i \u0026lt;= Math.floor(Math.sqrt(num)); i++) { if (num % i === 0) result.push(i); } return result.map((el) =\u0026gt; [num / el, el]); }; const result = []; const divisors = getDivisors(yellow); divisors.forEach((divisor) =\u0026gt; { const width = divisor[0] + 2; const height = divisor[1] + 2; if (brown === width * 2 + (height - 2) * 2) { result.push(width, height); } }); return result; } My Tips #효율적인 소수 판별 #const isPrime = (num) =\u0026gt; { if (num \u0026lt; 2) return false; for (let i = 2; i \u0026lt;= Math.floor(Math.sqrt(num)); i++) { if (num % i === 0) return false; } return true; }; 재귀함수를 활용한 조합 및 순열 # 조합\n모든 조합\nconst getCombination = (arr) =\u0026gt; { const result = []; arr.forEach((head, idx, src) =\u0026gt; { // 현재 요소 저장. result.push(head); // 현재 요소 뒤의 나머지 배열!!! const restArr = src.slice(idx + 1); // 의 조합. const restCombination = getCombination(restArr); // 현재 요소와 합쳐서 저장. result.push(...restCombination.map((tail) =\u0026gt; [head, ...tail])); }); return result; }; 특정 조합\nconst getCombination = (arr, selected_num) =\u0026gt; { // 마지막 값이 결정되고 순차적으로 값 결정!! if (selected_num === 1) return arr.map((el) =\u0026gt; [el]); const result = []; arr.forEach((head, idx, arr) =\u0026gt; { // 현재 요소 뒤의 나머지 배열!!! const restArr = arr.slice(idx + 1); // 의 조합. const restCombination = getCombination(restArr, selected_num - 1); // 현재 요소와 합쳐서 저장. result.push(...restCombination.map((tail) =\u0026gt; [head, ...tail])); }); return result; }; 순열\n모든 순열\nconst getPermutation = (arr) =\u0026gt; { const result = []; arr.forEach((head, idx, arr) =\u0026gt; { // 현재 요소 저장. result.push([head]); // 현재 요소를 뺀 나머지 배열!!! const restArr = arr.filter((_, i) =\u0026gt; i !== idx); // 의 순열. const restPermutation = getPermutation(restArr); // 현재 요소와 합쳐서 저장. result.push(...restPermutation.map((tail) =\u0026gt; [head, ...tail])); }); return result; }; const getPermutation = (arr, selected_num) =\u0026gt; { const result = []; // 마지막 값이 결정되고 순차적으로 값 결정!! if (selected_num === 1) return arr.map((el) =\u0026gt; [el]); arr.forEach((head, idx, arr) =\u0026gt; { // 현재 요소를 뺀 나머지 배열!!! const restArr = arr.filter((_, i) =\u0026gt; i !== idx); // 의 순열. const restPermutation = getPermutation(restArr, selected_num - 1); // 현재 요소와 합쳐서 저장. result.push(...restPermutation.map((tail) =\u0026gt; [head, ...tail])); }); return result; }; *forEach에 restArr가 하나씩 줄어서 따로 탈출 조건은 필요 없음.\n효율적인 약수 쌍 구하기 #const getDivisors = (num) =\u0026gt; { const result = []; for (let i = 1; i \u0026lt;= Math.floor(Math.sqrt(num)); i++) { if (num % i === 0) result.push(i); } return result.map((el) =\u0026gt; [el, num / el]); }; Ref. 프로그래머스 고득점 Kit - 완전탐색\n","date":"6 May 2022","permalink":"/posts/algorithm/practice-kit/exhaustivesearch/","section":"Posts","summary":"무식해 보여도 사실은 최고의 방법일 때가 있지요.","title":"[Practice Kit] 완전탐색(Exhaustive Search, Brute-force Search)"},{"content":" 정렬을 이용해서 문제를 효율적으로 풀어보세요.\n출제 빈도 난이도 높음 쉬움 Tip. 객체 정렬 및 다중 정렬\n문제 #1. K번째수(Lv.1)^ #function solution(array, commands) { const func = (arr, i, j, k) =\u0026gt; { const cutArr = arr.slice(i - 1, j); cutArr.sort((a, b) =\u0026gt; a - b); return cutArr[k - 1]; }; return commands.map((command) =\u0026gt; func(array, ...command)); } 2. 가장 큰 수(Lv.2)^ #function solution(numbers) { const numStr = numbers .map((num) =\u0026gt; String(num)) // .sort는 Greedy하게 작동. .sort((a, b) =\u0026gt; Number(b + a) - Number(a + b)) .join(\u0026#34;\u0026#34;); // Edge: 0으로만 구성 되었을 경우. return numStr[0] === \u0026#34;0\u0026#34; ? \u0026#34;0\u0026#34; : numStr; } 3. H-Index(Lv.2)^ #function solution(citations) { citations.sort((a, b) =\u0026gt; b - a); let i = 0; // h 편 이상 인용된 논문이 h편 이상! while (citations[i] \u0026gt;= i + 1) { i++; } return i; } const solution = (citations) =\u0026gt; citations.sort((a, b) =\u0026gt; b - a).filter((citation, idx) =\u0026gt; citation \u0026gt;= idx + 1) .length; Ref. 프로그래머스 고득점 Kit - 정렬\n","date":"4 May 2022","permalink":"/posts/algorithm/practice-kit/sort/","section":"Posts","summary":"정렬을 이용해서 문제를 효율적으로 풀어보세요.","title":"[Practice Kit] 정렬(Sort)"},{"content":" Key-value쌍으로 데이터를 빠르게 찾아보세요.\n출제 빈도 난이도 높음 보통 개념 정리 #Hash Table # key, value 쌍으로 데이터를 배열(bucket, slot)에 저장하는 자료 구조. 적은 리소스로 많은 데이터를 효율적으로 관리하기 위해 사용. Ex. 작은 크기의 캐쉬 메모리로도 프로세스 관리 가능. 빠른 저장 혹은 검색 가능. key값에 해시 함수를 적용해서 고유한 index를 찾은 후 값을 저장 혹은 검색. 데이터 저장 혹은 검색 시 해시 함수를 1번만 수행해서 평균 시간복잡도는 O(1) (상수 시간, Constant time). 메모리를 미리 할당해 둬야 해서 공간 효율적이지는 않음. Hash Function #임의의 길이를 갖는 임의의 데이터를 고정된 길이의 데이터(hash value)로 매핑하는 단방향 함수.\nDivision Method\n숫자로 된 키값을 해시 테이블의 크기로 나눈 나머지를 해시값으로 반환. 해시 테이블의 크기는 2의 제곱수와 거리가 먼 소수를 사용하는 것이 좋음. 단점: 해시 테이블의 크기가 정해짐. Multiplication Method\n숫자로 된 키값 k, 0과 1 사이의 실수 A, 해시 테이블의 크기 m h(k)=(kAmod1)xm m은 중요하지 않으며 보통 2의 제곱수를 사용. 2진수 연산에 최적화한 컴퓨터 구조 고려. 단점: Division Method 보다 느림. Universal Hashing\n다수의 해시 함수를 집합 H에 넣어두고, 무작위로 선택해 해시값을 만드는 방법. 임의의 키값을 임의의 해시값에 매핑할 확률을 1/m로 만드는 것이 목적. Hash Collision #해시 함수가 서로 다른 두 개의 키에 대해 동일한 해시값 반환.\nSeparate Chaining(분리 연결법) 해당 버킷에 데이터가 이미 있으면 노드를 추가해 다음 노드를 가리키는 방식으로 구현. 장점: 해시 테이블의 확장이 필요없고, 간단하게 구현 및 삭제 가능. 단점: 데이터의 수가 많아지면 동일한 버킷에 연결되는 데이터가 많아지며 효율성 감소.\n*O(n)까지 시간복잡도 증가 가능 Open Addressing(개방 주소법) 비어있는 해시 테이블의 공간을 활용. 해시 함수로 얻은 주소가 아닌, 다른 주소에 데이터를 저장. 메모리 문제가 발생하지 않으나 해시 충돌이 생길 수 있음. 문제 #1. 완주하지 못한 선수(Lv.1)^ # sort 사용 // 정렬 후 비교해서 다른 순간이 완주하지 못한 참가자. // Ps. 문자는 `.sort()`로 오름차순 정렬 가능. function solution(participant, completion) { participant.sort(); completion.sort(); const idx = participant.findIndex((el, idx) =\u0026gt; el !== completion[idx]); return participant[idx]; } Map 사용 // participant에 있는 경우 +1, completion에 있는 경우 -1. function solution(participant, completion) { const map = new Map(); for (let i = 0; i \u0026lt; participant.length; i++) { const p = participant[i]; const c = completion[i]; map.set(p, (map.get(p) || 0) + 1); map.set(c, (map.get(c) || 0) - 1); } for (let [k, v] of map) { if (v \u0026gt; 0) return k; } } reduce, 쉼표 연산자 사용 // completion에 있는 경우 -1. function solution(participant, completion) { const pObj = participant.reduce( (acc, cur) =\u0026gt; ((acc[cur] = acc[cur] ? acc[cur] + 1 : 1), acc), {} ); completion.forEach((c) =\u0026gt; { pObj[c] -= 1; }); for (let key in pObj) { if (pObj[key] === 1) return key; } } 2. 위장(Lv.2)^ # Map 사용 // 옷 종류별로 개수 + 1(안입는 경우의 수) 전부 곱한 뒤, -1(아무것도 안입는 경우의 수)! function solution(clothes) { let cnt = 1; const map = new Map(); for (let c of clothes) { const type = c[1]; map.set(type, (map.get(type) || 0) + 1); } for (let [_, v] of map) { cnt *= v + 1; } return cnt - 1; } reduce 사용 function solution(clothes) { const cObj = clothes.reduce( (obj, _clothes) =\u0026gt; ( (obj[_clothes[1]] = obj[_clothes[1]] ? obj[_clothes[1]] + 1 : 1), obj ), {} ); let cnt = 1; for (let key in cObj) { cnt *= cObj[key] + 1; } return cnt - 1; } 3. 베스트앨범(Lv.3)^ # reduce 사용 function solution(genres, plays) { const infos = genres.map((genre, idx) =\u0026gt; ({ num: idx, genre: genre, play: plays[idx], })); // 1) 장르별 총 플레이 시간. const genrePlayObj = genres.reduce( (obj, genre, idx) =\u0026gt; ( (obj[genre] = obj[genre] ? obj[genre] + plays[idx] : plays[idx]), obj ), {} ); infos.map((info) =\u0026gt; { const genre = info.genre; const genrePlayObj = genrePlayObj[genre]; info.genre = genrePlayObj; }); // 2) 순서대로 정렬. infos.sort((a, b) =\u0026gt; b.play - a.play); infos.sort((a, b) =\u0026gt; b.genre - a.genre); // 3) 상위 2개만 앨범에 추가. const cnt = {}; const album = []; infos.forEach((info) =\u0026gt; { cnt[info.genre] = cnt[info.genre] ? cnt[info.genre] + 1 : 1; if (cnt[info.genre] \u0026lt; 3) { album.push(info.num); } }); return album; } function solution(genres, plays) { const genrePlayObj = genres.reduce( (acc, genre, idx) =\u0026gt; ( (acc[genre] = acc[genre] ? acc[genre] + plays[idx] : plays[idx]), acc ), {} ); const cnt = {}; const album = []; genres // 객체에 정보 담아서, .map((genre, idx) =\u0026gt; ({ genre, play: plays[idx], idx })) .sort((a, b) =\u0026gt; { // 다중 정렬. if (a.genre !== b.genre) { return genrePlayObj[b.genre] - genrePlayObj[a.genre]; } if (a.play !== b.play) { return b.play - a.play; } return a.idx - b.idx; }) // 상위 2개만 앨범에 포함. .filter((info) =\u0026gt; { cnt[info.genre] = cnt[info.genre] ? cnt[info.genre] + 1 : 1; if (cnt[info.genre] \u0026lt; 3) { album.push(info.idx); } }); return album; } forEach 사용 function solution(genres, plays) { const genrePlayObj = {}; genres.forEach((genre, idx) =\u0026gt; { genrePlayObj[genre] = genrePlayObj[genre] ? genrePlayObj[genre] + plays[idx] : plays[idx]; }); const genrePlayObj_cnt = {}; return genres .map((genre, idx) =\u0026gt; ({ genre: genre, play: plays[idx], num: idx })) .sort((a, b) =\u0026gt; { if (a.genre !== b.genre) { return genrePlayObj[b.genre] - genrePlayObj[a.genre]; } if (a.play !== b.play) { return b.play - a.play; } return a.num - b.num; }) .filter((genre) =\u0026gt; { if (genrePlayObj_cnt[genre.genre] \u0026gt;= 2) return false; genrePlayObj_cnt[genre.genre] = genrePlayObj_cnt[genre.genre] ? genrePlayObj_cnt[genre.genre] + 1 : 1; return true; }) .map((genre) =\u0026gt; genre.num); } My Tips #종류별로 정리 👍 # reduce const obj = arr1.reduce( (acc, cur, idx) =\u0026gt; ( (acc[cur] = acc[cur] ? acc[cur] + arr2[idx] : arr2[idx]), acc ), {} ); forEach const obj = {}; arr1.forEach((el, idx) =\u0026gt; { obj[el] = obj[el] ? obj[el] + arr2[idx] : arr2[idx]; }); Map const map = new Map(); for (let i = 0; i \u0026lt; arr1.length; i++) { map.set(arr1[i], (map.get(arr1[i]) || arr2[i]) + arr2[i]); } 고급 정렬 # 객체 정렬\n// 1) value arr.sort((a, b) =\u0026gt; a.value - b.value); // value값 기준 오름차순정렬. arr.sort((a, b) =\u0026gt; b.value - a.value); // value값 기준 내림차순정렬. // 2) key arr.map((el) =\u0026gt; Object.entries(el)); arr.sort((a, b) =\u0026gt; a[0] - b[0]); // key값 기준 오름차순정렬. arr.sort((a, b) =\u0026gt; b[0] - a[0]); // key값 기준 내림차순정렬. 다중 정렬\narr.sort((a, b) =\u0026gt; { if (a.type1 !== b.type1) { return b.type1 - a.type1; } if (a.type2 !== b.type2) { return b.type2 - a.type2; } return b.type3 - a.type3; }); /* lower performance arr.sort((a, b) =\u0026gt; b.type3 - a.type3) arr.sort((a, b) =\u0026gt; b.type2 - a.type2) arr.sort((a, b) =\u0026gt; b.type1 - a.type1) */ Ref. 프로그래머스 고득점 Kit - 해시 Ref. ratsgo\u0026rsquo;s blog - 해싱, 해시함수, 해시테이블\n","date":"2 May 2022","permalink":"/posts/algorithm/practice-kit/hash/","section":"Posts","summary":"Key-value쌍으로 데이터를 빠르게 찾아보세요.","title":"[Practice Kit] 해시(Hash)"},{"content":"React v18.0 #Intro #1월 초, 한참 퍼스트 프로젝트를 준비하면서 바쁜 와중 \u0026ldquo;노마드 코더\u0026quot;의 \u0026ldquo;완전 새로운 리액트가 온다? 핵심정리 10분컷\u0026rdquo; 영상을 보고 React 18에 처음 관심을 가졌다. 이때는 아직 프로젝트를 해본 적도 없어서 영상에서 좋다고 하니까 좋은 거구나 할 뿐이었다. (지금은 입력 지연이나 Loading의 반복 작성 등 문제를 직접 겪어본 후라 어떤 점이 좋은지 어느 정도 이해함.)\n이후로 하루에 한 번씩 공식 문서에 들어가서 출시 여부를 확인하고 틈틈이 구글에 \u0026ldquo;when react 18 release\u0026quot;를 검색했다. 사실 이 정도로 출시를 기다린 주된 이유는 \u0026ldquo;React 18의 특정한 기능을 사용해 보고 싶어서\u0026quot;는 아니었다.\n개발 공부를 하면서 \u0026ldquo;이 기능은 언제 새로 추가되었다.\u0026rdquo; (Ex. Arrow Function(ES6), React Hooks(v16.8)) 이런 글들을 볼 때마다, 새로운 기능이 추가되는 순간을 직접 경험해 보고 싶었다. 이것이 내가 React 18의 출시를 목 빠지게 기다린 주된 이유이다.\n이 문서는 React 18을 파이널 프로젝트 리팩토링에 활용하기 위해 공식 문서를 참조하여 공부하며 작성한 문서이다. 빨리 새로운 기능을 활용한 다음 \u0026ldquo;이 때 React 18이 출시 되었고, 이 프로젝트에 이 기능을 처음 사용 했었지!\u0026rdquo; 하는 나만의 추억을 만들고 싶다.\nWhat is Concurrent React? # 동시성(Concurrent)은 그 자체로 기능이 아니고 React가 동시에 여러 버전의 UI를 준비할 수 있도록 하는 새로운 배후 메커니즘. Concurrent React의 핵심 속성은 렌더링이 중단 가능한 것. 기존의 동기 렌더링(Synchronous rendering)은 일단 렌더링을 시작하면 사용자가 화면에서 결과를 볼 수 있을 때까지 업데이트를 중단할 수 없음. What’s New in React 18 #1. Automatic Batching^ # this is an in-depth feature that we don’t expect most users to need to think about. However, it may be relevant to educators and library developers. 일괄 처리는 더 나은 성능을 위해 React가 여러 상태 업데이트를 단일 리렌더링으로 그룹화하는 것. React 18 미만에서는 이벤트 헨들러 내부의 업데이트만 일괄 처리. React 18 부터는 promises, setTimeout, 이벤트 헨들러 또는 기타 이벤트 내부의 업데이트도 모두 자동 일괄 처리. ReactDOM.flushSync()를 사용해 일괄 처리 취소 가능. Example: // Before: only React events were batched. // After: updates inside of timeouts, promises, native event handlers or any other event are batched. setTimeout(() =\u0026gt; { setCount((c) =\u0026gt; c + 1); setFlag((f) =\u0026gt; !f); // Before: React will render twice, once for each state update (no batching) // After: React will only re-render once at the end (that\u0026#39;s batching!) }, 1000); 2. Transitions^ # 전환은 긴급한 업데이트와 긴급하지 않은 업데이트를 구분하기 위한 React의 새로운 개념.\n긴급하지 않은 업데이트 중에 긴급한 업데이트가 일어나면 긴급하지 않은 업데이트 중지 후 긴급한 업데이트 우선 처리. (후에 중지 되었던 업데이트는 최신 업데이트만 렌더링.)\n예를 들어 목록에서 필터를 클릭할 때 클릭된 필터의 변경은 긴급한 업데이트, 필터가 적용된 목록의 변경 긴급하지 않은 업데이트. 필터를 연속 클릭하면 목록의 변경은 중지되고 마지막 필터가 적용된 최신 목록만 렌더링.\nReact.startTransition\nReact.startTransition(callback); React.useTransition\nconst [isPending, startTransition] = useTransition(); Example:\nfunction App() { const [isPending, startTransition] = useTransition(); const [count, setCount] = useState(0); function handleClick() { startTransition(() =\u0026gt; { setCount((c) =\u0026gt; c + 1); }); } return ( \u0026lt;div\u0026gt; {isPending \u0026amp;\u0026amp; \u0026lt;Spinner /\u0026gt;} \u0026lt;button onClick={handleClick}\u0026gt;{count}\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 3. Suspense^ # Suspense는 React 프로그래밍 모델에서 UI 로딩 상태를 일급 선언적 개념으로 만듦.\nReact 18에서는 Suspense에 대한 서버의 지원을 추가하고 동시 렌더링(Concurrent rendering)을 사용하여 기능을 확장.\nReact 18의 Suspense는 Transition API와 결합 시 가장 잘 작동. 업데이트 일시 중단 시 콘텐츠가 대체 항목으로 대체되는 것을 방지하고 충분한 데이터가 로드될 때까지 렌더링을 지연.\nExample:\nconst [isPending, startTransition] = useTransition(); function handleClick() { startTransition(() =\u0026gt; { setTab(\u0026#34;comments\u0026#34;); }); } \u0026lt;Suspense fallback={\u0026lt;Spinner /\u0026gt;}\u0026gt; \u0026lt;div style={{ opacity: isPending ? 0.8 : 1 }}\u0026gt; {tab === \u0026#34;photos\u0026#34; ? \u0026lt;Photos /\u0026gt; : \u0026lt;Comments /\u0026gt;} \u0026lt;/div\u0026gt; \u0026lt;/Suspense\u0026gt;; 4. Rendering APIs #React DOM Client^ # react-dom/client:\ncreateRoot: 루트를 만드는 새로운 방법. ReactDOM.render 대신 사용. hydrateRoot: 서버 렌더링 응용 프로그램을 hydrate 하는 새로운 방법. 새로운 React DOM Server API와 함께 ReactDOM.hydrate 대신 사용. *hydrate란? Server에서 렌더링 된 HTML 코드를 Client에서 JS 코드와 매칭 시키는 것.\n*createRoot와 hydrateRoot 모두 \u0026ldquo;렌더링 중 오류에서 복구\u0026rdquo; 또는 \u0026ldquo;로깅을 위한 수화\u0026rdquo; 시 알림을 받기를 원하는 경우 onRecoverableError라는 새로운 옵션을 허용.\nReact DOM Server^ # react-dom/server:\nrenderToPipeableStream: Node 환경용. renderToReadableStream: Deno와 Cloudflare workers 같은 최신 Edge runtime 환경용. *기존 renderToString은 작동하지만 권장하지 않음.\n5. Strict Mode^ # React 18 미만: 구성 요소를 마운트하고 효과를 생성. React 18: 구성 요소를 마운트하고 효과를 생성한 뒤 구성 요소의 마운트 해제 및 리마운트를 시뮬레이션. 6. Hooks #useId^ #const id = useId(); useId로 수화 불일치를 피하면서 서버와 클라이언트에서 안정적인 고유 ID를 생성. Example: function NameFields() { const id = useId(); return ( \u0026lt;div\u0026gt; \u0026lt;label htmlFor={id}\u0026gt;Do you like React?\u0026lt;/label\u0026gt; \u0026lt;input id={id} type=\u0026#34;checkbox\u0026#34; name=\u0026#34;react\u0026#34; /\u0026gt; \u0026lt;label htmlFor={id + \u0026#34;-firstName\u0026#34;}\u0026gt;First Name\u0026lt;/label\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input id={id + \u0026#34;-firstName\u0026#34;} type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;label htmlFor={id + \u0026#34;-lastName\u0026#34;}\u0026gt;Last Name\u0026lt;/label\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input id={id + \u0026#34;-lastName\u0026#34;} type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } useTransition^ #const [isPending, startTransition] = useTransition(); *앞선 Transitions에서 설명.\nuseDeferredValue^ #const deferredValue = useDeferredValue(value); useDeferredValue로 트리의 긴급하지 않은 부분 렌더링 연기 가능.\nDebouncing 또는 Throttling을 사용하여 업데이트를 연기하는 user-space hooks와 유사하나 몇 가지 장점이 있음.\n고정된 시간 지연이 없어 우선되는 렌더링이 반영된 직후 지연된 렌더링 시도. 지연된 렌더링은 중단 가능하며 사용자 입력을 차단하지 않음. 값을 setState로 제어할 수 없을 때 유용. (다른 경우는 Transitions 권장.)\nuseDeferredValue는 전달한 값만 연기. 즉, 긴급 업데이트 중 자식 구성 요소의 리렌더링을 방지하려면 해당 구성 요소를 React.memo 또는 React.useMemo로 메모해야 함.\nExample:\nfunction Typeahead() { const query = useSearchQuery(\u0026#34;\u0026#34;); const deferredQuery = useDeferredValue(query); // Memoizing tells React to only re-render when deferredQuery changes, // not when query changes. const suggestions = useMemo( () =\u0026gt; \u0026lt;SearchSuggestions query={deferredQuery} /\u0026gt;, [deferredQuery] ); return ( \u0026lt;\u0026gt; \u0026lt;SearchInput query={query} /\u0026gt; \u0026lt;Suspense fallback=\u0026#34;Loading results...\u0026#34;\u0026gt;{suggestions}\u0026lt;/Suspense\u0026gt; \u0026lt;/\u0026gt; ); } useSyncExternalStore^ # useSyncExternalStore는 외부 저장소가 업데이트를 동기적으로 강제하여 동시 읽기를 지원하는 새로운 Hook. useSyncExternalStore is intended to be used by libraries, not application code. useInsertionEffect^ # useInsertionEffect는 CSS-in-JS 라이브러리가 렌더링 중에 스타일을 삽입할 때 생기는 성능 문제를 해결하는 새로운 Hook. DOM이 변경된 후에 실행되지만 기존 레이아웃이 영향을 미치기 전에 새 레이아웃을 읽음. useInsertionEffect is intended to be used by libraries, not application code. Ps. React Blog: How to Upgrade to React 18\nPs. React Blog: React Conf 2021 Recap\nPs. Youtube: 완전 새로운 리액트가 온다? 핵심정리 10분컷\nPs. Youtube: useTransition vs useDeferredValue | React 18\nRef. React Blog: React v18.0\n","date":"18 April 2022","permalink":"/posts/studies/react/react/v18.0/","section":"Posts","summary":"React v18.","title":"[React] React v18.0"},{"content":"CREATE YOUR FIRST APP #4. Pre-rendering and Data Fetching # Static-site Generation(SSG) is the pre-rendering method that generates the HTML at build time. The pre-rendered HTML is then reused on each request. Server-side Rendering(SSR) is the pre-rendering method that generates the HTML on each request. We recommend using SSG whenever possible because your page can be built once and served by CDN, which makes it much faster than having a server render the page on every request. If your page shows frequently updated data, and the page content changes on every request, you can use SSR. It will be slower, but the pre-rendered page will always be up-to-date. Or you can skip pre-rendering and use CSR to populate frequently updated data. getStaticProps^ #export default function Home(props) { ... } export async function getStaticProps() { // Get external data from the file system, API, DB, etc. const data = ... // The value of the `props` key will be // passed to the `Home` component return { props: ... } } Create posts/test1.md\n--- title: \u0026#34;Test1\u0026#34; date: \u0026#34;2020-01-01\u0026#34; --- Lorem ipsum dolor sit amet. Create posts/test2.md\n--- title: \u0026#34;Test2\u0026#34; date: \u0026#34;2020-01-02\u0026#34; --- sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. *Each markdown file has a metadata section at the top containing title and date. This is called YAML Front Matter, which can be parsed using a library called gray-matter.\nnpm install gray-matter Create lib/posts.js\nimport fs from \u0026#34;fs\u0026#34;; import path from \u0026#34;path\u0026#34;; import matter from \u0026#34;gray-matter\u0026#34;; const postsDirectory = path.join(process.cwd(), \u0026#34;posts\u0026#34;); export function getSortedPostsData() { // Get file names under /posts const fileNames = fs.readdirSync(postsDirectory); const allPostsData = fileNames.map((fileName) =\u0026gt; { // Remove \u0026#34;.md\u0026#34; from file name to get id const id = fileName.replace(/\\.md$/, \u0026#34;\u0026#34;); // Read markdown file as string const fullPath = path.join(postsDirectory, fileName); const fileContents = fs.readFileSync(fullPath, \u0026#34;utf8\u0026#34;); // Use gray-matter to parse the post metadata section const matterResult = matter(fileContents); // Combine the data with the id return { id, ...matterResult.data, }; }); // Sort posts by date return allPostsData.sort(({ date: a }, { date: b }) =\u0026gt; { if (a \u0026lt; b) { return 1; } else if (a \u0026gt; b) { return -1; } else { return 0; } }); } *It\u0026rsquo;s usually convention to use lib or utils.\nUpdate pages/index.js\n... import { getSortedPostsData } from \u0026#34;../lib/posts\u0026#34;; export async function getStaticProps() { const allPostsData = getSortedPostsData(); return { props: { allPostsData, }, }; } export default function Home ({ allPostsData }) { return ( \u0026lt;Layout home\u0026gt; ... \u0026lt;section className={`${utilStyles.headingMd} ${utilStyles.padding1px}`}\u0026gt; \u0026lt;h2 className={utilStyles.headingLg}\u0026gt;Blog\u0026lt;/h2\u0026gt; \u0026lt;ul className={utilStyles.list}\u0026gt; {allPostsData.map(({ id, date, title }) =\u0026gt; ( \u0026lt;li className={utilStyles.listItem} key={id}\u0026gt; {title} \u0026lt;br /\u0026gt; {id} \u0026lt;br /\u0026gt; {date} \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/Layout\u0026gt; ); } getServerSideProps^ #export async function getServerSideProps(context) { return { props: { // props for your component }, }; } Because getServerSideProps is called at request time, its parameter (context) contains request specific parameters.\nYou should use getServerSideProps only if you need to pre-render a page whose data must be fetched at request time.\n5. Dynamic Routes^ #Create a page at /pages/posts/[id].js\nA React component to render this page getStaticPaths which returns an array of possible values for id getStaticProps which fetches necessary data for the post with id Update lib/posts.js\n... export function getAllPostIds() { const fileNames = fs.readdirSync(postsDirectory); return fileNames.map((fileName) =\u0026gt; { return { params: { id: fileName.replace(/\\.md$/, \u0026#34;\u0026#34;), }, }; }); } export function getPostData(id) { const fullPath = path.join(postsDirectory, `${id}.md`); const fileContents = fs.readFileSync(fullPath, \u0026#34;utf8\u0026#34;); // Use gray-matter to parse the post metadata section const matterResult = matter(fileContents); // Combine the data with the id return { id, ...matterResult.data, }; } *Important: Each object must have the params key and contain an object with the id key (because we’re using [id] in the file name). Otherwise, getStaticPaths will fail.\nCreate pages/posts/[id].js\nimport Layout from \u0026#34;../../components/layout\u0026#34;; import { getAllPostIds, getPostData } from \u0026#34;../../lib/posts\u0026#34;; export async function getStaticPaths() { const paths = getAllPostIds(); return { paths, fallback: false, }; } export async function getStaticProps({ params }) { const postData = getPostData(params.id); return { props: { postData, }, }; } export default function Post({ postData }) { return ( \u0026lt;Layout\u0026gt; {postData.title} \u0026lt;br /\u0026gt; {postData.id} \u0026lt;br /\u0026gt; {postData.date} \u0026lt;/Layout\u0026gt; ); } Render Markdown #npm install remark remark-html Update lib/posts.js\n... import { remark } from \u0026#39;remark\u0026#39; import html from \u0026#39;remark-html\u0026#39; ... export async function getPostData(id) { const fullPath = path.join(postsDirectory, `${id}.md`) const fileContents = fs.readFileSync(fullPath, \u0026#39;utf8\u0026#39;) // Use gray-matter to parse the post metadata section const matterResult = matter(fileContents) // Use remark to convert markdown into HTML string const processedContent = await remark() .use(html) .process(matterResult.content) const contentHtml = processedContent.toString() // Combine the data with the id and contentHtml return { id, contentHtml, ...matterResult.data } } Update pages/posts/[id].js\n... export async function getStaticProps({ params }) { const postData = await getPostData(params.id); return { props: { postData, }, }; } export default function Post({ postData }) { return ( \u0026lt;Layout\u0026gt; {postData.title} \u0026lt;br /\u0026gt; {postData.id} \u0026lt;br /\u0026gt; {postData.date} \u0026lt;br /\u0026gt; \u0026lt;div dangerouslySetInnerHTML={{ __html: postData.contentHtml }} /\u0026gt; \u0026lt;/Layout\u0026gt; ) } Polishing the Post Page # Adding title to the Post Page\nUpdate pages/posts/[id].js\n... import Head from \u0026#39;next/head\u0026#39; ... export default function Post({ postData }) { return ( \u0026lt;Layout\u0026gt; \u0026lt;Head\u0026gt; \u0026lt;title\u0026gt;{postData.title}\u0026lt;/title\u0026gt; \u0026lt;/Head\u0026gt; ... \u0026lt;/Layout\u0026gt; ) } Formatting the Date\nnpm install date-fns Create components/date.js\nimport { parseISO, format } from \u0026#34;date-fns\u0026#34;; export default function Date({ dateString }) { const date = parseISO(dateString); return \u0026lt;time dateTime={dateString}\u0026gt;{format(date, \u0026#34;LLLL d, yyyy\u0026#34;)}\u0026lt;/time\u0026gt;; } Update pages/posts/[id].js\n... import Date from \u0026#39;../../components/date\u0026#39; ... export default function Post({ postData }) { return ( \u0026lt;Layout\u0026gt; ... {/* Replace {postData.date} with this */} \u0026lt;Date dateString={postData.date} /\u0026gt; ... \u0026lt;/Layout\u0026gt; ) } Adding CSS\nUpdate pages/posts/[id].js\n... import utilStyles from \u0026#39;../../styles/utils.module.css\u0026#39; ... export default function Post({ postData }) { return ( \u0026lt;Layout\u0026gt; \u0026lt;Head\u0026gt; \u0026lt;title\u0026gt;{postData.title}\u0026lt;/title\u0026gt; \u0026lt;/Head\u0026gt; \u0026lt;article\u0026gt; \u0026lt;h1 className={utilStyles.headingXl}\u0026gt;{postData.title}\u0026lt;/h1\u0026gt; \u0026lt;div className={utilStyles.lightText}\u0026gt; \u0026lt;Date dateString={postData.date} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div dangerouslySetInnerHTML={{ __html: postData.contentHtml }} /\u0026gt; \u0026lt;/article\u0026gt; \u0026lt;/Layout\u0026gt; ) } Polishing the Index Page # Update pages/index.js\n... import Link from \u0026#39;next/link\u0026#39; import Date from \u0026#39;../components/date\u0026#39; ... export default function Home({ allPostsData }) { return ( ... {/* Replace \u0026lt;li\u0026gt;...\u0026lt;/li\u0026gt; with this */} \u0026lt;li className={utilStyles.listItem} key={id}\u0026gt; \u0026lt;Link href={`/posts/${id}`}\u0026gt; \u0026lt;a\u0026gt;{title}\u0026lt;/a\u0026gt; \u0026lt;/Link\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;small className={utilStyles.lightText}\u0026gt; \u0026lt;Date dateString={date} /\u0026gt; \u0026lt;/small\u0026gt; \u0026lt;/li\u0026gt; ... Dynamic Routes Details # Essential information of dynamic routes Fallback If fallback is false, then any paths not returned by getStaticPaths will result in a 404 page. If fallback is true, then the paths that have not been generated at build time will not result in a 404 page. Instead, Next.js will serve a “fallback” version of the page on the first request to such a path. If fallback is blocking, then new paths will be server-side rendered with getStaticProps, and cached for future requests so it only happens once per path. Catch-all Routes pages/posts/[...id].js matches /posts/a, but also /posts/a/b, /posts/a/b/c and so on. return [ { params: { // Statically Generates /posts/a/b/c id: [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;], }, }, //... ]; export async function getStaticProps({ params }) { // params.id will be like [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] } Router import { useRouter } from \u0026#34;next/router\u0026#34;; 404 Pages // pages/404.js export default function Custom404() { return \u0026lt;h1\u0026gt;404 - Page Not Found\u0026lt;/h1\u0026gt;; } 6. API Routes^ # Create pages/api/hello.js export default function handler(req, res) { res.status(200).json({ text: \u0026#34;Hello\u0026#34; }); } http://localhost:3000/api/hello Do Not Fetch an API Route from getStaticProps or getStaticPaths Because they run only on the server-side and will never run on the client-side. A Good Use Case: Handling Form Input A good use case for API Routes is handling form input. For example, you can create a form on your page and have it send a POST request to your API Route. You can then write code to directly save it to your database. The API Route code will not be part of your client bundle, so you can safely write server-side code. export default function handler(req, res) { const email = req.body.email; // Then save email to your database, etc... } Preview Mode Dynamic API Routes 7. Deploying Your Next.js App #Deploy to Vercel # Create a Github Repository git remote add origin git@github.com:YuchanJeong/nextjs-blog-sample.git git push -u origin main Create a Vercel Account Import your nextjs-blog-sample repository nextjs-blog-sample Next.js and Vercel^ # Default features: Pages that use Static Generation and assets (JS, CSS, images, fonts, etc) will automatically be served from the Vercel Edge Network, which is blazingly fast. Pages that use Server-Side Rendering and API routes will automatically become isolated Serverless Functions. This allows page rendering and API requests to scale infinitely. More features: Custom Domains: Once deployed on Vercel, you can assign a custom domain to your Next.js app. Take a look at our documentation here. Environment Variables: You can also set environment variables on Vercel. Take a look at our documentation here. You can then use those environment variables in your Next.js app. Automatic HTTPS: HTTPS is enabled by default (including custom domains) and doesn\u0026rsquo;t require extra configuration. We auto-renew SSL certificates. Preview Deployment for Every Push (Develop, Preview, Ship) #When you have a pull request open, Vercel automatically creates a preview deployment for that branch on every push. The preview URL will always point to the latest preview deployment.\nYou can share this preview URL with your collaborators and get immediate feedback.\nIf your preview deployment looks good, merge it to main. When you do this, Vercel automatically creates a production deployment.\nRef. https://nextjs.org/learn/basics/create-nextjs-app\n","date":"8 April 2022","permalink":"/posts/studies/react/next.js/lc-4/","section":"Posts","summary":"CREATE YOUR FIRST APP #4.","title":"[Next.js] Learn Course (4) - CREATE YOUR FIRST APP 2"},{"content":"CREATE YOUR FIRST APP #1. Create a Next.js App # Create a Next.js App\nnpx create-next-app nextjs-blog --use-npm --example \u0026#34;https://github.com/vercel/next-learn/tree/master/basics/learn-starter\u0026#34; *If it doesn’t work, please take a look at this page.\nRun the development server\ncd nextjs-blog npm run dev Editing the Home Page\npages/index.js 2. Navigate Between Pages #In Next.js, a page is a React Component exported from a file in the pages directory.\nPages are associated with a route based on their file name. For example, in development:\npages/index.js is associated with the / route. pages/posts/first-post.js is associated with the /posts/first-post route. Simply create a JS file under the pages directory, and the path to the file becomes the URL path.\npages/posts/first-post.js\nexport default function FirstPost() { return \u0026lt;h1\u0026gt;First Post\u0026lt;/h1\u0026gt;; } *The component can have any name, but you must export it as a default export.\nLink Component #In Next.js, you use the Link Component from next/link to wrap the \u0026lt;a\u0026gt; tag. \u0026lt;Link\u0026gt; allows you to do client-side navigation to a different page in the application. Client-side navigation means that the page transition happens using JavaScript, which is faster than the default navigation done by the browser(full refresh).\npages/index.js\nimport Link from \u0026#34;next/link\u0026#34;; \u0026lt;h1 className=\u0026#34;title\u0026#34;\u0026gt; Read{\u0026#34; \u0026#34;} \u0026lt;Link href=\u0026#34;/posts/first-post\u0026#34;\u0026gt; \u0026lt;a\u0026gt;this page!\u0026lt;/a\u0026gt; \u0026lt;/Link\u0026gt; \u0026lt;/h1\u0026gt; *{' '} adds an empty space, which is used to divide text over multiple lines.\npages/posts/first-post.js\nimport Link from \u0026#34;next/link\u0026#34;; export default function FirstPost() { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;First Post\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt; \u0026lt;Link href=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;a\u0026gt;Back to home\u0026lt;/a\u0026gt; \u0026lt;/Link\u0026gt; \u0026lt;/h2\u0026gt; \u0026lt;/\u0026gt; ); } *If you need to add attributes like, for example, className, add it to the a tag, not to the Link tag. Here’s an example.\n*You can learn more about the Link component in the API reference for next/link and routing in general in the routing documentation.\nCode splitting and prefetching #Next.js does code splitting automatically, so each page only loads what’s necessary for that page. Only loading the code for the page you request also means that pages become isolated. If a certain page throws an error, the rest of the application would still work.\nFurthermore, in a production build of Next.js, whenever Link components appear in the browser’s viewport, Next.js automatically prefetches the code for the linked page in the background. By the time you click the link, the code for the destination page will already be loaded in the background, and the page transition will be near-instant.\n3. Assets, Metadata, and CSS #Assets #Next.js can serve static assets, like images, under the top-level public directory. Files inside public can be referenced from the root of the application similar to pages.\nSave the picture as profile.jpg in the public/images directory.\nimport Image from \u0026#34;next/image\u0026#34;; // Image Component and Image Optimization const YourComponent = () =\u0026gt; ( \u0026lt;Image src=\u0026#34;/images/profile.jpg\u0026#34; // Route of the image file height={144} // Desired size with correct aspect ratio width={144} // Desired size with correct aspect ratio alt=\u0026#34;Your Name\u0026#34; /\u0026gt; ); *To learn more about Automatic Image Optimization, check out the documentation.\n*To learn more about the Image component, check out the API reference for next/image.\nMetadata # pages/index.js\nimport Head from \u0026#34;next/head\u0026#34;; \u0026lt;Head\u0026gt; \u0026lt;title\u0026gt;Create Next App\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;/favicon.ico\u0026#34; /\u0026gt; \u0026lt;/Head\u0026gt; *To learn more about the Head component, check out the API reference for next/head.\n*If you want to customize the \u0026lt;html\u0026gt; tag, for example to add the lang attribute, you can do so by creating a pages/\\_document.js file. Learn more in the custom Document documentation.\nThird-Party JavaScript #In addition to metadata, scripts that need to load and execute as soon as possible are usually added within the \u0026lt;head\u0026gt; of a page. Using a regular HTML \u0026lt;script\u0026gt; element, an external script would be added as follows:\npages/posts/first-post.js\nimport Script from \u0026#34;next/script\u0026#34;; \u0026lt;Script src=\u0026#34;https://connect.facebook.net/en_US/sdk.js\u0026#34; strategy=\u0026#34;lazyOnload\u0026#34; onLoad={() =\u0026gt; console.log(`script loaded correctly, window.FB has been populated`) } /\u0026gt; strategy controls when the third-party script should load. A value of lazyOnload tells Next.js to load this particular script lazily during browser idle time onLoad is used to run any JavaScript code immediately after the script has finished loading. In this example, we log a message to the console that mentions that the script has loaded correctly *To learn more about the Script component, check out the documentation.\nLayout Component # pages/posts/first-post.js\nimport Head from \u0026#34;next/head\u0026#34;; import Link from \u0026#34;next/link\u0026#34;; import Layout from \u0026#34;../../components/layout\u0026#34;; export default function FirstPost() { return ( \u0026lt;Layout\u0026gt; \u0026lt;Head\u0026gt; \u0026lt;title\u0026gt;First Post\u0026lt;/title\u0026gt; \u0026lt;/Head\u0026gt; \u0026lt;h1\u0026gt;First Post\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt; \u0026lt;Link href=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;a\u0026gt;Back to home\u0026lt;/a\u0026gt; \u0026lt;/Link\u0026gt; \u0026lt;/h2\u0026gt; \u0026lt;/Layout\u0026gt; ); } components/layout.module.css\n.container { max-width: 36rem; padding: 0 1rem; margin: 3rem auto 6rem; } components/layout.js\nimport styles from \u0026#34;./layout.module.css\u0026#34;; export default function Layout({ children }) { return \u0026lt;div className={styles.container}\u0026gt;{children}\u0026lt;/div\u0026gt;; } Global Styles # pages/_app.js\nimport \u0026#34;../styles/global.css\u0026#34;; export default function App({ Component, pageProps }) { return \u0026lt;Component {...pageProps} /\u0026gt;; } *You need to restart the development server when you add pages/_app.js.\nstyles/global.css\nhtml, body { padding: 0; margin: 0; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif; line-height: 1.6; font-size: 18px; } * { box-sizing: border-box; } a { color: #0070f3; text-decoration: none; } a:hover { text-decoration: underline; } img { max-width: 100%; display: block; } *Only inside pages/_app.js you can import global CSS files.\nPolishing Layout # Update components/layout.module.css\n.container { max-width: 36rem; padding: 0 1rem; margin: 3rem auto 6rem; } .header { display: flex; flex-direction: column; align-items: center; } .backToHome { margin: 3rem 0 0; } Create styles/utils.module.css\n.heading2Xl { font-size: 2.5rem; line-height: 1.2; font-weight: 800; letter-spacing: -0.05rem; margin: 1rem 0; } .headingXl { font-size: 2rem; line-height: 1.3; font-weight: 800; letter-spacing: -0.05rem; margin: 1rem 0; } .headingLg { font-size: 1.5rem; line-height: 1.4; margin: 1rem 0; } .headingMd { font-size: 1.2rem; line-height: 1.5; } .borderCircle { border-radius: 9999px; } .colorInherit { color: inherit; } .padding1px { padding-top: 1px; } .list { list-style: none; padding: 0; margin: 0; } .listItem { margin: 0 0 1.25rem; } .lightText { color: #666; } Update components/layout.js\nimport Head from \u0026#34;next/head\u0026#34;; import Image from \u0026#34;next/image\u0026#34;; import styles from \u0026#34;./layout.module.css\u0026#34;; import utilStyles from \u0026#34;../styles/utils.module.css\u0026#34;; import Link from \u0026#34;next/link\u0026#34;; const name = \u0026#34;Yuchan\u0026#34;; export const siteTitle = \u0026#34;Next.js Sample Website\u0026#34;; export default function Layout({ children, home }) { return ( \u0026lt;div className={styles.container}\u0026gt; \u0026lt;Head\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;/favicon.ico\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;Learn how to build a personal website using Next.js\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:image\u0026#34; content={`https://og-image.vercel.app/${encodeURI( siteTitle )}.png?theme=light\u0026amp;md=0\u0026amp;fontSize=75px\u0026amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg`} /\u0026gt; \u0026lt;meta name=\u0026#34;og:title\u0026#34; content={siteTitle} /\u0026gt; \u0026lt;meta name=\u0026#34;twitter:card\u0026#34; content=\u0026#34;summary_large_image\u0026#34; /\u0026gt; \u0026lt;/Head\u0026gt; \u0026lt;header className={styles.header}\u0026gt; {home ? ( \u0026lt;\u0026gt; \u0026lt;Image priority src=\u0026#34;/images/profile.jpg\u0026#34; className={utilStyles.borderCircle} height={144} width={144} alt={name} /\u0026gt; \u0026lt;h1 className={utilStyles.heading2Xl}\u0026gt;{name}\u0026lt;/h1\u0026gt; \u0026lt;/\u0026gt; ) : ( \u0026lt;\u0026gt; \u0026lt;Link href=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;a\u0026gt; \u0026lt;Image priority src=\u0026#34;/images/profile.jpg\u0026#34; className={utilStyles.borderCircle} height={108} width={108} alt={name} /\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/Link\u0026gt; \u0026lt;h2 className={utilStyles.headingLg}\u0026gt; \u0026lt;Link href=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;a className={utilStyles.colorInherit}\u0026gt;{name}\u0026lt;/a\u0026gt; \u0026lt;/Link\u0026gt; \u0026lt;/h2\u0026gt; \u0026lt;/\u0026gt; )} \u0026lt;/header\u0026gt; \u0026lt;main\u0026gt;{children}\u0026lt;/main\u0026gt; {!home \u0026amp;\u0026amp; ( \u0026lt;div className={styles.backToHome}\u0026gt; \u0026lt;Link href=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;a\u0026gt;← Back to home\u0026lt;/a\u0026gt; \u0026lt;/Link\u0026gt; \u0026lt;/div\u0026gt; )} \u0026lt;/div\u0026gt; ); } Update pages/index.js\nimport Head from \u0026#34;next/head\u0026#34;; import Layout, { siteTitle } from \u0026#34;../components/layout\u0026#34;; import utilStyles from \u0026#34;../styles/utils.module.css\u0026#34;; export default function Home() { return ( \u0026lt;Layout home\u0026gt; \u0026lt;Head\u0026gt; \u0026lt;title\u0026gt;{siteTitle}\u0026lt;/title\u0026gt; \u0026lt;/Head\u0026gt; \u0026lt;section className={utilStyles.headingMd}\u0026gt; \u0026lt;p\u0026gt;Hi! I\u0026#39;m Yuchan Jeong.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; (This is a sample website - you’ll be building a site like this on{\u0026#34; \u0026#34;} \u0026lt;a href=\u0026#34;https://nextjs.org/learn\u0026#34;\u0026gt;our Next.js tutorial\u0026lt;/a\u0026gt;.) \u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/Layout\u0026gt; ); } Ps. Styling Tips\nRef. https://nextjs.org/learn/basics/create-nextjs-app\n","date":"7 April 2022","permalink":"/posts/studies/react/next.js/lc-3/","section":"Posts","summary":"CREATE YOUR FIRST APP #1.","title":"[Next.js] Learn Course (3) - CREATE YOUR FIRST APP 1"},{"content":"How Next.js Works #0. Development and Production Environments #During development, you’re building and running the application on your local machine. Going to production is the process of making your application ready to be deployed and consumed by users.\nIn the development stage, Next.js optimizes for the developer and their experience building the application. It comes with features that aim to improve the Developer Experience such the TypeScript and ESLint integration, Fast Refresh, and more. In the production stage, Next.js optimizes for the end-users, and their experience using the application. It aims to transform the code to make it performant and accessible. Next.js handles much of these code transformations and underlying infrastructure to make it easier for your application to go to production.\nThis is made possible because Next.js has a compiler written in Rust, a low-level programming language, and SWC, a platform that can be used for compilation, minification, bundling, and more.\n1. What is Compiling? #Compiling refers to the process of taking code in one language and outputting it in another language or another version of that language.\nDeveloper code\nexport default function HomePage() { return \u0026lt;div\u0026gt;DX of the Future\u0026lt;/div\u0026gt;; } Compiled code\n\u0026#34;use strict\u0026#34;; Object defineProperty(exports, \u0026#34;__esModule\u0026#34;, { value: true }); exports.default = HomePage; function HomePage() { return /*#__PURE__*/React.createElement( \u0026#34;div\u0026#34;, null, \u0026#34;DX of the Future\u0026#34; ); } In Next.js, compilation happens during the development stage as you edit your code, and as part of the build step to prepare your application for production.\n2. What is Minifying? #Minification is the process of removing unnecessary code formatting and comments without changing the code’s functionality. The goal is to improve the application’s performance by decreasing file sizes.\nMinified code\n\u0026#34;use strict\u0026#34;;Object.defineProperty(exports,\u0026#34;__esModule\u0026#34;,{value:0});exports.default=HomePage;function HomePage(){return React.createElement(\u0026#34;div\u0026#34;,null,\u0026#34;DX of the Future\u0026#34;);} 3. What is Bundling? #Exporting and importing internal modules, as well as external third-party packages, creates a complex web of file dependencies.\nBundling is the process of resolving the web of dependencies and merging (or ‘packaging’) the files (or modules) into optimized bundles for the browser, with the goal of reducing the number of requests for files when a user visits a web page.\n4. What is Code Splitting? #Code-splitting is the process of splitting the application’s bundle into smaller chunks required by each entry point(URLs). The goal is to improve the application\u0026rsquo;s initial load time by only loading the code required to run that page.\nNext.js has built-in support for code splitting. Each file inside your pages/ directory will be automatically code split into its own JavaScript bundle during the build step.\n5. Build Time and Runtime # Build time (or build step) A series of steps that prepare your application code for production. Built files include: HTML files for statically generated pages JavaScript code for rendering pages on the server JavaScript code for making pages interactive on the client CSS files Runtime (or request time) The period of time when your application runs in response to a user’s request, after your application has been built and deployed. 6. Client and Server #In the context of web applications, the client refers to the browser on a user’s device that sends a request to a server for your application code. It then turns the response it receives from the server into an interface the user can interact with.\nServer refers to the computer in a data centre that stores your application code, receives requests from a client, does some computation, and sends back an appropriate response.\n7. What is Rendering? #There is an unavoidable unit of work to convert the code you write in React into the HTML representation of your UI. This process is called rendering.\nClient-Side Rendering (CSR) In a standard React application, the browser receives an empty HTML shell from the server along with the JavaScript instructions to construct the UI. The initial rendering work happens on the user\u0026rsquo;s device. Pre-Rendering Next.js pre-renders every page by default. Pre-rendering means the HTML is generated in advance, on a server, instead of having it all done by JavaScript on the user\u0026rsquo;s device. Server-Side Rendering (SSR) The HTML of the page is generated on a server for each request. The generated HTML, JSON data, and JavaScript instructions to make the page interactive are then sent to the client. On the client, the HTML is used to show a fast non-interactive page, while React uses the JSON data and JavaScript instructions to make components interactive (for example, attaching event handlers to a button). This process is called hydration. In Next.js, you can opt to server-side render pages by using getServerSideProps. React 18 and Next 12 introduce an alpha version of React server components. Server components are completely rendered on the server and do not require client-side JavaScript to render. In addition, server components allow developers to keep some logic on the server and only send the result of that logic to the client. This reduces the bundle size sent to the client and improves client-side rendering performance. Learn more about React server components here.\nStatic Site Generation (SSG) The HTML is generated on the server, but unlike server-side rendering, there is no server at runtime. Instead, content is generated once, at build time, when the application is deployed, and the HTML is stored in a CDN and re-used for each request. In Next.js, you can opt to statically generate pages by using getStaticProps. The beauty of Next.js is that you can choose the most appropriate rendering method for your use case on a page-by-page basis, whether that\u0026rsquo;s Static Site Generation, Server-side Rendering, or Client-Side Rendering. To learn more about which rendering method is right for your specific use case, see the data fetching docs.\n8. What is the Network? # Origin Servers The server refers to the main computer that stores and runs the original version of your application code. We use the term origin to distinguish this server from the other places application code can be distributed to, such as CDN servers and Edge servers. Content Delivery Network (CDN) CDNs store static content (such as HTML and image files) in multiple locations around the world and are placed between the client and the origin server. When a new request comes in, the closest CDN location to the user can respond with the cached result. This reduces the load on the origin because the computation doesn’t have to happen on each request. It also makes it faster for the user because the response comes from a location geographically closer to them. In Next.js, since pre-rendering can be done ahead of time, CDNs are well suited to store the static result of the work - making content delivery faster. The Edge The Edge is a generalized concept for the fringe (or edge) of the network, closest to the user. CDNs could be considered part of \u0026ldquo;the Edge\u0026rdquo; because they store static content at the fringe (edge) of the network. Similar to CDNs, Edge servers are distributed to multiple locations around the world. But unlike CDNs, which store static content, some Edge servers can run code. By running code at the Edge, you can move some of the work that was traditionally done client-side or server-side to the Edge. This can make your application more performant. In Next.js, you can run code at the Edge with Middleware, and soon with React Server Components. Ref. https://nextjs.org/learn/foundations/how-nextjs-works\n","date":"6 April 2022","permalink":"/posts/studies/react/next.js/lc-2/","section":"Posts","summary":"How Next.","title":"[Next.js] Learn Course (2) - How Next.js Works"},{"content":"About Next.js #1. Building Blocks of a Web Application # 1 User Interface How users will consume and interact with your application. 2 Routing How users navigate between different parts of your application. 3 Data Fetching Where your data lives and how to get it. 4 Rendering When and where you render static or dynamic content. 5 Integrations What third-party services you use (CMS, auth, payments, etc) and how you connect to them. 6 Infrastructure Where you deploy, store, and run your application code (Serverless, CDN, Edge, etc). 7 Performance How to optimize your application for end-users. 8 Scalability How your application adapts as your team, data, and traffic grow. 9 Developer Experience Your team’s experience building and maintaining your application. *For each part of your application, you will need to decide whether you will build a solution yourself or use other tools such as libraries and frameworks.\n2. What is React? # React is a JavaScript library for building interactive user interfaces(UI).\nBy library, we mean React provides helpful functions to build UI, but leaves it up to the developer where to use those functions in their application.\n3. What is Next.js? # Next.js is a React framework that gives you building blocks to create web applications.\nBy framework, we mean Next.js handles the tooling and configuration needed for React, and provides additional structure, features, and optimizations for your application.\nFrom JavaScript to React #1. Rendering User Interfaces #When a user visits a web page, the server returns an HTML file to the browser. Then the browser reads the HTML and constructs the DOM.\nDocument Object Model (DOM)\nAn object representation of the HTML elements A bridge between your code and the user interface A tree-like structure with parent and child relationships Imperative vs Declarative Programming\nDOM Methods: An imperative Programming\nImperative programming is like giving a chef step-by-step instructions on how to make a pizza. Ex. \u0026ldquo;Knit the dough, roll the dough, add tomato sauce, add cheese, add ham, add pineapple, bake at 200 degrees celsius in a stone oven for\u0026hellip;” \u0026lt;!-- index.html --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // Select the div element with \u0026#39;app\u0026#39; id const app = document.getElementById(\u0026#34;app\u0026#34;); // Create a new H1 element const header = document.createElement(\u0026#34;h1\u0026#34;); // Create a new text node for the H1 element const headerContent = document.createTextNode( \u0026#34;Develop. Preview. Ship. 🚀\u0026#34; ); // Append the text to the H1 element header.appendChild(headerContent); // Place the H1 element inside the div app.appendChild(header); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; React: A declarative UI library\nDeclarative programming is like ordering a pizza without being concerned about the steps it takes to make the pizza. Ex. “A Hawaiian pizza please.” 2. Getting Started with React # react The core React library react-dom Provides DOM-specific methods that enable you to use React with the DOM \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/react@17/umd/react.development.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/react-dom@17/umd/react-dom.development.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- Babel Script --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/@babel/standalone/babel.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/jsx\u0026#34;\u0026gt; const app = document.getElementById(\u0026#39;app\u0026#39;); ReactDOM.render(\u0026lt;h1\u0026gt;Develop. Preview. Ship. 🚀\u0026lt;/h1\u0026gt;, app); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; You need a JavaScript compiler, such as a Babel, to transform your JSX code into regular JavaScript. React is a library that contains reusable snippets of code that perform tasks on your behalf - in this case, updating the UI. *If you’d like to learn more, take a look at the UI trees and the render method sections in the React Documentation.\n3. Building UI with Components #User interfaces(UI) can be broken down into smaller building blocks called components.\nconst app = document.getElementById(\u0026#34;app\u0026#34;); function Header() { return \u0026lt;h1\u0026gt;Develop. Preview. Ship. 🚀\u0026lt;/h1\u0026gt;; } function HomePage() { return ( \u0026lt;div\u0026gt; {/* Nesting the Header component */} \u0026lt;Header /\u0026gt; \u0026lt;/div\u0026gt; ); } // Capitalize the React Component ReactDOM.render(\u0026lt;HomePage /\u0026gt;, app); 4. Displaying Data with Props #Using props\n// function Header(props) { // return \u0026lt;h1\u0026gt;{props.title ? props.title : \u0026#34;Default title\u0026#34;}\u0026lt;/h1\u0026gt;; // } function Header({ title }) { return \u0026lt;h1\u0026gt;{title ? title : \u0026#34;Default title\u0026#34;}\u0026lt;/h1\u0026gt;; } function Page() { return ( \u0026lt;div\u0026gt; \u0026lt;Header title=\u0026#34;React 💙\u0026#34; /\u0026gt; \u0026lt;Header title=\u0026#34;A new title\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } Iterating through lists\nfunction HomePage() { const names = [\u0026#34;Ada Lovelace\u0026#34;, \u0026#34;Grace Hopper\u0026#34;, \u0026#34;Margaret Hamilton\u0026#34;]; return ( \u0026lt;div\u0026gt; \u0026lt;Header title=\u0026#34;Develop. Preview. Ship. 🚀\u0026#34; /\u0026gt; \u0026lt;ul\u0026gt; {names.map((name) =\u0026gt; ( \u0026lt;li key={name}\u0026gt;{name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } 5. Adding Interactivity with State #function HomePage() { const [likes, setLikes] = useState() function handleClick() { setLikes(likes + 1) }} return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Likes ({likes})\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } *If you’d like to learn more, take a look at the Adding Interactivity and Managing State sections in the React Documentation.\nFrom React to Next.js #npm install react react-dom next pages/index.jsx\nimport { useState } from \u0026#34;react\u0026#34;; function Header({ title }) { return \u0026lt;h1\u0026gt;{title ? title : \u0026#34;Default title\u0026#34;}\u0026lt;/h1\u0026gt;; } export default function HomePage() { const names = [\u0026#34;Ada Lovelace\u0026#34;, \u0026#34;Grace Hopper\u0026#34;, \u0026#34;Margaret Hamilton\u0026#34;]; const [likes, setLikes] = useState(0); function handleClick() { setLikes(likes + 1); } return ( \u0026lt;div\u0026gt; \u0026lt;Header title=\u0026#34;Develop. Preview. Ship. 🚀\u0026#34; /\u0026gt; \u0026lt;ul\u0026gt; {names.map((name) =\u0026gt; ( \u0026lt;li key={name}\u0026gt;{name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;Like ({likes})\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } package.json\n... \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;next dev\u0026#34; }, ... You removed the babel script, a taste of the complex tooling configuration you no longer have to think about.\nRef. https://nextjs.org/learn/foundations/about-nextjs\n","date":"5 April 2022","permalink":"/posts/studies/react/next.js/lc-1/","section":"Posts","summary":"About Next.","title":"[Next.js] Learn Course (1) - About Next.js"},{"content":"","date":null,"permalink":"/categories/bootcamp/","section":"Categories","summary":"","title":"\u003cBootcamp\u003e"},{"content":"*전체적인 회고는 따로 회고록에 작성\nDebate Ducks # Notion Github Demo 1. Socket.io^ #a. Init # Server\nconst options = { key: fs.readFileSync(__dirname + \u0026#34;/key.pem\u0026#34;, \u0026#34;utf-8\u0026#34;), cert: fs.readFileSync(__dirname + \u0026#34;/cert.pem\u0026#34;, \u0026#34;utf-8\u0026#34;), }; const https = require(\u0026#34;https\u0026#34;); const server = https.createServer(options, app); const { Server } = require(\u0026#34;socket.io\u0026#34;); // socket 서버를 따로 사용하지 않고, https 서버와 공유 const io = new Server(server, { cors: { origin: \u0026#34;*\u0026#34; } }); Client\nimport io from \u0026#34;socket.io-client\u0026#34;; import { useState, useEffect } from \u0026#34;react\u0026#34;; ... export default function DebateRoom() { const [socket, setSocket] = useState({}); useEffect(() =\u0026gt; { setSocket(io(`${process.env.REACT_APP_API_URL}`)); }, []); // 정보를 받아오기 전에는 로딩 페이지를 보여줌 return \u0026lt;div\u0026gt;{Object.keys(socket).length !== 0 ? \u0026lt;RealtimeDebate socket={socket} /\u0026gt; : \u0026lt;Loading /\u0026gt;}\u0026lt;/div\u0026gt;; } b. Enter # Server\n// 연결 시 액션 io.on(\u0026#34;connection\u0026#34;, (socket) =\u0026gt; { // 연결이 잠시라도 끊길 시 액션 (disconnect: 완전히 끊길 시 액션) socket.on(\u0026#34;disconnecting\u0026#34;, () =\u0026gt; { ... }); ... socket.on(\u0026#34;enter\u0026#34;, (data, done) =\u0026gt; { const userCount = io.sockets.adapter.rooms.get(data.debateId)?.size; // 이미 두 명 이상이 방에 있으면 입장 거절 if (userCount \u0026gt;= 2) { done(\u0026#34;rejected\u0026#34;); } else { socket.join(data.debateId); socket.to(data.debateId).emit(\u0026#34;guest_enter\u0026#34;); done(\u0026#34;fulfilled\u0026#34;); } }); }; Client\nsocket.emit(\u0026#34;enter\u0026#34;, { debateId }, (status) =\u0026gt; { switch (status) { case \u0026#34;rejected\u0026#34;: setIsExceedModalOn(true); setNotice({ ...notice, ...{ turn: \u0026#34;pre\u0026#34;, text: \u0026#34;Entry is not allowed. The room is currently full.\u0026#34; } }); break; case \u0026#34;fulfilled\u0026#34;: navigator.mediaDevices.getUserMedia({ video: true, audio: true }).then((stream) =\u0026gt; { setStream(stream); if (myVideoRef.current) { myVideoRef.current.srcObject = stream; } }); setNotice({ ...notice, ...{ turn: \u0026#34;pre\u0026#34;, text: \u0026#34;Waiting for another debater to join.\u0026#34; } }); break; } }); ... function disconnect() { myVideoRef?.current?.srcObject.getTracks().forEach((track) =\u0026gt; { track.stop(); }); peerVideoRef?.current?.srcObject?.getTracks().forEach((track) =\u0026gt; { track.stop(); }); myPeer?.current?.destroy(); socket.emit(\u0026#34;leave\u0026#34;, { debateId }); socket.disconnect(); } c. Connect #*simple-peer\n// \u0026lt;두 번째 사람 입장 시 첫 번째 사람에게 발생하는 액션\u0026gt; socket.on(\u0026#34;guest_enter\u0026#34;, () =\u0026gt; { setNotice({ ...notice, ...{ turn: \u0026#34;pre\u0026#34;, text: \u0026#34;To start the debate, press the start button in the upper right corner.\u0026#34; } }); // 사용자 미디어 획득 navigator.mediaDevices .getUserMedia({ video: true, audio: true }) .then((stream) =\u0026gt; { setStream(stream); setIsConnected(true); // Video 재생 if (myVideoRef.current) { myVideoRef.current.srcObject = stream; } // Peer 생성 const peer = new Peer({ // Host initiator: true, trickle: false, config: { iceServers: [ { url: \u0026#34;stun:stun.l.google.com:19302\u0026#34; }, { url: \u0026#34;stun:stun1.l.google.com:19302\u0026#34; }, { url: \u0026#34;stun:stun2.l.google.com:19302\u0026#34; }, { url: \u0026#34;stun:stun3.l.google.com:19302\u0026#34; }, { url: \u0026#34;stun:stun4.l.google.com:19302\u0026#34; }, { url: \u0026#34;stun:stun.nextcloud.com:443\u0026#34; }, ], }, // Stream 전달 stream, }); myPeer.current = peer; // Signal 발생 peer.on(\u0026#34;signal\u0026#34;, (signal) =\u0026gt; { socket.emit(\u0026#34;host_signal\u0026#34;, { debateId, signal }); }); // Stream 발생 peer.on(\u0026#34;stream\u0026#34;, (stream) =\u0026gt; { setPeerStream(stream); if (peerVideoRef.current) { peerVideoRef.current.srcObject = stream; } }); // Error 발생 peer.on(\u0026#34;error\u0026#34;, () =\u0026gt; { setIsConnected(false); setIsErrorModalOn(true); }); socket.on(\u0026#34;guest_signal\u0026#34;, (data) =\u0026gt; { // Signal 전달 peer.signal(data.signal); }); }) .catch(() =\u0026gt; { setIsConnected(false); setIsErrorModalOn(true); }); }); // \u0026lt;두 번째 사람 입장 시 두 번째 사람에게 발생하는 액션\u0026gt; socket.on(\u0026#34;host_signal\u0026#34;, (data) =\u0026gt; { setNotice({ ...notice, ...{ turn: \u0026#34;pre\u0026#34;, text: \u0026#34;To start the debate, press the start button in the upper right corner.\u0026#34; } }); navigator.mediaDevices .getUserMedia({ video: true, audio: true }) .then((stream) =\u0026gt; { setStream(stream); setIsConnected(true); if (myVideoRef.current) { myVideoRef.current.srcObject = stream; } const peer = new Peer({ // Guest initiator: false, trickle: false, stream, }); myPeer.current = peer; peer.on(\u0026#34;signal\u0026#34;, (signal) =\u0026gt; { socket.emit(\u0026#34;guest_signal\u0026#34;, { debateId, signal }); }); peer.on(\u0026#34;stream\u0026#34;, (stream) =\u0026gt; { setPeerStream(stream); if (peerVideoRef.current) { peerVideoRef.current.srcObject = stream; } }); peer.on(\u0026#34;error\u0026#34;, () =\u0026gt; { setIsConnected(false); setIsErrorModalOn(true); }); // Signal 전달 peer.signal(data.signal); }) .catch(() =\u0026gt; { setIsConnected(false); setIsErrorModalOn(true); }); } 2. Mute \u0026amp; Screen Share # Mute\nconst [isAudioMuted, setIsAudioMuted] = useState(false); const [isVideoMuted, setIsVideoMuted] = useState(false); function toggleMuteAudio(boolean) { if (stream) { setIsAudioMuted(boolean); stream.getAudioTracks()[0].enabled = !boolean; } } function toggleMuteVideo(boolean) { if (stream) { setIsVideoMuted(boolean); stream.getVideoTracks()[0].enabled = !boolean; } } Screen Share\nfunction shareScreen() { navigator.mediaDevices .getDisplayMedia({ cursor: true }) .then((screenStream) =\u0026gt; { // Screen Share On // 얻은 공유 화면 스트림의 비디오 트랙으로 기존 스트림의 비디오 트랙 대체 myPeer?.current?.replaceTrack( stream?.getVideoTracks()[0], screenStream?.getVideoTracks()[0], stream ); if (myVideoRef?.current) { // 비디오 스트림 대체 myVideoRef.current.srcObject = screenStream; if (isPro) { setIsProScreenOn(true); } else if (!isPro) { setIsConScreenOn(true); } socket.emit(\u0026#34;screen_on\u0026#34;, { debateId, isPro }); } // Screen Share Off // 기존 스트림의 비디오 트랙으로 공유 화면의 스트림의 비디오 트랙 대체 screenStream.getTracks()[0].onended = () =\u0026gt; { myPeer?.current?.replaceTrack( screenStream?.getVideoTracks()[0], stream?.getVideoTracks()[0], stream ); if (myVideoRef?.current) { // 비디오 스트림 대체 myVideoRef.current.srcObject = stream; if (isPro) { setIsProScreenOn(false); } else if (!isPro) { setIsConScreenOn(false); } socket.emit(\u0026#34;screen_off\u0026#34;, { debateId, isPro }); } }; }); } 3. Canvas^ # Video\nfunction drawVideo() { // Eraser : 이미 그려진 부분 지우기 const EraserCtx = canvasRef?.current?.getContext(\u0026#34;2d\u0026#34;); if (EraserCtx) { EraserCtx.fillStyle = \u0026#34;White\u0026#34;; EraserCtx.fillRect(0, 40, 1280, 620); } // Pro : 찬성 측 그릴 요소들 const proCtx = canvasRef?.current?.getContext(\u0026#34;2d\u0026#34;); if (proCtx) { proCtx.fillStyle = \u0026#34;#ff9425\u0026#34;; proCtx.fillRect(10, 90, 620, 470); } const proBgCtx = canvasRef?.current?.getContext(\u0026#34;2d\u0026#34;); if (proBgCtx) { proBgCtx.fillStyle = \u0026#34;White\u0026#34;; proBgCtx.fillRect(20, 580, 600, 60); } const proTextCtx = canvasRef?.current?.getContext(\u0026#34;2d\u0026#34;); if (proTextCtx) { proTextCtx.font = \u0026#34;32px poppins\u0026#34;; proTextCtx.fillStyle = \u0026#34;#ff9425\u0026#34;; proTextCtx.textAlign = \u0026#34;center\u0026#34;; proTextCtx.fillText(`${debateInfo.proName}`, 320, 620); } // Con : 반대 측 그릴 요소들 ... // Draw : 실제로 그리기 if (isPro) { canvasRef?.current?.getContext(\u0026#34;2d\u0026#34;).drawImage(myVideoRef?.current, 20, 100, 600, 450); canvasRef?.current?.getContext(\u0026#34;2d\u0026#34;).drawImage(peerVideoRef?.current, 660, 100, 600, 450); } else if (!isPro) { canvasRef?.current?.getContext(\u0026#34;2d\u0026#34;).drawImage(peerVideoRef?.current, 20, 100, 600, 450); canvasRef?.current?.getContext(\u0026#34;2d\u0026#34;).drawImage(myVideoRef?.current, 660, 100, 600, 450); } } Notice\nuseEffect(() =\u0026gt; { let color; switch (notice?.turn) { case \u0026#34;pre\u0026#34;: color = \u0026#34;black\u0026#34;; break; case \u0026#34;pro\u0026#34;: color = \u0026#34;#ff9425\u0026#34;; break; case \u0026#34;con\u0026#34;: color = \u0026#34;#6667ab\u0026#34;; break; } // Eraser const backgroundCtx = canvasRef?.current?.getContext(\u0026#34;2d\u0026#34;); if (backgroundCtx) { backgroundCtx.fillStyle = color; backgroundCtx.fillRect(0, 0, canvasRef?.current?.width, 40); } // Notice \u0026amp; Draw const noticeCtx = canvasRef?.current?.getContext(\u0026#34;2d\u0026#34;); if (noticeCtx) { noticeCtx.font = \u0026#34;18px poppins\u0026#34;; noticeCtx.fillStyle = \u0026#34;White\u0026#34;; noticeCtx.textAlign = \u0026#34;center\u0026#34;; if (notice?.turn === \u0026#34;pre\u0026#34;) { noticeCtx.fillText( `${notice?.text}`, canvasRef?.current?.width / 2, 25 ); } else if (notice?.turn === \u0026#34;pro\u0026#34; || notice?.turn === \u0026#34;con\u0026#34;) { noticeCtx.fillText( `${notice?.text} ( ${notice?.time} sec )`, canvasRef?.current?.width / 2, 25 ); } } }, [notice.text, notice.time]); 4. Record #const mergedAudioTracks = useRef({}); const canvasStream = useRef({}); const mergedStream = useRef({}); const mergedRecorder = useRef({}); const mergedBlobs = useRef([]); const mergedBlob = useRef({}); const mergedUrl = useRef(\u0026#34;\u0026#34;); // 토론 시작 socket.on(\u0026#34;debate_start\u0026#34;, () =\u0026gt; { // 캔버스 스트림 얻음 canvasStream.current = canvasRef?.current?.captureStream(); // 캔버스 스트림의 비디오 트랙과 합쳐진 오디오 트랙 합침 const mergeTracks = [ ...canvasStream.current.getVideoTracks(), ...mergedAudioTracks.current, ]; // 합쳐진 트랙에서 스트림 생성 mergedStream.current = new MediaStream(mergeTracks); // 레코더 생성 mergedRecorder.current = new MediaRecorder(mergedStream?.current, { mimeType: \u0026#34;video/webm\u0026#34;, }); // Blobs에 얻은 데이터들 추가하기 mergedRecorder.current.ondataavailable = (ev) =\u0026gt; { mergedBlobs.current = [...mergedBlobs.current, ev.data]; }; // 녹화 종료 시 액션 mergedRecorder.current.onstop = async () =\u0026gt; { // blobs의 요소들을 합친 새로운 스트림 생성 mergedBlob.current = new Blob(mergedBlobs?.current, { type: \u0026#34;video/webm\u0026#34; }); // 저장 가능한 url 생성 mergedUrl.current = window.URL.createObjectURL(mergedBlob?.current); // 저장 가능한 링크 aRef.current.href = mergedUrl?.current; const videoUrl = await saveVideo( mergedBlob?.current, `${debateInfo.title}_${debateId}` ); axios.patch( `${process.env.REACT_APP_API_URL}/debate/debate_room/${debateId}/video`, { videoUrl }, { withCredentials: true } ); }; // 60프레임으로 녹화 시작 mergedRecorder?.current?.start(1000 / 60); setNotice({ ...notice, ...{ turn: \u0026#34;pre\u0026#34;, text: `Topic : ${debateInfo.title}` }, }); setTimeout(() =\u0026gt; { setIsProTurn(true); setNotice({ ...notice, ...{ turn: \u0026#34;pre\u0026#34;, text: \u0026#34;The debate will begin soon with the opening remarks of the pro. ( 60 sec )\u0026#34;, }, }); }, 3000); setTimeout(() =\u0026gt; { socket.emit(\u0026#34;debate_opening_pro\u0026#34;, { debateId }); }, 6000); }); // 오디오 트랙 합침 useEffect(() =\u0026gt; { function mergeAudioTracks(myStream, peerStream) { const context = new AudioContext(); const destination = context.createMediaStreamDestination(); const source1 = context.createMediaStreamSource(myStream); const myStreamGain = context.createGain(); source1.connect(myStreamGain).connect(destination); const source2 = context.createMediaStreamSource(peerStream); const peerStreamGain = context.createGain(); source2.connect(peerStreamGain).connect(destination); return destination.stream.getAudioTracks(); } if (stream \u0026amp;\u0026amp; peerStream) { mergedAudioTracks.current = mergeAudioTracks(stream, peerStream); } }, [stream, peerStream]); Video Download\n// 녹화 영상 다운로드 function download() { aRef?.current?.click(); } return ( ... \u0026lt;a ref={aRef} download={`${debateInfo.title}_${debateId}`} /\u0026gt; ... ) Video Upload\nimport AWS from \u0026#34;aws-sdk\u0026#34;; export default async function saveVideo(file, fileName) { const s3 = new AWS.S3({ accessKeyId: process.env.REACT_APP_AWS_ACCESS_KEY, secretAccessKey: process.env.REACT_APP_AWS_SECRET_ACCESS_KEY, region: process.env.REACT_APP_AWS_REGION, }); const params = { Bucket: \u0026#34;debate-ducks-video\u0026#34;, Key: fileName, Body: file, ContentEncoding: \u0026#34;base64\u0026#34;, ContentType: \u0026#34;video/webm\u0026#34;, }; try { const result = await s3.upload(params).promise(); if (result.Location) { console.log(result.Location); return result.Location; } } catch (err) { console.log(err); } return null; } Ps. Problem Solving #a. Backspace \u0026amp; Reload # Problem\n뒤로 가기 후 앞으로 다시 왔을 때나 새로고침 후 20% 확률로 사용자가 서로 연결되지 않고 각자 연결만 기다림 Solving\n뒤로 가기는 작동하지 않게 막고 새로고침은 한 쪽의 연결이 끊겼을 때 다른 측의 연결도 끊어서 해결\n뒤로가기 방지 Hook\nimport { useEffect } from \u0026#34;react\u0026#34;; export default function usePrevent() { useEffect(() =\u0026gt; { const preventGoBack = () =\u0026gt; { history.pushState(null, \u0026#34;\u0026#34;, location.href); }; history.pushState(null, \u0026#34;\u0026#34;, location.href); window.addEventListener(\u0026#34;popstate\u0026#34;, preventGoBack); return () =\u0026gt; window.removeEventListener(\u0026#34;popstate\u0026#34;, preventGoBack); }, []); } b. Draw Video on Canvas # Problem 비디오를 캔버스에 그릴 때, 비디오가 사용자 뷰에서 벗어나면 더 이상 캔버스에 그려지지 않음 Solving 보이지 않는 비디오를 화면 가운데 고정해서 해결 \u0026lt;div className=\u0026#34;w-screen h-screen flex justify-center items-center fixed\u0026#34;\u0026gt; \u0026lt;video ref={myVideoRef} muted autoPlay playsInline width=\u0026#34;0\u0026#34; height=\u0026#34;0\u0026#34; \u0026gt;\u0026lt;/video\u0026gt; \u0026lt;video ref={peerVideoRef} autoPlay playsInline width=\u0026#34;0\u0026#34; height=\u0026#34;0\u0026#34; \u0026gt;\u0026lt;/video\u0026gt; \u0026lt;/div\u0026gt; c. Screen Share # Problem\n화면 공유 시 탭이나 앱을 공유할 경우 가로세로 비율이 달라서 캔버스에 적절한 비율로 그릴 수 없음 Solving\n가로와 세로 중 더 긴 거에 맞춰서 같은 비율로 조정하고, 조정 후 짧은 게 캔버스의 크기보다 클 경우 다시 비율에 맞게 조정\nfunction resize(video) { let width = 0; let height = 0; if (video.videoWidth \u0026gt;= video.videoHeight) { width = 1280; height = (1280 * video.videoHeight) / video.videoWidth; if (height \u0026gt; 620) { width = (1280 * 620) / height; height = 620; } } else if (video.videoWidth \u0026lt; video.videoHeight) { width = (620 * video.videoWidth) / video.videoHeight; height = 620; } return [width, height]; } d. Timer # Problem\n클라이언트에서 타이머를 사용할 경우 사용자 간에 1~2초의 차이가 있었음 Solving\n서버에서 타이머를 사용해서 해결\nServer\nlet isClear = false; function startTimer(data, sec, curAction, nextAction) { let time = sec; const timer = setInterval(() =\u0026gt; { if (isClear) { clearInterval(timer); } socket.to(data.debateId).emit(curAction, { time }); time--; if (time \u0026lt; 0) { clearInterval(timer); socket.to(data.debateId).emit(nextAction); } }, 1000); } ... socket.on(\u0026#34;debate_opening_pro\u0026#34;, (data) =\u0026gt; { startTimer(data, 60, \u0026#34;debate_opening_pro\u0026#34;, \u0026#34;debate_opening_con_pre\u0026#34;); }); socket.on(\u0026#34;debate_opening_con\u0026#34;, (data) =\u0026gt; { startTimer(data, 60, \u0026#34;debate_opening_con\u0026#34;, \u0026#34;debate_contention1_pro_pre\u0026#34;); }); ... Client\n... socket.on(\u0026#34;debate_opening_pro\u0026#34;, (data) =\u0026gt; { setNotice({ ...notice, ...{ turn: \u0026#34;pro\u0026#34;, text: \u0026#34;The opening remarks of the pro\u0026#34;, time: data.time } }); }); socket.on(\u0026#34;debate_opening_con_pre\u0026#34;, () =\u0026gt; { setIsProTurn(false); setNotice({ ...notice, ...{ turn: \u0026#34;pre\u0026#34;, text: \u0026#34;Next turn, the opening remarks of the con. ( 60 sec )\u0026#34; } }); setTimeout(() =\u0026gt; { socket.emit(\u0026#34;debate_opening_con\u0026#34;, { debateId }); }, 3000); }); socket.on(\u0026#34;debate_opening_con\u0026#34;, (data) =\u0026gt; { setNotice({ ...notice, ...{ turn: \u0026#34;con\u0026#34;, text: \u0026#34;The opening remarks of the con\u0026#34;, time: data.time } }); }); ... e. Clear Interval # Problem\nsetInterval로 캔버스에 그림을 그린 후 clearInterval로 더 이상 그려지지 않게 할 때 clearInterval이 제대로 작동하지 않음 Solving\n재랜더링이 일어나지 않는 useRef와 메모리 누수를 막는 useCallback을 활용해서 해결\n*The Iceberg of React Hooks\n*Referencing Values with Refs\nInterval Hook\nimport { useRef, useCallback } from \u0026#34;react\u0026#34;; export default function useSetInterval(callback, ms) { const intervalRef = useRef(null); const start = useCallback(() =\u0026gt; { if (intervalRef.current !== null) { return; } intervalRef.current = setInterval(() =\u0026gt; { callback(); }, ms); }, []); const stop = useCallback(() =\u0026gt; { if (intervalRef.current === null) { return; } clearInterval(intervalRef.current); intervalRef.current = null; }, []); return [start, stop]; } 리액트의 라이프 사이클과 재랜더링에 관해서 좀 더 많은 공부가 필요하다.\n","date":"21 March 2022","permalink":"/posts/bootcamp/bc-final-2/","section":"Posts","summary":"*전체적인 회고는 따로 회고록에 작성","title":"BC-Final / Final Project 기능 회고"},{"content":"*기능 관련 부분은 따로 기능 회고록에 작성\nDebate Ducks # Notion Github Demo 1. 사전 준비 #코로나와 수면 부족으로 인해 악화된 컨디션 회복을 최우선 목표로 설날 동안 푹 쉬었다.\n팀원들에게 물어본 결과 \u0026ldquo;완성도를 위해서 TypeScript, Next.js, React native, and Nest.js 등의 새로운 스택은 사용하지 말자\u0026quot;라는 의견이 다수결이어서 새로운 스택은 가능한 사용하지 않기로 했다. 그래서 아이디어 구상과 퍼스트 프로젝트를 뜯어보며 보완할 점을 찾는데 남는 시간을 모두 할애했다.\n2. 기획 단계 #퍼스트 프로젝트의 \u0026ldquo;지나친 협업으로 인한 비효율성\u0026quot;에서 교훈을 얻어 이번에는 각자 구체적인 아이디어를 준비 해오고 회의 시간에는 발표 및 토의만 진행했다.\n총 15개의 아이디어가 나왔고 토의 후 각자 의견과 별점(5점 만점)을 남기는 방식으로 효율적으로 아이디어들을 추렸다. 그 결과 8개의 아이디어가 추려졌고, 각자 해당 아이디어의 구현 방법을 다음날까지 찾아오기로 했다. 다른 팀원 아이디어들의 문제점은 전부 \u0026ldquo;데이터를 어디서 가져올 수 있느냐?\u0026ldquo;였고, 내 아이디어들의 문제점은 전부 \u0026ldquo;현재 우리 실력으로 구현할 수 있는가?\u0026ldquo;였다. 팀원들은 아이디어가 요구하는 정확한 데이터를 찾는데 실패하였고, 남은 4개의 내 아이디어들 중에서 최종 결정을 하게 되었다.\n4개의 아이디어 모두 구현 방법은 찾았으나 당장 우리 실력으로 기간 내에 구현 가능한지 아닌지 불투명할 정도로 난이도가 있었다. 긴 토의 끝에 \u0026ldquo;실시간 온라인 토론 플랫폼\u0026quot;이라는 내가 가장 하고 싶었던 아이디어가 채택되었다. (ps. 별점이 가장 높았던 아이디어는 아님)\n해당 아이디어를 낸 이유\n이미 Web으로만 하기로 한 시점에서 App보다 Web에 더 어울리는 아이디어를 고민했고, 자료를 공유해야 하는 토론은 Web에 더 어울린다고 생각함 일단 나 스스로가 초, 중, 고, 대학교 모두 토론 동아리에 들었을 정도로 토론을 좋아함 토론의 중요성은 모두가 알지만 학교를 벗어나면 말로 하는 토론을 할 수 있는 공간이 드묾 신기하게도 퍼스트 프로젝트와 파이널 프로젝트 모두 내 아이디어이고, 프로젝트의 이름은 모두 다른 팀원 한 분의 의견이 채택되었다. \u0026ldquo;Debate Ducks, 꽥꽥 되지 말고 논리적으로 이야기하자!\u0026rdquo; (ps. 사실 이름은 단순히 귀여워서 채택되었고 의미는 나중에 붙임 🤣🤣🤣)\n3. 설계 단계 #우선 어떤 페이지들이 필요하고 어떤 기능들을 하는지 간단히 사이트맵을 만들었다.\n그리고 이를 바탕으로 흐름도를 작성하였는데, 이 과정에서 최대한 자세하게 API와 동작 및 구성요소 하나하나까지 작성하기로 했다. 작은 흐름도에 모든 것을 적어 넣으려 하다 보니 우선 알아보기 너무 복잡하였고, 수정 사항이 하나 생길 때마다 배치 자체가 달라져야 해서 수정에 많은 시간이 들었다. 또한 모든 요소들의 디테일까지 설계하느라 많은 시간이 들었다.\n그래서 원래 첫째 주에 기획 및 설계를 끝내기로 계획하였으나 둘째 주 수요일이 되어서야 마칠 수 있었다. \u0026ldquo;기획 및 설계를 최대한 자세하게 하라!\u0026ldquo;라는 기본 원리에 잘못 매몰되어서 생긴 문제였다. 단기 프로젝트였던 만큼 필수 기능만 우선적으로 디테일하게 설계한 뒤 완성하고, 그다음 다시 추가 기능을 기획해야 했다. 하지만 완벽하게 기획 및 설계를 마친 뒤 코딩에 들어가겠다고 욕심을 부렸고, 결국은 퍼스트 때와 똑같은 실수를 반복했다.\n또한 모든 페이지의 디자인을 구현하다 보니 와이어 프레임도 막상 필요한 부분은 완성하지 못한 채로 코딩에 들어갔다.\n4. 구현 단계 #각자 퍼스트 프로젝트 때 맡았던 부분을 우선적으로 구현하기로 했다. 나는 우선 공통 로직들을 커스텀 훅과 유틸 함수로 작성한 뒤, 목록 불러오기, 필터링, 검색, 페이지 네이션 등의 프런트엔드 기초 로직들을 작성했다. 이번에는 실시간 통신이라는 새로운 기술을 배워서 적용해야 했기 때문에 스타일을 적용하는 부분들은 다른 팀원들에게 맡겼다.\n실시간 통신 부분은 우선 노마드 코더 Zoom 클론 코딩 강의를 통해 기본적인 개념을 익혔다. 그다음 공식 문서를 통해 Socket.io와 WebRTC에 대해 조금 더 상세하게 공부했다. 이 과정에서 기본 원리는 같으나 조금 더 간단하게 적용할 수 있는 simple-peer라는 라이브러리를 사용했다. 단순한 실시간 영상통화가 아닌 찬성·반대 측을 나누어야 하는 토론 기능을 구현할 때 peer1과 peer2로 쉽게 구분할 수 있는 점이 라이브러리 사용의 주된 이유였다. 마지막으로 해당 스택들이 적용된 프로젝트들을 10개 이상 하나씩 뜯어보면서 실제로 어떻게 프로젝트에 적용되는지를 파악했다.\n다음은 진행된 실시간 토론을 녹화해야 했는데 양측의 카메라, 공유 화면, 진행 단계 및 타이머 등을 원하는 형태로 배치해서 녹화하는 것이 쉽지 않았다. 스크린 녹화를 통해서는 비슷하게 구현할 수 있었지만, 사용자가 어떤 화면을 녹화할 시 선택하는 스크린 녹화는 동일한 퀄리티의 녹화 영상을 얻을 수 없었기에 선택하지 않았다.\nJavaScript에서 녹화 가능한 대상을 찾아보던 도중 Canvas 요소를 발견하였고, setInterval을 통해 Canvas에 양측의 카메라, 공유 화면, 진행 단계 및 타이머 등을 원하는 형태로 배치해서 그렸고, 이를 녹화한 뒤 양측의 미디어에서 사운드를 추출해서 합쳤다. 그 뒤 토론이 종료될 때 자동으로 aws-sdk를 통해 s3에 업로드되게 만들었으며, 사용자의 디바이스에도 저장 가능하게 만들었다.\n이 부분은 와이어 프레임이 작성되어 있지 않아서 개발과 스타일 작업을 병행했다. 그리고 원래 담당하기로 예정된 부분은 아니었지만 토론이 진행된 후 게시물에서 s3에 업로드 되어있는 비디오를 불러와 볼 수 있게 만들었으며, 투표 기능도 만들었다.\n5. 잘한 점 # 지식 공유\n개발 과정에서 내가 알고 있는 지식들을 최대한 팀원들과 공유하면서 팀 전체적인 실력이 올라갔다. 퍼스트 프로젝트 때는 팀원의 질문을 받았을 때 질문에 관해서만 알려줬는데, 파이널 프로젝트 때는 해당 부분을 알려줌과 동시에 내가 알고 있는 팁들을 최대한 알려주려고 노력했다. 특히 팀원들에게 \u0026ldquo;리액트에서 대부분의 간단한 로직은 삼항 연산자를 사용하면 된다\u0026quot;고 알려줬는데, 팀원들이 이 팁 이후로 리액트를 보는 눈이 달라졌다고 해주셔서 뿌듯했다.\n실력 좋은 팀원들이 나에게 코드 짜는 방향을 잡아줘서 도움이 많이 되었다.\n“리액트의 대부분은 삼항연산자” 라는 팀원분의 설명을 들은 날이 turning point가 된 날이라 생각한다. 그 설명을 듣고, ‘그렇다면 저는 이 아이콘을 누르면 이미 만들어놓은 모달을 띄우게 하고 싶은데 이러이러한 식으로 useState를 사용하면 될까요?’ / ‘useEffect를 이 경우에 이렇게 사용하는게 맞나요?’ 하는 알맞은 질문을 하며 개념을 천천히 정립해나갔다.\n*팀원 중 한분의 프로젝트 회고\n원리 파악\n새로운 기술을 배우고 적용하는 과정에서 공식 문서의 내용과 예제를 통해 익히고, 검색을 통해 에러를 해결하며, 해당 기술을 사용한 프로젝트들을 뜯어보며 어떻게 실제 프로젝트에서 적용되는지를 공부했다. 단순히 예제대로 적용하는데 그치지 않고 10개 이상의 프로젝트들을 뜯어보고 또 직접 수정해 보면서 작동 원리를 파악하기 위해 노력했다. 그 결과 기술에 맞춰서 기능을 개발하는 게 아니라 내가 필요한 기능을 해당 기술을 활용해 구현할 수 있었다.\n분업 및 공통 요소 파악\n팀적으로는 퍼스트 프로젝트 때 느낀 교훈을 바탕으로 분업을 적극적으로 도입하고, 공통 요소(공통 함수, 공통 컴포넌트, 공통 스타일 등)를 미리 파악한 뒤 우선적으로 개발해서 조금 더 효율적으로 작업할 수 있었다.\n*퍼스트 프로젝트때 잘한점인 집중, 도전 정신, 철저한 복습 및 추가학습 그리고 적극적인 의사소통은 그데로 유지했다.\n6. 아쉬운 점 및 개선방안 # 기획 및 설계에 과투자\n퍼스트 프로젝트와 마찬가지로 기획 및 설계에 너무 많은 시간을 사용했다. 퍼스트 프로젝트가 끝난 뒤 파이널 프로젝트에서는 그러지 않기로 팀원들과 다짐하였으나, 이후 \u0026ldquo;기획 및 설계는 최대한 자세하게 하라!\u0026ldquo;라는 기본 원리에 잘못 매몰되었다. 기획 및 설계를 최대한 자세하게 하되 기획 및 설계의 우선순위도 잘 설정했어야 했다. 하지만 우리는 구현의 우선순위만 신경 썼다. 앞으로는 기획 및 설계의 우선순위도 신경 쓸 것이다.\n또한 \u0026ldquo;나만 준비된 상태에서의 논의는 조금 독단적으로 결론이 날 수도 있다\u0026quot;에서 교훈을 얻어 의견 수렴 전에 팀원들에게 하루 이상 고민하고 준비할 시간을 주었는데, 이 때문에 오히려 의견 수렴에 너무 많은 시간이 소모되어 기획 및 설계 단계가 늘어지게 되었다. 앞으로는 준비가 필요한 논의와 아닌 논의를 잘 구분할 것이다.\n프로젝트 관리 실패\n개인적으로는 주어진 테스크를 모두 처리했고, 추가로 팀원도 어느 정도 도와줄 수 있어서 만족했다. 하지만 프로젝트를 전체적으로 조율하는 입장에서는 역할을 실패했다. (혼자 백 앤드를 담당한 팀장이 팀원 고충 처리 및 전체 일정 조율을 했고, 프런트 앤드 관련 업무는 관련 지식이 가장 많은 내가 자연스럽게 관리하게 됐다.)\n새로운 기술을 배우고 적용하는데 너무 많은 시간을 사용해서 전체적인 디테일을 신경 쓰면서 팀원들의 테스크를 관리할 시간이 부족했다. 앞으로는 전체적인 프로젝트 관리도 시간 계획에 포함함으로써 이 문제를 해결할 것이다.\nGithub 활용 부족\n팀원 간의 의사소통에 디스코드, 카카오톡, 줌 그리고 게더타운을 활용했다. 그러고 나니 프로젝트가 끝났을 때 우리의 의사소통 과정이 체계적으로 남아 있지 않았다. 앞으로는 Github의 이슈, 리뷰, 디스커션 등의 기능들을 더 적극적으로 활용해 의사소통 과정을 체계적으로 남길 것이다.\nTailwind CSS 커스텀 중복 이름\nTailwind CSS를 사용할 때 커스텀 값들을 따로 작성해서 사용했는데, 팀원들이 커스텀 값들을 추가하는 과정에서 기존 값들과 중복되는 이름을 사용해서 스타일 적용이 깨졌다. 일단 임의로 처리는 해 두었지만, 후에 커스텀 값의 이름을 유니크하게 만들고 스타일들을 하나하나 확인해서 다시 제대로 처리할 것이다.\n","date":"20 March 2022","permalink":"/posts/bootcamp/bc-final-1/","section":"Posts","summary":"*기능 관련 부분은 따로 기능 회고록에 작성","title":"BC-Final / Final Project 회고"},{"content":"*전체적인 회고는 따로 회고록에 작성\nHiBye #1. Custom Hooks \u0026amp; Utils #useDetectOutsideClick # 범위 밖을 클릭하면 닫히는 모달 import { useState, useEffect } from \u0026#34;react\u0026#34;; export default function useDetectOutsideClick(target, initialState) { const [isActive, setIsActive] = useState(initialState); useEffect(() =\u0026gt; { const onClick = (e) =\u0026gt; { if (target.current !== null \u0026amp;\u0026amp; !target.current.contains(e.target)) { setIsActive(!isActive); } }; if (isActive) { window.addEventListener(\u0026#34;click\u0026#34;, onClick); } return () =\u0026gt; { window.removeEventListener(\u0026#34;click\u0026#34;, onClick); }; }, [isActive, target]); return [isActive, setIsActive]; } const [isActive, setIsActive] = useDetectOutsideClick(refNavbar, false); const click = useCallback(() =\u0026gt; { setIsActive(!isActive); }, [isActive, setIsActive]); useQuery # 쿼리 값 불러오기 import { useLocation } from \u0026#34;react-router-dom\u0026#34;; import { useMemo } from \u0026#34;react\u0026#34;; export function useQuery() { const { search } = useLocation(); return useMemo(() =\u0026gt; new URLSearchParams(search), [search]); } const query = useQuery(); const queryPage = query.get(\u0026#34;page\u0026#34;); const querySearch = query.get(\u0026#34;search\u0026#34;) || \u0026#34;\u0026#34;; getByteLength # 바이트 계산 export default function getByteLength(s, b, i, c) { for (b = i = 0; (c = s.charCodeAt(i++)); b += c \u0026gt;\u0026gt; 11 ? 3 : c \u0026gt;\u0026gt; 7 ? 2 : 1); return b; } /* c에 s의 현재 위치(i)의 유니코드값을 charCodeAt() 함수를 사용해서 가져옴. 2048(2^11)로 나누었을 때 몫이 있으면 3바이트, 그보다 작은데 123(2^7)로 나누었을 때 몫이 있으면 2바이트, 나머지 경우에는 1바이트를 b에 할당. */ getByteLength(name); useBoardCheck # 유효한 게시판인지 확인 import { useSelector } from \u0026#34;react-redux\u0026#34;; export default function useBoardCheck(boardId) { const publicBoards = useSelector((state) =\u0026gt; state.publicBoards); const privateBoards = useSelector((state) =\u0026gt; state.privateBoards); // 처음에 undefined라서 초깃값을 따로 할당해서 length나 filter()를 사용 가능하게 만듦 const publicBoardsData = publicBoards.data.data || []; const privateBoardsData = privateBoards.data.data || []; const publicBoard = publicBoardsData.filter( (board) =\u0026gt; String(board.id) === boardId ); const privateBoard = privateBoardsData.filter( (board) =\u0026gt; String(board.id) === boardId ); const board = publicBoard.length !== 0 ? publicBoard[0] : privateBoard[0]; const isLoading = publicBoards.loading \u0026amp;\u0026amp; privateBoards.loading; return { board, isLoading }; } import { useParams } from \u0026#34;react-router-dom\u0026#34;; const boardId = useParams(); const { board, isLoading } = useBoardCheck(boardId); 2. Redux-toolkit #import { createAsyncThunk, createSlice } from \u0026#34;@reduxjs/toolkit\u0026#34;; import axios from \u0026#34;axios\u0026#34;; export const getPrivateBoards = createAsyncThunk( \u0026#34;privateBoards/getPrivateBoards\u0026#34;, async (couple_id) =\u0026gt; { const response = await axios.get( `${process.env.REACT_APP_API_URL}/boards/${couple_id}` ); return response.data; } ); const privateBoardsSlice = createSlice({ name: \u0026#34;privateBoardsSlice\u0026#34;, initialState: { loading: true, error: null, data: [], }, reducers: {}, extraReducers: (builder) =\u0026gt; { builder.addCase(getPrivateBoards.pending, (state) =\u0026gt; { state.loading = true; }); builder.addCase(getPrivateBoards.fulfilled, (state, action) =\u0026gt; { state.loading = false; state.data = action.payload; }); builder.addCase(getPrivateBoards.rejected, (state, action) =\u0026gt; { state.loading = false; state.error = action.error; }); }, }); export default privateBoardsSlice.reducer; import { createSlice } from \u0026#34;@reduxjs/toolkit\u0026#34;; const privateBoardEditModalSlice = createSlice({ name: \u0026#34;privateBoardEditModal\u0026#34;, initialState: { isOpen: false }, reducers: { openModal: (state) =\u0026gt; { state.isOpen = true; }, closeModal: (state) =\u0026gt; { state.isOpen = false; }, }, }); export default privateBoardEditModalSlice.reducer; export const { openModal, closeModal } = privateBoardEditModalSlice.actions; 3. Dynamic Routing #function App() { return ( \u0026lt;BrowserRouter\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Routes\u0026gt; \u0026lt;Route exact path=\u0026#34;/\u0026#34; element={\u0026lt;Main /\u0026gt;} /\u0026gt; \u0026lt;Route exact path=\u0026#34;/signin\u0026#34; element={\u0026lt;SignIn /\u0026gt;} /\u0026gt; \u0026lt;Route exact path=\u0026#34;/signup\u0026#34; element={\u0026lt;SignUp /\u0026gt;} /\u0026gt; \u0026lt;Route exact path=\u0026#34;/mypage\u0026#34; element={\u0026lt;MyPage /\u0026gt;} /\u0026gt; \u0026lt;Route exact path=\u0026#34;/post/:boardId/*\u0026#34; element={\u0026lt;PostBoard /\u0026gt;} /\u0026gt; \u0026lt;Route exact path=\u0026#34;/chat/:boardId\u0026#34; element={\u0026lt;ChatBoard /\u0026gt;} /\u0026gt; \u0026lt;Route exact path=\u0026#34;/todolist/:boardId\u0026#34; element={\u0026lt;TodolistBoard /\u0026gt;} /\u0026gt; \u0026lt;Route path=\u0026#34;*\u0026#34; element={\u0026lt;Error /\u0026gt;} /\u0026gt; \u0026lt;/Routes\u0026gt; \u0026lt;Footer className=\u0026#34;absolute z-40\u0026#34; /\u0026gt; \u0026lt;/BrowserRouter\u0026gt; ); } // \u0026#39;/post/:boardId/*\u0026#39; 부분 때문에 일일이 boardId를 checking 하는 과정이 필요했음 4. Header #D-day 계산 #let d_day = null; if (started_at) { const today = new Date(); const gap = started_at.getTime() - today.getTime(); d_day = Math.floor(gap / (1000 * 60 * 60 * 24)) * -1; } Navbar 토글 기능 #\u0026lt;GiHamburgerMenu className={`text-3xl absolute left-4 cursor-pointer hover:text-hibye-60 ${isActive ? \u0026#34;text-hibye-60\u0026#34; : \u0026#34;text-hibye-80\u0026#34;}`} onClick={click} /\u0026gt; \u0026lt;div ref={navRef} className=\u0026#34;absolute top-16\u0026#34;\u0026gt; {isActive ? \u0026lt;Navbar click={click} publicBoards={publicBoards} privateBoards={privateBoards} couple_id={couple_id} is_matching={is_matching} /\u0026gt; : null} \u0026lt;/div\u0026gt; 로그인 시 Logout과 MyPage 표시 #{ id ? ( \u0026lt;\u0026gt; {d_day ? ( \u0026lt;div className=\u0026#34;pt-1\u0026#34;\u0026gt; \u0026lt;span className=\u0026#34;text-hibye-60 text-base font-bold mr-1\u0026#34;\u0026gt;♡\u0026lt;/span\u0026gt; \u0026lt;span className=\u0026#34;text-hibye-60 text-base\u0026#34;\u0026gt;{d_day}\u0026lt;/span\u0026gt; \u0026lt;span className=\u0026#34;text-hibye-60 text-sm font-bold ml-1\u0026#34;\u0026gt;Days\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ) : null} \u0026lt;button className=\u0026#34;button--pink ml-6\u0026#34; onClick={signOut}\u0026gt; Sign Out \u0026lt;/button\u0026gt; \u0026lt;Link to=\u0026#34;./mypage\u0026#34; className=\u0026#34;button--pink ml-4\u0026#34;\u0026gt; My Page \u0026lt;/Link\u0026gt; \u0026lt;/\u0026gt; ) : ( \u0026lt;Link to=\u0026#34;./signin\u0026#34; className=\u0026#34;button--pink\u0026#34;\u0026gt; Sign In \u0026lt;/Link\u0026gt; ); } 5. Navbar #게시판 타입 별로 아이콘 선택 #const choseIcon = (category) =\u0026gt; { if (category === \u0026#34;post\u0026#34;) return \u0026lt;BsPencilSquare className=\u0026#34;inline mr-2 mb-1\u0026#34; /\u0026gt;; if (category === \u0026#34;chat\u0026#34;) { return ( \u0026lt;BsChatDots style={{ transform: \u0026#34;scaleX(-1)\u0026#34;, }} className=\u0026#34;inline mr-2 mb-1\u0026#34; /\u0026gt; ); } if (category === \u0026#34;todolist\u0026#34;) return \u0026lt;BsListUl className=\u0026#34;inline mr-2 mb-1\u0026#34; /\u0026gt;; }; 게시판 목록 불러오기 #{ boards.loading || boards.error ? ( \u0026lt;div className=\u0026#34;flex justify-center\u0026#34;\u0026gt; \u0026lt;Spinner /\u0026gt; \u0026lt;/div\u0026gt; ) : boards.data.data.length === 0 ? ( \u0026lt;div className=\u0026#34;border-hibye-60\u0026#34;\u0026gt;There is no board.\u0026lt;/div\u0026gt; ) : ( boards.data.data.map((board) =\u0026gt; ( \u0026lt;Link to={`/${board.category}/${board.id}?page=1\u0026amp;search=`} key={board.id} className=\u0026#34;mb-4 truncate block hover:text-hibye-80 duration-300\u0026#34; onClick={click} \u0026gt; {choseIcon(board.category)} {board.name} \u0026lt;/Link\u0026gt; )) ); } 6. PrivateBoardCreateModal #input 기본 상태관리 #const [name, setName] = useState(\u0026#34;\u0026#34;); const onChangeName = (e) =\u0026gt; { setName(e.target.value); }; // --- // \u0026lt;input type=\u0026#34;text\u0026#34; value={name} placeholder=\u0026#34;Enter board name\u0026#34; onChange={onChangeName} className={inputStyle} ref={refName} /\u0026gt;; 게시판 생성 시 유효성 검사 #const nameByte = getByteLength(name); if ( nameByte \u0026lt; 1 || nameByte \u0026gt; 36 || /\\s{2,}|^\\s|\\s$|[^\\w가-힣\\x20\\s]/g.test(name) ) { setValid((state) =\u0026gt; ({ ...state, isValid: false, reason: \u0026#34;name\u0026#34; })); refName.current.focus(); return; } 7. ChatBoard #Top 버튼 #const onClick = () =\u0026gt; { window.scrollTo({ top: 0, behavior: \u0026#34;smooth\u0026#34; }); }; const [ScrollY, setScrollY] = useState(0); const [isOverScrollY, setIsOverScrollY] = useState(false); const handleShowButton = () =\u0026gt; { setScrollY(window.pageYOffset); if (ScrollY \u0026gt; 100) { setIsOverScrollY(true); } else { setIsOverScrollY(false); } }; useEffect(() =\u0026gt; { const watch = () =\u0026gt; { window.addEventListener(\u0026#34;scroll\u0026#34;, handleShowButton); }; watch(); return () =\u0026gt; { window.removeEventListener(\u0026#34;scroll\u0026#34;, handleShowButton); }; }); // --- // { isOverScrollY ? \u0026lt;TopBtn /\u0026gt; : null; } 로딩 혹은 에러 #// 2초 이내에 데이터를 못 받아오면 Error로 간주 그 이전에는 Loading으로 간주 const [checkTwoSec, setCheckTwoSec] = useState(false); useEffect(() =\u0026gt; { setTimeout(() =\u0026gt; { setCheckTwoSec(true); }, 2000); }); // --- // {isLoading ? ( \u0026lt;div className=\u0026#34;w-screen h-screen flex justify-center items-center bg-hibye-10\u0026#34;\u0026gt; \u0026lt;Spinner /\u0026gt; \u0026lt;/div\u0026gt; ) : !board ? ( checkTwoSec ? ( \u0026lt;Error /\u0026gt; ) : ( \u0026lt;div className=\u0026#34;w-screen h-screen flex justify-center items-center bg-hibye-10\u0026#34;\u0026gt; \u0026lt;Spinner /\u0026gt; \u0026lt;/div\u0026gt; ) ) : (...) } 무한 스크롤 #import { useInView } from \u0026#34;react-intersection-observer\u0026#34;; const [refView, inView] = useInView({ threshold: 0.5, }); const [chats, setChats] = useState([]); const [page, setPage] = useState(1); const [lastPage, setLastPage] = useState(1); const [loading, setLoading] = useState(false); const getChats = useCallback(async () =\u0026gt; { setLoading(true); await axios .get(`${process.env.REACT_APP_API_URL}/posts/${boardId}?page=${page}`) .then((res) =\u0026gt; { setChats((state) =\u0026gt; [...state, ...res.data.data]); setLastPage(res.data.lastPage); }); setLoading(false); }, [page, boardId]); useEffect(() =\u0026gt; { if (page \u0026lt;= lastPage) getChats(); }, [getChats, page, lastPage]); useEffect(() =\u0026gt; { if (inView \u0026amp;\u0026amp; !loading) { setPage((state) =\u0026gt; state + 1); } }, [inView, loading]); // --- // \u0026lt;div className=\u0026#34;p-5\u0026#34;\u0026gt; \u0026lt;Chats chats={chats} user_id={user_id} /\u0026gt; \u0026lt;div ref={refView} className=\u0026#34;text-center mt-4\u0026#34;\u0026gt; {loading ? \u0026lt;Spinner /\u0026gt; : null} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;; 내용과 input창 전환 #{ edit.isEdit \u0026amp;\u0026amp; edit.post_id === post.id ? ( \u0026lt;\u0026gt; \u0026lt;input className=\u0026#34;w-full rounded-2xl border bg-gray-10 pl-3 pr-3 text-gray-80\u0026#34; type=\u0026#34;text\u0026#34; onChange={onChangeEditContents} placeholder=\u0026#34;Enter Chat here\u0026#34; value={editContents} ref={refInput} /\u0026gt; {valid.isValid ? null : ( \u0026lt;div className=\u0026#34;text-hibye-80 text-sm text-center mb-2 mt-2\u0026#34;\u0026gt; Invalid chat. Please check again. \u0026lt;/div\u0026gt; )} \u0026lt;/\u0026gt; ) : ( \u0026lt;div className=\u0026#34;text-xm text-gray-80\u0026#34;\u0026gt;{post.contents}\u0026lt;/div\u0026gt; ); } 8. PostBoard #Nested routing #\u0026lt;Routes\u0026gt; \u0026lt;Route exact path=\u0026#34;/\u0026#34; element={\u0026lt;PostBoardMain board={board} boardId={boardId} /\u0026gt;} /\u0026gt; \u0026lt;Route exact path=\u0026#34;/:postId\u0026#34; element={\u0026lt;Post /\u0026gt;} /\u0026gt; \u0026lt;/Routes\u0026gt; 게시물 목록 불러오기(페이지네이션) #import { useNavigate } from \u0026#34;react-router-dom\u0026#34;; import { useQuery } from \u0026#34;../utils/useQuery\u0026#34;; const navigate = useNavigate(); const query = useQuery(); const queryPage = query.get(\u0026#34;page\u0026#34;); const querySearch = query.get(\u0026#34;search\u0026#34;) || \u0026#34;\u0026#34;; const [posts, setPosts] = useState([]); const [page, setPage] = useState(1); const [lastPage, setLastPage] = useState(Number.MAX_SAFE_INTEGER); const getPosts = useCallback(async () =\u0026gt; { await axios .get(`${process.env.REACT_APP_API_URL}/posts/${boardId}?page=${queryPage}\u0026amp;search=${querySearch}`) .then((res) =\u0026gt; { setPosts(() =\u0026gt; [...res.data.data]); setLastPage(res.data.lastPage); }) .catch((err) =\u0026gt; { alert(err) }, [queryPage, boardId, querySearch]); useEffect(() =\u0026gt; { if (queryPage \u0026lt;= lastPage) { getPosts(); } }, [getPosts, queryPage, lastPage]); // 입력 후 enter를 했을 때, 숫자일 경우 해당 페이지로 이동 const onKeyPress = (e) =\u0026gt; { if (e.key === \u0026#34;Enter\u0026#34;) { const number = parseInt(e.target.value); if (!e.target.value) return; if (typeof number === \u0026#34;number\u0026#34;) { setPage(number); navigate(`/post/${boardId}?page=${number}\u0026amp;search=${querySearch}`); } } }; 검색 #const refSearch = useRef(null); const [search, setSearch] = useState(\u0026#34;\u0026#34;); const [inputSearch, setInputSearch] = useState(\u0026#34;\u0026#34;); const onChangeSearch = (e) =\u0026gt; { setInputSearch(e.target.value); }; const onKeyPressSearch = (e) =\u0026gt; { if (e.key === \u0026#34;Enter\u0026#34;) { if (e.target.value.length !== 0 \u0026amp;\u0026amp; e.target.value.length \u0026lt; 2) { swal.fire({ title: \u0026#34;Search failed\u0026#34;, text: \u0026#34;Please type more than 2 letters\u0026#34;, icon: \u0026#34;error\u0026#34;, confirmButtonColor: \u0026#34;#D70569\u0026#34;, }); return; } else { setSearch(e.target.value); setInputSearch(\u0026#34;\u0026#34;); setPage(1); setInputNum(1); navigate(`/post/${boardId}?page=${1}\u0026amp;search=${e.target.value}`); refSearch.current.blur(); } } }; const searchCancel = () =\u0026gt; { setSearch(\u0026#34;\u0026#34;); setInputSearch(\u0026#34;\u0026#34;); navigate(`/post/${boardId}?page=${1}\u0026amp;search=${\u0026#34;\u0026#34;}`); }; // --- // // 검색 버튼과 input 창을 겹쳐둬서 버튼에 호버하면 input 창이 배경색과 넓이를 가짐 \u0026lt;div className=\u0026#34;relative\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; ref={refSearch} onChange={onChangeSearch} onKeyPress={onKeyPressSearch} value={inputSearch} className=\u0026#34;absolute w-6 pl-2 text-transparent pr-2 bg-transparent duration-300 focus:bg-hibye-20 focus:w-40 focus:border-hibye-80 focus:text-hibye-100\u0026#34; /\u0026gt; \u0026lt;div className=\u0026#34;flex\u0026#34;\u0026gt; \u0026lt;SearchBtn className=\u0026#34;absolute\u0026#34; /\u0026gt; {search ? ( \u0026lt;div className=\u0026#34;flex items-center gap-1\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;ml-2 text-hibye-80\u0026#34;\u0026gt;{querySearch}\u0026lt;/div\u0026gt; \u0026lt;div onClick={searchCancel}\u0026gt; \u0026lt;CancelBtnSmall className=\u0026#34;self-center\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) : null} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;; 9. MyPage # 커플 맺기 전 커플 맺기 진행 중 커플 맺기 후 // 커플 맺기 단계별로 다양한 화면을 렌더링 해줘야 했음 \u0026lt;\u0026gt; {!userInfo.id ? ( \u0026lt;Navigate to=\u0026#34;/signin\u0026#34; /\u0026gt; ) : ( \u0026lt;div className=\u0026#34;bg-hibye-10\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;inner flex justify-center items-center\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;mt-24 mb-24 p-10\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;flex items-center mb-12\u0026#34;\u0026gt; {!isEditName ? ( \u0026lt;div className=\u0026#34;text-hibye-80 text-lg mr-3 font-bold\u0026#34;\u0026gt; {userInfo.username} \u0026lt;/div\u0026gt; ) : ( \u0026lt;input className=\u0026#34;self-center text-hibye-100 text-base rounded-2xl border bg-gray-10 pl-3 pr-3 w-56 mr-3\u0026#34; placeholder=\u0026#34;Enter username\u0026#34; ref={refUsername} value={inputUsername} onChange={changeUsernameInput} /\u0026gt; )} {!isEditName ? ( \u0026lt;div onClick={onEditName}\u0026gt; \u0026lt;EditBtn className=\u0026#34;self-center text-2xl text-hibye-80 hover:text-hibye-10 hover:bg-hibye-80 rounded-full cursor-pointer duration-300\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ) : ( \u0026lt;div className=\u0026#34;flex gap-1\u0026#34;\u0026gt; \u0026lt;div onClick={changeUsername}\u0026gt; \u0026lt;CheckBtn /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div onClick={offEditName}\u0026gt; \u0026lt;CancelBtn2 /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; )} \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;flex bb-12 mb-8\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;text-hibye-60 text-sm font-bold w-28 mr-8\u0026#34;\u0026gt; Email address \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;text-gray-80 text-sm\u0026#34;\u0026gt;{userInfo.email}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;flex mb-2\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;text-hibye-60 text-sm font-bold w-28 mr-8\u0026#34;\u0026gt; Lover \u0026lt;/div\u0026gt; {!userInfo.couple_id ? ( \u0026lt;\u0026gt; \u0026lt;input className=\u0026#34;text-hibye-100 text-sm rounded-2xl border bg-gray-10 pl-3 pr-3 mb-3 w-56\u0026#34; placeholder=\u0026#34;Enter username\u0026#34; onChange={changeLoverInput} value={inputLover} ref={refLover} /\u0026gt; \u0026lt;div onClick={addLover}\u0026gt; \u0026lt;FiArrowRightCircle className=\u0026#34;text-2xl text-hibye-80 hover:text-hibye-10 hover:bg-hibye-80 rounded-full cursor-pointer duration-300 ml-2\u0026#34; ref={refLover} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/\u0026gt; ) : !userInfo.is_matching ? ( \u0026lt;div className=\u0026#34;text-hibye-80 text-sm\u0026#34;\u0026gt; Please wait for reply. \u0026lt;/div\u0026gt; ) : ( \u0026lt;input type=\u0026#34;date\u0026#34; className=\u0026#34;text-hibye-100 text-sm rounded-2xl border bg-gray-10 pl-3 pr-3\u0026#34; placeholder=\u0026#34;YYYY-MM-DD\u0026#34; /\u0026gt; )} \u0026lt;/div\u0026gt; {isUsernameValid ? ( \u0026lt;div className=\u0026#34;mb-10\u0026#34; /\u0026gt; ) : ( \u0026lt;div className=\u0026#34;text-hibye-80 text-xs text-center mb-10\u0026#34;\u0026gt; Invalid username, Please check again. \u0026lt;/div\u0026gt; )} \u0026lt;div className=\u0026#34;text-gray-80 text-sm underline cursor-pointer w-max\u0026#34; onClick={changePassword} \u0026gt; Change password \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;text-gray-80 text-sm underline cursor-pointer w-max\u0026#34; onClick={deleteId} \u0026gt; Delete account \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; )} \u0026lt;/\u0026gt; Ps. 느낀점 # 중복 로직 혹은 스타일이 많았는데 이를 효율적으로 처리하지 못하고 반복 작성하였음 유저의 상태(로그인 여부, 커플 여부, 매칭 중 여부 등) 별로 다양한 화면을 렌더링 해줘야 했는데 이 상태를 어떻게 처리할지 깊이 고려하지 않았었음 쿼리의 사용이 미숙했음 한 컴포넌트에서 기능적인 부분과 디자인적인 부분을 같이 처리하다 보니 가독성이 떨어졌음(Container Component와 View Component 구분 고려) 주석을 좀 더 적극적으로 활용해서 보기 쉽게 만들 필요성을 느낌(어떤 부분이 어떤 기능을 하는지 구분이 잘 안 돼있음) 최적화를 고려하지 못했음(Profile 진행 후 memo, useCallback 등으로 처리해 주어야 함) 새로고침 후에도 지니고 있어야하는 상태와 아닌 상태를 구분하지 않았었음 안정성을 기본으로 효율성과 가독성도 고려하면서 코딩을 하자!\n","date":"3 February 2022","permalink":"/posts/bootcamp/bc-first-2/","section":"Posts","summary":"*전체적인 회고는 따로 회고록에 작성","title":"BC-First / First Project 기능 회고"},{"content":"*기능 관련 부분은 따로 기능 회고록에 작성\nHiBye # 1. 사전 준비 #프로젝트가 시작되기 전 개인 역량을 최대로 끌어올리기 위해 배웠던 내용들을 복습 및 정리하면서 프로젝트에 추가로 사용할 만한 스택들(Redux-toolkit, Redux-saga, GraphQL, Next.js, TypeScript 등)을 알아보고 공부하였다. 그리고 협업할 때 규칙을 지킬 수 있게 도와주는 관련 라이브러리들(EsLint, Prettier, Lint-staged, Husky)도 공부하고 사용해 봤다.\n이 경험을 바탕으로 팀원들에게 공식 문서와 내가 연습했던 내용들을 보여주며 각 스택들을 소개하였고, 필요 여부와 팀원들이 당장 사용 가능할지 여부 등의 의견을 수렴하였다. 팀의 주 의견은 First Project는 복습 위주로 새로운 스택은 사용하지 말자는 것이었다.\n하지만 나는 Prettier는 Git을 사용할 때 어떤 부분이 바뀌었는지 쉽게 확인하기 위해 필요하며 별도의 추가 학습 없이 초기에 설정만 해두면 사용이 가능하고, Redux-toolkit의 경우도 상태 관리를 위해 Redux를 사용할 것이라면 아주 조금의 추가 학습으로 더 쉽게 사용할 수 있다고(특히 비동기 처리 부분) 팀원들을 설득하였고, 그 결과 저 두 스택만 추가로 사용하기로 결정되었다.\n그리고 이 과정에서 팀원 중 한 분이 평소에 Tailwind CSS를 사용해 보고 싶었다고 하셨고, 일단은 사용해 본 사람이 아무도 없었기 때문에 판단은 보류되었다. 따로 공부하고 사용해 본 뒤 Tailwind CSS는 기본 CSS 지식만 있다면 쉽게 사용할 수 있다고 판단하였고, 클래스명을 따로 맞추고 정해야 하는 번거로움이 없어진다는 장점을 위주로 팀원들을 설득하여 Tailwind CSS도 사용하기로 결정되었다.\n2. 기획 단계 #기획 단계에서는 많은 기획들(개발 프로젝트 팀원 구하는 커뮤니티, 식단 관리 앱, 데이트 코스 공유, 공유 책갈피 등)이 나왔었고 활발히 의견을 주고받았다. 나는 모든 사용자가 볼 수 있는 공적인 게시판을 기본으로 커플의 경우 자신들만 볼 수 있는 사적 게시판(사용자가 원할 경우 공유 가능)을 제공받는 커플 커뮤니티를 만들어보자고 제안하였다.\n우선 이별 후에 페이스북이나 인스타그램등 SNS에 올린 전 애인 관련 게시물들을 일일이 삭제하거나 비공개 처리해야 하는데 이 커뮤니티를 활용하면 한 번에 편하게 처리 가능하다는 점이 많은 공감을 얻었다. 팀원들이 주로 설득된 부분은 기능들을 우리의 역량에 맞게 유동적으로 조절 가능하다는 점이었다. 기본 게시판 이외에 채팅, 투두 리스트, 공유 달력, 커플 심리 테스트, 지도 기반 데이트 코스 등 페이지 별로 다양한 기능들을 추가할 수 있으며 몇 개가 빠져도 전혀 이상하지 않다. 결국 내 의견이 채택되어 First Project로 커플 커뮤니티를 만들기로 했다.\n이후 논의 과정에서 이별 게시판도 따로 만들어서 사용자가 헤어진 뒤에도 계속 이용할 수 있게 하자는 의견이 나왔고 그 결과로 프로젝트의 이름이 Hibye가 되었다. 추가적인 논의 과정에서 이별이 강조되기 시작하였고, 나는 커뮤니티를 처음 사용하러 오는 사람은 커플일 것인데 이별이 너무 정면에 있는 것은 적절치 않은 것 같다고 팀원들을 설득하여 이별의 비중을 낮추었다. 개인적으로는 Hibye라는 이름도 조금 걸렸으나 마땅한 대안 제시에 실패하였고, Bye가 꼭 이별의 의미만 있는 건 아니라는 팀원들의 의견을 승낙하고 프로젝트의 구체적인 설계로 넘어갔다.\n3. 설계 단계 #우선 흐름도를 그리며 전체적인 흐름을 봤다. 그 후 요구사항 명세서도 작성하고 와이어 프레임도 작성하였다. 이 과정에서 카카오 오븐, 미로, 피그마 등 다양한 툴들을 사용해 보며 조금씩 달라지기는 하였으나 많은 부분을 중복 작성하게 되었고 시간을 낭비하였다.\n최후에는 피그마를 사용하기로 결정하고 정식으로 와이어 프레임과 데이터 베이스 설계도를 작성하였다. 그 후 컴포넌트 명과 어떤 기능을 하는지를 와이어 프레임에 자세히 표시하고 이를 바탕으로 기능 투두 리스트를 작성하고 디자인까지 입힌 프로토타입을 만들었다. 이 과정에서 디자이너 출신의 팀원분이 많은 역할을 하셨다.\n기능 투두 리스트는 페이지 혹은 컴포넌트 별로 필수 여부(필수, 권장, 도전)를 바탕으로 개발할 기능들을 나누었으며 예상 난이도를 표시하여 이후 태스크 카드를 만들 때 많은 도움이 되었다. 이 과정에서 내가 기능 투두 리스트는 개발을 하는 데 도움이 되게 개발자 친화적으로 작성하자고 설득하여 그리 작성하였으나 이후 사용자 친화적으로 작성해달라는 피드백을 받아서 사용자 친화적인 필수 개발 사항도 따로 작성하였다.\n4. 구현 및 발표 단계 #우리 팀은 작성된 태스크 카드를 바탕으로 각자 하고 싶은 작업을 그때그때 선택하여 작업하였다. 이때 기능 위주로 태스크를 나누지 않고 페이지 위주로 나눈 것이 First Project 최악의 실수였다. 작업 과정에서 나는 게시판 목록이나 게시물 목록 등은 직접 임시 서버를 만들어서 데이터를 받아와 테스트하였지만, 필요한 사용자 정보는 로그인 시 받아올 거라 다른 팀원이 로그인 페이지를 구현하기로 되어있었기 때문에 따로 서버를 통하지 않고 상태의 초깃값에 넣어서 테스트하였다.\n사용자 정보는 거의 모든 페이지에서 중요하게 사용되었지만 마지막 날 전까지 구현되지 않았다. 하지만 모두 마지막 날 전까지만 구현되면 된다고 생각하였고 다행히 마지막 날에는 구현이 되었다. 하지만 병합 후 최후의 테스트를 했을 때 문제가 생겼다. 새로 고침을 하면 상태에 저장된 사용자 정보가 모두 사라졌다. 가장 기초적인 부분을 놓쳤던 것이다. 그래서 급하게 로컬 저장소에 사용자 정보를 저장하는 방식으로 선회하여 임시로 해결하였다. 하지만 그 과정에서 잡다한 에러들이 발생하였고 급하게 해결하느라 고생하였다.\n또한 제일 중요한 기능이 커플을 맺는 기능인데 이 부분이 마지막 날까지 구현되지 않아서 내가 급하게 투입되었다. 그래서 나는 발표 준비를 하지 못하고 마지막 순간까지 개발을 하게 되었다. 그 결과 아이러니하게도 발표 녹화에는 마지막에 구현한 커플 맺는 기능 및 마이페이지 외에 내가 개발한 다른 페이지들은 포함되지 못하였다. 이번 프로젝트에서 개인적으로 가장 아쉬운 부분이다.\n5. 잘한 점 #우선 개인적으로 프로젝트 기간에 잠자는 시간 외에는 프로젝트에만 모든 시간을 할애하였다. 그 결과로 많은 업무를 처리하며 단기간에 실력 향상을 할 수 있었다. 그리고 필수 사항을 구현하는 것에 안주하지 않고 더 높은 단계의 사항들에 도전하여 구현하였고, 조금더 완성도 있는 결과물을 얻었다.\n또한 철저한 복습 및 추가 학습을 통해 프런트 부분에서 팀 내 가장 높은 이해도를 가질 수 있었다. 그 결과 프런트 전반을 주도하며 팀원이 모르는 부분을 알려주고 급하게 처리해야 할 문제 등을 나서서 해결할 수 있었다. 그리고 백 부분도 어느 정도의 이해도가 잡혀 있어서 백 앤드와의 적극적인 의사소통이 가능했다.\n팀적으로는 적극적인 의사소통(특히 모르는 것을 부끄럽게 생각하지 않고 적극적으로 물어봄)이 최고의 장점이었다. 그리고 사전에 프로토타입이 잘 만들어져있어서 스타일 작업을 하는 것이 매우 수월했다. Tailwind CSS의 사용은 최고의 수확이었다. 클래스명이 따로 필요 없고 직관적이라는 편의성에 팀원 전원이 매우 만족해서 Final Project 때도 사용할 예정이다.\n6. 아쉬운 점 및 개선방안 #우선 현재 해외라 새벽 세시(한국 시간 아침 여덟시)에 일어나야 해 매우 힘들었으며, 거기다 코로나까지 걸려서 체력적으로 매우 힘들었다(회의 때 기침을 너무 많이 해서 팀원분들께 죄송했다). 개발에 몰두하다 조금 늦게 자면 하루에 한두 시간 밖에 못 자서 프로젝트의 끝에 가까워질수록 점점 더 건강이 나빠졌다. 다행히 Final Project 전에 설이 있어서 건강 회복에 전념할 예정이다. 그리고 Final Project 때는 수면시간을 꼭 지켜서 컨디션 관리에 유의할 것이다.\n프로젝트의 방향성이나 스택의 사용 등에 있어서 설득의 과정이 있기는 했으나 조금 독단적이었던 것도 같다. 사전 준비를 나만 철저히 해왔기 때문에 팀원들이 완전한 이해 없이 내가 말하는 대로 그냥 이끌려간 느낌이 있다. 다음에는 찬반 의견을 좀 더 시간을 두고 수렴할 것이다.\n시간관리 측면에서도 내가 개발하기 위해 사용할 시간만 고려했는데 에러 해결이나 팀원의 이슈를 대신 처리하고 설명해 주는데 사용할 시간은 전혀 고려하지 않아서 갑작스러운 상황에서의 시간관리가 잘되지 않았다. 다음에는 시간 계획을 세울 때 조금 더 여유 있게 세워서 유연한 대처가 가능하게 할 것이다.\n또한 팀적으로도 개인적으로도 우선순위 분배가 잘되지 않았다. 다음에는 우선순위를 잘 분배해서 필수 항목들부터 빠르게 개발해가며 디테일들은 메모해 뒀다가 후 순위로 처리할 것이다.\n팀적으로는 우선 공통부분을 효율적으로 묶어서 처리하지 못한 부분이 아쉬웠다. 개발 시간을 줄여주는 것은 물론 유지 보수에도 큰 도움이 되기 때문에 다음에는 기획 단계에서 철저히 공통부분을 묶어서 높은 우선순위를 줄 것이다.\n그리고 너무 협업만 우선시하여 시간 낭비가 많았다. 특히 기획 단계에서 생각부터 같이해서 많은 시간을 낭비하였다. 다음에는 분업도 신경 써서 기획의 경우 각자 생각해와서 의견을 나누거나 결정을 내릴 때만 협업을 한다든지 하는 식으로 조금 더 효율적인 팀 운영을 할 것이다.\n","date":"1 February 2022","permalink":"/posts/bootcamp/bc-first-1/","section":"Posts","summary":"*기능 관련 부분은 따로 기능 회고록에 작성","title":"BC-First / First Project 회고"},{"content":" Section3 회고지만 First Project를 끝내고서야 작성할 수 있을 정도로 프로젝트에 온 힘을 쏟았었다. 특히 Section3 후반부 부터는 프로젝트 전에 나의 역량을 최대한 끌어올리기 위해 다양한 공부(특히 리액트와 관련된 추가 스택들)를 병행했다. Section3는 데이터베이스, 인증/보안, 배포에 관해서 배웠는데 확실히 나는 프런트 쪽이 더 적성에 맞는 거 같다. 데이터를 마음대로 주무르고 조회하는 과정은 흥미로웠으나 프런트에서 직접 작동하는 모습을 보는 것보다는 흥미가 떨어졌다. 그래도 데이터 베이스를 설계하는 부분은 프런트에서 직접 작동하는 모습을 보는 것만큼 흥미로웠다. section3에서 가장 흥미로웠던 부분은 인증/보안 부분이었다. 이제까지는 보안을 신경 쓰면서 코딩을 했던 적이 없었던 나로서는 신세계였다. 특히 토큰은 앞으로도 쭉 요긴하게 쓰일 것 같았다. 아직은 공부가 덜되어서 정확한 이해는 되지 않았지만 좀 더 이 부분을 공부하여 사용자가 안심하고 사용할 수 있는 앱이나 사이트를 개발하고 싶다. 배포 부분은 사실 가장 흥미가 떨어졌다. 클라우드 기반으로 환경에 상관없이 퍼포먼스를 유지할 수 있게 하는 부분은 흥미롭기는 하였으나 무엇인가를 직접 개발하는 것보다는 나에게 흥미롭지 않았다. (아마 DevOps 쪽으로 가는 일은 없을 것 같다.) 문제형 HA는 역시나 Toy-project(알고리즘 문제)보다 쉬워서 막힘없이 수월하게 풀 수 있었다. 과제형 HA는 인증/보안 부분이 나왔는데 처음에는 막막 하였으나 공부하고 정리했던 내용들을 하나하나 읽어보면서 어떤 원리로 작동하는지를 이해하니 그 다음부터는 생각보다 쉽게 풀어나갈 수 있었다. 과제형 HA는 프로젝트를 만드는데 있어서 많은 도움이 되었다. ","date":"29 January 2022","permalink":"/posts/bootcamp/bc-16w/","section":"Posts","summary":"Section3 회고지만 First Project를 끝내고서야 작성할 수 있을 정도로 프로젝트에 온 힘을 쏟았었다.","title":"BC-16w / Section3 및 HA 회고"},{"content":"1. Why Docker? # 컨테이너 방식으로 실행 환경에 구애받지 않고 애플리케이션을 실행할 수 있음 1) 의존성 충돌 문제 해결 # 각 컨테이너가 철저하게 실행 환경이 격리되어 있기 때문에 가능 각 컨테이너의 내용물 프로세스 특정 컨테이너에서 작동하는 프로세스는 기본적으로 그 컨테이너 안에서만 액세스할 수 있음 컨테이너 안에서 실행되는 프로세스는 다른 컨테이너의 프로세스에게 영향을 줄 수 없음 네트워크 기본으로 컨테이너 하나에 하나의 IP 주소가 할당 파일 시스템 컨테이너 안에서 사용되는 파일 시스템은 구획화되어 있음 해당 컨테이너에서의 명령이나 파일 등의 액세스를 제한할 수 있음 2) 개발과 배포 환경 일치 # Ex. ECS in AWS 3) 수평 확장 \u0026amp; 새로운 내용 배포 간편화 # 트래픽 분산을 위해 프록시 서버(로드 밸런서) 운영 실행 환경의 일치로 이를 쉽게 해줌 Etc. 용어 정리 # 컨테이너 애플리케이션이 의존성, 네트워크 환경, 파일 시스템에 구애받지 않고, 도커라는 기술 위에 실행될 수 있도록 만든 애플리케이션 상자 이미지 이미지는 애플리케이션 및 애플리케이션 구성을 함께 담아놓은 템플릿 이미지를 이용해 여러 개의 컨테이너를 생성(수평 확장) 이미지는 기본 이미지로부터 변경 사항을 추가/커밋해서 또 다른 이미지를 만들 수도 있음 Ex. Node.js 웹 앱의 도커라이징(컨테이너화) 레지스트리 이미지는 레지스트리에 저장 Ex. Docker Hub, Amazon ECR 2. Docker CLI (1) # Docker docs Registry_Account/Repository_Name:Tag 레지스트리(Registry) Ex. Docker Hub 도커 이미지를 관리하는 공간 레포지토리(Repository) 레지스트리 내에 도커 이미지가 저장되는 공간 이미지 이름이 사용되기도 함 태그(Tag) 해당 이미지를 설명하는 버전 정보를 주로 입력 특별히 다른 것을 지정하지 않는다면 latest 태그를 붙인 이미지를 가져옴 # 최신 이미지를 받아옴 docker image pull Registry_Account/Repository_Name:Tag # 이미지 리스트를 출력 docker image ls # 이미지 삭제 docker image rm 이미지_이름 | 6b362a9f73eb # 컨테이너_이름을 이름으로 갖는 컨테이너를 실행 docker container run --name 컨테이너_이름 Registry_Account/Repository_Name:Tag # 모든 컨테이너의 리스트를 출력 docker container ps -a # 컨테이너 삭제 docker container rm 컨테이너_이름 | CONTAINER ID # 컨테이너 실행 docker container run --name 컨테이너_이름 docker/whalesay:latest cowsay boo # OPTIONS # --name : 컨테이너의 이름을 할당 # COMMAND # cowsay : 컨테이너 실행 시 cowsay 명령어를 호출 # ARG... # boo : COMMAND인 cowsay에 넘겨질 파라미터 docker container run -it --rm danielkraic/asciiquarium:latest 3. Docker CLI (2) # 로컬에 있는 파일과 도커 이미지를 연결하는 방법 CP(Copy) : 호스트와 컨테이너 사이에 파일을 복사(Copy) Volume : 호스트와 컨테이너 사이에 공간을 마운트(Mount) A. httpd(http daemon) # Apache HTTP Server를 실행할 수 있는 오픈소스 웹 서버 소프트웨어 httpd는 /usr/local/apache2/htdocs/ 경로에 웹 서버와 관련된 파일들이 저장되어 있다면, 해당 파일을 기반으로 웹 서버가 실행되도록 함 git clone https://github.com/codestates/pacman-canvas docker container run --name 컨테이너_이름 -p 818:80 httpd # -p 옵션은 로컬호스트의 포트와 컨테이너의 포트를 연결 # 2의 명령어에서 818포트가 로컬호스트의 포트이고, 80번은 컨테이너의 포트 # httpd 는 일정 시간 연결 기록이 없으면, 서버 가동이 중지됨 # (컨테이너를 백그라운드에서 실행하게 해주는 -d 옵션) docker container cp ./ 컨테이너_이름:/usr/local/apache2/htdocs/ # [주의] 위의 명령어를 로컬 터미널에서 실행할 때, 위치는 pacman-canvas 디렉토리여야 함 docker exec -it 컨테이너_이름 bash # 컨테이너 내부 터미널로 접속할 수 있음 B. Docker 이미지 만들기 # 구동한 Docker Container를 이미지로 만드는 방법 docker container commit 컨테이너_이름 my_pacman:1.0 docker run --name my_web2 -p 900:80 my_pacman:1.0 Docker Image 빌드를 위한 파일인 Dockerfile 로 만드는 방법 # 베이스 이미지를 httpd:2.4 로 사용 FROM httpd:2.4 # 호스트의 현재 경로에 있는 파일을 생성할 이미지 /usr/local/apache2/htdocs/ 에 복사 COPY ./ /usr/local/apache2/htdocs/ # --tag 는 name:tag 형식으로 이미지를 생성할 수 있음 # 지정한 경로에 있는 Dockerfile을 찾아서 빌드 docker build --tag my_pacman:2.0 . # [주의] \u0026#34;.\u0026#34;을 명령어에 꼭 포함해야 함 docker run --name my_web3 -p 901:80 my_pacman:2.0 # 901 포트에서 웹 서버로 이미지를 구동 ","date":"7 January 2022","permalink":"/posts/bootcamp/bc-15w-3/","section":"Posts","summary":"1. Why Docker?","title":"BC-15w-3 / [배포] Docker"},{"content":"","date":null,"permalink":"/tags/docker/","section":"Tags","summary":"","title":"Docker"},{"content":"1) Cloud Computing # 데이터 센터에서는 서버의 자원과 공간, 및 네트워크 환경을 제공(on-premise) 클라우드 컴퓨팅은 가상화 기술의 발전으로부터 비롯 운영 환경 자체가 클라우드 제공자에게 종속되어 버리므로, 클라우드 서비스에 문제가 생기면 내가 배포하고 관리하는 환경에도 영향이 미치거나 백엔드 구성 자체가 특정 회사의 기술로만 구성해야만 하는 경우가 발생할 수도 있는 단점이 있음 클라우드 서비스의 형태 SaaS(Software as a Service) 클라우드 제공자가 당장 사용 가능한 소프트웨어를 제공하는 경우 대부분 SaaS에 해당 PaaS(Platform as a Service) 클라우드 제공자가 데이터베이스, 개발 플랫폼까지 제공하는 경우 대부분 PaaS에 해당 IaaS(Infrastructure as a Service) 클라우드 제공자가 가상 컴퓨터까지 제공하는 경우 대부분 IaaS에 해당 *AWS는 IaaS에 가까움 2) Deploy # Development 단계 각자의 컴퓨터에서 코드를 작성하고 테스트하는 과정 개발 단계이기 때문에 실제 데이터를 이용하지 않고 더미 데이터를 이용해서 테스트 Integration 단계 각자의 컴퓨터에서 작성한 코드를 합치는 과정 내가 작성한 코드가 다른 코드를 침범해서 오류를 일으키지 않는지, 코드 간에 conflict가 있지는 않은지 확인하는 과정 Staging 단계 실제 출시 단계인 Production 단계와 가장 유사한 환경에서 테스트하는 과정 실제 데이터를 복사해서 문제가 있지 않은지 등 다양한 환경에서 테스트를 진행 또한 서비스와 관련된 부서 혹은 인원의 확인 과정을 거침 Production 단계 개발된 서비스를 출시하는 단계 사용자가 접속할 수 있는 Production 환경에서 코드를 구동하고 서비스를 제공 실제 데이터를 가지고 서비스가 운영되기 때문에 문제가 생기면 안 되는 단계 환경 설정을 코드와 분리하는 것이 중요 절대경로 대신 상대경로 사용 환경에 따라 포트를 분기할 수 있도록 환경 변수를 설정(.env) Docker와 같은 개발 환경 자체를 통일시키는 솔루션을 사용 3) EC2(Elastic Compute Cloud) # AWS에서 원격으로 제어할 수 있는 가상의 컴퓨터를 한 대 빌리는 것 사용한 만큼 비용을 지불 인스턴스는 1대의 컴퓨터를 의미하는 단위이고 AWS에서 컴퓨터를 빌리는 것을 인스턴스를 생성한다고 함 AMI(Amazon Machine Image)는 소프트웨어 구성이 기재된 템플릿 장점 구성하는 데 필요한 시간이 짧다 AMI를 통해서 필요한 용도에 따라 다양한 운영체제에 대한 선택이 가능 CPU와 RAM, 용량까지도 손쉽게 구성 4) RDS(Relational Database Service) # AWS에서 제공하는 관계형 데이터베이스 서비스 RDS를 이용하면 데이터베이스 유지 보수와 관련된 일들을 RDS에서 전적으로 자동 관리 다양한 데이터베이스 엔진 선택지를 제공 5) S3(Simple Storage Service) # AWS에서 제공하는 클라우드 스토리지 서비스 높은 확장성 강력한 내구성 높은 가용성 보장 가용 영역(Availability Zone)이란 각 리전(Region) 안에 존재하는 데이터 센터(IDC) 다양한 스토리지 클래스를 제공 \u0026ldquo;Standard\u0026rdquo; 데이터에 빠른 속도로 접근할 수 있고, 데이터 액세스 요청에 대한 처리 속도가 빠름 데이터를 오래 보관하는 목적으로는 비효율적 bcs 높은 보관 비용 \u0026ldquo;Glacier\u0026rdquo; 저장된 데이터에 액세스하는 속도는 느리지만, 데이터를 보관하는 비용이 매우 저렴 정적 웹 사이트 호스팅이 가능 버킷이 사용자들이 정적 웹 사이트를 배포할 수 있는 공간을 제공 버킷 S3에 저장되는 파일들이 담기는 바구니(파일을 저장하는 최상위 디렉터리) 버킷의 이름은 버킷이 속해 있는 리전(버킷이 생성된 지역)에서 유일해야 함 버킷 정책을 생성하여 해당 버킷에 대한 다른 유저의 접근 권한을 수정할 수 있음 버킷에 저장되는 객체는 파일과 메타데이터로 구성 파일의 값에는 실제 데이터를 저장하며, 최대 크기는 5TB 메타데이터는 객체에 대한 정보가 담긴 데이터 모든 객체는 고유한 URL 주소를 가지고 있음 http://[버킷의 이름].S3.amazonaws.com/[객체의 키] 6) Deploy Strategy # 클라이언트 앱을 정적 파일로 빌드하여 제공 즉, S3를 이용해서 클라이언트를 배포 빌드 불필요한 데이터를 없애고, 여러 갈래로 퍼져있는 데이터들을 통합/ 압축하여 배포하기에 최적화된 상태를 만듬 빌드 과정을 진행하기 전과 비교했을 때 데이터의 용량이 줄어들고, 웹 사이트의 로딩 속도가 빨라진다는 장점이 생김 일반적인 의미의 빌드는, 소스코드를 실행 가능한 번들로 변환하는 컴파일 과정을 의미 AWS에서 제공하는 CDN 서비스인 \u0026ldquo;CloudFront\u0026quot;를 통해서 각지의 데이터 센터에 데이터를 분산시켜서 저장해 뒀다가 가까운 지역에서 데이터를 주는 방식으로 사용자에게 더 빠르게 서비스를 제공 AWS에서 제공하는 \u0026ldquo;Route 53\u0026rdquo; 서비스를 이용하면 직관적인 도메인 주소를 통해서 서비스에 접근하도록 할 수 있음 ","date":"5 January 2022","permalink":"/posts/bootcamp/bc-15w-2/","section":"Posts","summary":"1) Cloud Computing # 데이터 센터에서는 서버의 자원과 공간, 및 네트워크 환경을 제공(on-premise) 클라우드 컴퓨팅은 가상화 기술의 발전으로부터 비롯 운영 환경 자체가 클라우드 제공자에게 종속되어 버리므로, 클라우드 서비스에 문제가 생기면 내가 배포하고 관리하는 환경에도 영향이 미치거나 백엔드 구성 자체가 특정 회사의 기술로만 구성해야만 하는 경우가 발생할 수도 있는 단점이 있음 클라우드 서비스의 형태 SaaS(Software as a Service) 클라우드 제공자가 당장 사용 가능한 소프트웨어를 제공하는 경우 대부분 SaaS에 해당 PaaS(Platform as a Service) 클라우드 제공자가 데이터베이스, 개발 플랫폼까지 제공하는 경우 대부분 PaaS에 해당 IaaS(Infrastructure as a Service) 클라우드 제공자가 가상 컴퓨터까지 제공하는 경우 대부분 IaaS에 해당 *AWS는 IaaS에 가까움 2) Deploy # Development 단계 각자의 컴퓨터에서 코드를 작성하고 테스트하는 과정 개발 단계이기 때문에 실제 데이터를 이용하지 않고 더미 데이터를 이용해서 테스트 Integration 단계 각자의 컴퓨터에서 작성한 코드를 합치는 과정 내가 작성한 코드가 다른 코드를 침범해서 오류를 일으키지 않는지, 코드 간에 conflict가 있지는 않은지 확인하는 과정 Staging 단계 실제 출시 단계인 Production 단계와 가장 유사한 환경에서 테스트하는 과정 실제 데이터를 복사해서 문제가 있지 않은지 등 다양한 환경에서 테스트를 진행 또한 서비스와 관련된 부서 혹은 인원의 확인 과정을 거침 Production 단계 개발된 서비스를 출시하는 단계 사용자가 접속할 수 있는 Production 환경에서 코드를 구동하고 서비스를 제공 실제 데이터를 가지고 서비스가 운영되기 때문에 문제가 생기면 안 되는 단계 환경 설정을 코드와 분리하는 것이 중요 절대경로 대신 상대경로 사용 환경에 따라 포트를 분기할 수 있도록 환경 변수를 설정(.","title":"BC-15w-2 / [배포] Amazon Web Service"},{"content":"1. What is Next.js # Image Optimization Image and Automatic Image Optimization with instant builds. Internationalization Built-in Domain \u0026amp; Subdomain Routing and Automatic Language detection. Next.js Analytics A true lighthouse score based on real visitor data \u0026amp; page-by-page insights Zero Config Automatic compilation and bundling. Optimized for production from the start. Hybrid: SSG and SSR Pre-render pages at build time (SSG) or request time (SSR) in a single project. Incremental Static Regeneration Add and update statically pre-rendered pages incrementally after build time. TypeScript Support Automatic TypeScript configuration and compilation. Fast Refresh Fast, reliable live-editing experience, as proven at Facebook scale. File-system Routing Every component in the pages directory becomes a route. API Routes Optionally create API endpoints to provide backend functionality. Built-in CSS Support Create component-level styles with CSS modules. Built-in Sass support. Code-splitting and Bundling Optimized bundle splitting algorithm created by the Google Chrome team. 2. Next.js Setup #npx create-next-app 앱_이름 3. Routing # Index routes\npages/index.js / pages/blog/index.js /blog Nested routes\npages/blog/first-post.js /blog/first-post pages/dashboard/settings/username.js /dashboard/settings/username Dynamic route segments\npages/blog/[slug].js\n/blog/:slug (/blog/hello-world) import { useRouter } from \u0026#34;next/router\u0026#34;; export default function Blog() { const router = useRouter(); const { slug } = router.query; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;blog/{slug}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } pages/[username]/settings.js\n/:username/settings (/foo/settings) import { useRouter } from \u0026#34;next/router\u0026#34;; export default function UsernameSettings() { const router = useRouter(); const { username } = router.query; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{username}/settings\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } pages/post/[\u0026hellip;all].js\n/post/* (/post/2020/id/title) import { useRouter } from \u0026#34;next/router\u0026#34;; export default function PostAll() { const router = useRouter(); const { all } = router.query; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Post: {Array.isArray(all) ? all.join(\u0026#34;/\u0026#34;) : all}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } *console 찍어보면 undefined가 먼저 잡히고, 타입도 string | string[]인 문제가 있다.\n4. Sanity 연결하고 데이터 가져오기 # getStaticProps (Static Generation) Fetch data at build time getStaticPaths (Static Generation) Specify dynamic routes to pre-render pages based on data getServerSideProps (Server-side Rendering) Fetch data on each request npm i @sanity/client // services/SanityService import sanityClient from \u0026#34;@sanity/client\u0026#34;; export default class SanityService { _client = sanityClient({ dataset: \u0026#34;production\u0026#34;, projectId: process.env.SANITY_PROJECT_ID, useCdn: process.env.NODE_ENV === \u0026#34;production\u0026#34;, }); async getHome() { return await this._client.fetch( `*[_type == \u0026#34;home\u0026#34;][0]{\u0026#34;mainPostUrl\u0026#34;: mainPost -\u0026gt; slug.current}` ); } async getPosts() { return await this._client.fetch(` *[_type == \u0026#34;post\u0026#34;]{ title, subtitle, createdAt, \u0026#34;content\u0026#34;: content[]{ ..., ...select(_type == \u0026#34;imageGallery\u0026#34; =\u0026gt; {\u0026#34;images\u0026#34;: images[]{..., \u0026#34;url\u0026#34;: asset -\u0026gt; url}}) }, \u0026#34;slug\u0026#34;: slug.current, \u0026#34;thumbnail\u0026#34;: { \u0026#34;alt\u0026#34;: thumbnail.alt, \u0026#34;imageUrl\u0026#34;: thumbnail.asset -\u0026gt; url }, \u0026#34;author\u0026#34;: author -\u0026gt; { name, role, \u0026#34;image\u0026#34;: image.asset -\u0026gt; url }, \u0026#34;category\u0026#34;: category -\u0026gt; { title, \u0026#34;slug\u0026#34;: slug.current } } `); } } ","date":"3 January 2022","permalink":"/posts/bootcamp/bc-15w-1/","section":"Posts","summary":"1. What is Next.","title":"BC-15w-1 / {FC} Next.js로 블로그 만들기 - Next.js"},{"content":"1. What is Sanity^ ^ # Sanity.io is the unified content platform that powers better digital experiences\n2. Sanity Project 만들고 Deploy 하기 #npm install -g @sanity/cli sanity login # Sanity 시작 sanity init # 로컬에서 서버 띄우기, query 직접 띄워보기 가능 sanity start # Sanity에서 서버 띄우기 sanity deploy 3. Schema (1) - author #// author.js export default { name: \u0026#34;author\u0026#34;, title: \u0026#34;Author\u0026#34;, type: \u0026#34;document\u0026#34;, fields: [ { name: \u0026#34;name\u0026#34;, title: \u0026#34;Name\u0026#34;, type: \u0026#34;string\u0026#34;, validation: (Rule) =\u0026gt; Rule.required(), }, { name: \u0026#34;role\u0026#34;, title: \u0026#34;Role\u0026#34;, type: \u0026#34;string\u0026#34;, }, { name: \u0026#34;image\u0026#34;, title: \u0026#34;Image\u0026#34;, type: \u0026#34;image\u0026#34;, options: { hotspot: true, }, validation: (Rule) =\u0026gt; Rule.required(), }, ], preview: { select: { title: \u0026#34;name\u0026#34;, media: \u0026#34;image\u0026#34;, }, }, }; 4. Schema (2) - post #// post.js export default { name: \u0026#34;post\u0026#34;, title: \u0026#34;Post\u0026#34;, type: \u0026#34;document\u0026#34;, fields: [ { name: \u0026#34;title\u0026#34;, title: \u0026#34;Title\u0026#34;, type: \u0026#34;string\u0026#34;, validation: (Rule) =\u0026gt; Rule.required(), }, { // URL, Unique name: \u0026#34;slug\u0026#34;, title: \u0026#34;Slug\u0026#34;, type: \u0026#34;slug\u0026#34;, options: { source: \u0026#34;title\u0026#34;, maxLength: 96, }, validation: (Rule) =\u0026gt; Rule.required(), }, { name: \u0026#34;subtitle\u0026#34;, title: \u0026#34;Subtitle\u0026#34;, type: \u0026#34;string\u0026#34;, validation: (Rule) =\u0026gt; Rule.required(), }, { name: \u0026#34;author\u0026#34;, title: \u0026#34;Author\u0026#34;, type: \u0026#34;reference\u0026#34;, to: { type: \u0026#34;author\u0026#34; }, validation: (Rule) =\u0026gt; Rule.required(), }, { name: \u0026#34;content\u0026#34;, title: \u0026#34;Content\u0026#34;, type: \u0026#34;blockContent\u0026#34;, validation: (Rule) =\u0026gt; Rule.required(), }, { name: \u0026#34;createdAt\u0026#34;, title: \u0026#34;Created at\u0026#34;, type: \u0026#34;datetime\u0026#34;, }, { name: \u0026#34;thumbnail\u0026#34;, title: \u0026#34;Thumbnail\u0026#34;, type: \u0026#34;image\u0026#34;, options: { hotspot: true, }, fields: [ { name: \u0026#34;alt\u0026#34;, title: \u0026#34;alt\u0026#34;, type: \u0026#34;string\u0026#34;, options: { isHighlighted: true, }, validation: (Rule) =\u0026gt; Rule.required(), }, ], validation: (Rule) =\u0026gt; Rule.required(), }, { name: \u0026#34;category\u0026#34;, title: \u0026#34;Category\u0026#34;, type: \u0026#34;reference\u0026#34;, to: { type: \u0026#34;category\u0026#34; }, validation: (Rule) =\u0026gt; Rule.required(), }, { name: \u0026#34;tag\u0026#34;, title: \u0026#34;Tag\u0026#34;, type: \u0026#34;array\u0026#34;, of: [{ type: \u0026#34;reference\u0026#34;, to: { type: \u0026#34;tag\u0026#34; } }], }, ], preview: { select: { title: \u0026#34;title\u0026#34;, author: \u0026#34;author.name\u0026#34;, media: \u0026#34;thumbnail\u0026#34;, }, prepare(selection) { const { author } = selection; return Object.assign({}, selection, { subtitle: author \u0026amp;\u0026amp; `by ${author}`, }); }, }, }; // category.js export default { name: \u0026#34;category\u0026#34;, title: \u0026#34;Category\u0026#34;, type: \u0026#34;document\u0026#34;, fields: [ { name: \u0026#34;title\u0026#34;, title: \u0026#34;Title\u0026#34;, type: \u0026#34;string\u0026#34;, validation: (Rule) =\u0026gt; Rule.required(), }, { name: \u0026#34;slug\u0026#34;, title: \u0026#34;Slug\u0026#34;, type: \u0026#34;slug\u0026#34;, options: { source: \u0026#34;title\u0026#34;, maxLength: 96, }, validation: (Rule) =\u0026gt; Rule.required(), }, { name: \u0026#34;description\u0026#34;, title: \u0026#34;Description\u0026#34;, type: \u0026#34;text\u0026#34;, }, ], preview: { select: { title: \u0026#34;title\u0026#34;, subtitle: \u0026#34;description\u0026#34;, }, }, }; // tag.js export default { name: \u0026#34;tag\u0026#34;, title: \u0026#34;Tag\u0026#34;, type: \u0026#34;document\u0026#34;, fields: [ { name: \u0026#34;title\u0026#34;, title: \u0026#34;Title\u0026#34;, type: \u0026#34;string\u0026#34;, validation: (Rule) =\u0026gt; Rule.required(), }, { name: \u0026#34;slug\u0026#34;, title: \u0026#34;Slug\u0026#34;, type: \u0026#34;slug\u0026#34;, options: { source: \u0026#34;title\u0026#34;, maxLength: 96, }, validation: (Rule) =\u0026gt; Rule.required(), }, ], preview: { select: { title: \u0026#34;title\u0026#34;, subtitle: \u0026#34;slug.current\u0026#34;, }, }, }; 5. Schema (3) - home #// home.js export default { name: \u0026#34;home\u0026#34;, title: \u0026#34;Home\u0026#34;, type: \u0026#34;document\u0026#34;, fields: [ { name: \u0026#34;title\u0026#34;, title: \u0026#34;Title\u0026#34;, type: \u0026#34;string\u0026#34;, validation: (Rule) =\u0026gt; Rule.required(), }, { name: \u0026#34;mainPost\u0026#34;, title: \u0026#34;Main Post\u0026#34;, type: \u0026#34;reference\u0026#34;, to: { type: \u0026#34;post\u0026#34; }, validation: (Rule) =\u0026gt; Rule.required(), }, ], preview: { select: { title: \u0026#34;title\u0026#34;, subtitle: \u0026#34;mainPost.title\u0026#34;, media: \u0026#34;mainPost.thumbnail\u0026#34;, }, }, }; 6. Schema (4) - blockContent #// blockContent.js /** * This is the schema definition for the rich text fields used for * for this blog studio. When you import it in schemas.js it can be * reused in other parts of the studio with: * { * name: \u0026#39;someName\u0026#39;, * title: \u0026#39;Some title\u0026#39;, * type: \u0026#39;blockContent\u0026#39; * } */ export default { title: \u0026#34;Block Content\u0026#34;, name: \u0026#34;blockContent\u0026#34;, type: \u0026#34;array\u0026#34;, of: [ { title: \u0026#34;Block\u0026#34;, type: \u0026#34;block\u0026#34;, // Styles let you set what your user can mark up blocks with. These // correspond with HTML tags, but you can set any title or value // you want and decide how you want to deal with it where you want to // use your content. styles: [ { title: \u0026#34;Normal\u0026#34;, value: \u0026#34;normal\u0026#34; }, { title: \u0026#34;H1\u0026#34;, value: \u0026#34;h1\u0026#34; }, { title: \u0026#34;H2\u0026#34;, value: \u0026#34;h2\u0026#34; }, { title: \u0026#34;H3\u0026#34;, value: \u0026#34;h3\u0026#34; }, { title: \u0026#34;H4\u0026#34;, value: \u0026#34;h4\u0026#34; }, { title: \u0026#34;H5\u0026#34;, value: \u0026#34;h5\u0026#34; }, { title: \u0026#34;Quote\u0026#34;, value: \u0026#34;blockquote\u0026#34; }, ], lists: [ { title: \u0026#34;Bullet\u0026#34;, value: \u0026#34;bullet\u0026#34; }, { title: \u0026#34;Numbered\u0026#34;, value: \u0026#34;number\u0026#34; }, ], // Marks let you mark up inline text in the block editor. marks: { // Decorators usually describe a single property – e.g. a typographic // preference or highlighting by editors. decorators: [ { title: \u0026#34;Strong\u0026#34;, value: \u0026#34;strong\u0026#34; }, { title: \u0026#34;Emphasis\u0026#34;, value: \u0026#34;em\u0026#34; }, ], // Annotations can be any object structure – e.g. a link or a footnote. annotations: [ { title: \u0026#34;URL\u0026#34;, name: \u0026#34;link\u0026#34;, type: \u0026#34;object\u0026#34;, fields: [ { title: \u0026#34;URL\u0026#34;, name: \u0026#34;href\u0026#34;, type: \u0026#34;url\u0026#34;, }, ], }, ], }, }, // You can add additional types here. Note that you can\u0026#39;t use // primitive types such as \u0026#39;string\u0026#39; and \u0026#39;number\u0026#39; in the same array // as a block type. { type: \u0026#34;image\u0026#34;, options: { hotspot: true }, fields: [ { name: \u0026#34;caption\u0026#34;, title: \u0026#34;Caption\u0026#34;, type: \u0026#34;string\u0026#34;, option: { isHighlighted: true, }, }, { name: \u0026#34;alt\u0026#34;, title: \u0026#34;Alt\u0026#34;, type: \u0026#34;string\u0026#34;, option: { isHighlighted: true, }, validation: (Rule) =\u0026gt; Rule.required(), }, ], }, { type: \u0026#34;video\u0026#34;, }, { type: \u0026#34;code\u0026#34;, }, { type: \u0026#34;link\u0026#34;, }, { type: \u0026#34;imageGallery\u0026#34;, }, ], }; // video.js export default { name: \u0026#34;video\u0026#34;, title: \u0026#34;Video\u0026#34;, type: \u0026#34;object\u0026#34;, fields: [ { name: \u0026#34;caption\u0026#34;, title: \u0026#34;caption\u0026#34;, type: \u0026#34;string\u0026#34;, }, { name: \u0026#34;metadata\u0026#34;, title: \u0026#34;Metadata\u0026#34;, type: \u0026#34;urlWithMetadata\u0026#34;, }, ], preview: { select: { title: \u0026#34;caption\u0026#34;, subtitle: \u0026#34;metadata.url\u0026#34;, }, }, }; * https://www.sanity.io/plugins/sanity-plugin-url-metadata-input\n// code.js export default { name: \u0026#34;code\u0026#34;, title: \u0026#34;Code\u0026#34;, type: \u0026#34;object\u0026#34;, fields: [ { name: \u0026#34;title\u0026#34;, title: \u0026#34;Title\u0026#34;, type: \u0026#34;string\u0026#34;, validation: (Rule) =\u0026gt; Rule.required(), }, { name: \u0026#34;language\u0026#34;, title: \u0026#34;Language\u0026#34;, type: \u0026#34;string\u0026#34;, validation: (Rule) =\u0026gt; Rule.required(), }, { name: \u0026#34;code\u0026#34;, title: \u0026#34;Code\u0026#34;, type: \u0026#34;string\u0026#34;, validation: (Rule) =\u0026gt; Rule.required(), }, ], }; // link.js export default { name: \u0026#34;link\u0026#34;, title: \u0026#34;Link\u0026#34;, type: \u0026#34;object\u0026#34;, fields: [ { name: \u0026#34;metadata\u0026#34;, title: \u0026#34;Metadata\u0026#34;, type: \u0026#34;urlWithMetadata\u0026#34;, }, ], preview: { select: { title: \u0026#34;metadata.openGraph.title\u0026#34;, subtitle: \u0026#34;metadata.openGraph.url\u0026#34;, }, }, }; // imageGallery.js export default { name: \u0026#34;imageGallery\u0026#34;, title: \u0026#34;Image Gallery\u0026#34;, type: \u0026#34;object\u0026#34;, fields: [ { name: \u0026#34;caption\u0026#34;, title: \u0026#34;Caption\u0026#34;, type: \u0026#34;string\u0026#34;, validation: (Rule) =\u0026gt; Rule.required(), }, { name: \u0026#34;images\u0026#34;, title: \u0026#34;Images\u0026#34;, type: \u0026#34;array\u0026#34;, options: { layout: \u0026#34;grid\u0026#34;, }, of: [ { name: \u0026#34;image\u0026#34;, title: \u0026#34;Image\u0026#34;, type: \u0026#34;image\u0026#34;, hotspot: true, fields: [ { name: \u0026#34;alt\u0026#34;, title: \u0026#34;Alt\u0026#34;, type: \u0026#34;string\u0026#34;, option: { isHighlighted: true, }, validation: (Rule) =\u0026gt; Rule.required(), }, ], validation: (Rule) =\u0026gt; Rule.required(), }, ], validation: (Rule) =\u0026gt; Rule.required().max(4), }, ], }; 7. Studio의 input 커스터마이징^ #npm i yarn -g yarn add react-ace // components/CodeInput.jsx import React, { useCallback } from \u0026#34;react\u0026#34;; // import { Stack, Label, TextInput } from \u0026#34;@sanity/ui\u0026#34;; import { FormField } from \u0026#34;@sanity/base/components\u0026#34;; import AceEditor from \u0026#34;react-ace\u0026#34;; import \u0026#34;ace-builds/src-noconflict/theme-chrome\u0026#34;; import \u0026#34;ace-builds/src-noconflict/mode-javascript\u0026#34;; import PatchEvent, { set, unset } from \u0026#34;@sanity/form-builder/PatchEvent\u0026#34;; const CodeInput = React.forwardRef((props, ref) =\u0026gt; { const { type, // Schema information value, // Current field value readOnly, // Boolean if field is not editable placeholder, // Placeholder text from the schema markers, // Markers including validation rules presence, // Presence information for collaborative avatars compareValue, // Value to check for \u0026#34;edited\u0026#34; functionality onFocus, // Method to handle focus state onBlur, // Method to handle blur state onChange, } = props; const codeChange = useCallback( (code) =\u0026gt; { onChange(PatchEvent.from(code ? set(code) : unset())); }, [onChange] ); return ( \u0026lt;FormField description={type.description} // Creates description from schema title={type.title} // Creates label from schema title __unstable_markers={markers} // Handles all markers including validation __unstable_presence={presence} // Handles presence avatars compareValue={compareValue} // Handles \u0026#34;edited\u0026#34; status \u0026gt; \u0026lt;AceEditor ref={ref} value={value} tabSize={2} setOptions={{ useWorker: false }} onChange={codeChange} mode=\u0026#34;javascript\u0026#34; name=\u0026#34;ace-editor-code\u0026#34; width=\u0026#34;100%\u0026#34; theme=\u0026#34;chrome\u0026#34; style={{ boxShadow: \u0026#34;0 0 0 1px #cad1dc\u0026#34;, lineHeight: 1.6, }} /\u0026gt; \u0026lt;/FormField\u0026gt; ); }); export default CodeInput; import CodeInput from \u0026#34;../components/CodeInput\u0026#34;; export default { name: \u0026#34;code\u0026#34;, title: \u0026#34;Code\u0026#34;, type: \u0026#34;object\u0026#34;, fields: [ { name: \u0026#34;title\u0026#34;, title: \u0026#34;Title\u0026#34;, type: \u0026#34;string\u0026#34;, validation: (Rule) =\u0026gt; Rule.required(), }, { name: \u0026#34;language\u0026#34;, title: \u0026#34;Language\u0026#34;, type: \u0026#34;string\u0026#34;, validation: (Rule) =\u0026gt; Rule.required(), }, { name: \u0026#34;code\u0026#34;, title: \u0026#34;Code\u0026#34;, type: \u0026#34;string\u0026#34;, validation: (Rule) =\u0026gt; Rule.required(), inputComponent: CodeInput, }, ], }; 8. Query #*[_type == \u0026#39;home\u0026#39;][0]{\u0026#39;mainPostURL\u0026#39;: mainPost -\u0026gt; slug.current} *[_type == \u0026#39;post\u0026#39;]{\rtitle,\rsubtitle,\rcreatedAt,\r\u0026#34;content\u0026#34;: content[]{\r...,\r...select(_type == \u0026#34;imageGallery\u0026#34; =\u0026gt; {\u0026#34;images\u0026#34;: images[]{..., \u0026#34;url\u0026#34;: asset -\u0026gt; url}})\r},\r\u0026#34;slug\u0026#34;: slug.current,\r\u0026#34;thumbnail\u0026#34;: {\r\u0026#34;alt\u0026#34;: thumbnail.alt,\r\u0026#34;imageUrl\u0026#34;: thumbnail.asset -\u0026gt; url\r},\r\u0026#34;author\u0026#34;: author -\u0026gt; {\rname,\rrole,\r\u0026#34;image\u0026#34;: image.asset -\u0026gt; url\r},\r\u0026#34;category\u0026#34;: category -\u0026gt; {\rtitle,\r\u0026#34;slug\u0026#34;: slug.current\r}\r} ","date":"31 December 2021","permalink":"/posts/bootcamp/bc-14w-5/","section":"Posts","summary":"1. What is Sanity^ ^ # Sanity.","title":"BC-14w-5 / {FC} Next.js로 블로그 만들기 - Sanity"},{"content":"","date":null,"permalink":"/tags/sanity/","section":"Tags","summary":"","title":"Sanity"},{"content":"1. Rest API \u0026amp; GraphQL #Rest API #axios.get(\u0026#34;https://api.marktube.tv/v1/book\u0026#34;, { headers: `Bearer ${token}` }); axios.post( \u0026#34;https://api.marktube.tv/v1/book\u0026#34;, { title, message, author, url, }, { headers: `Bearer ${token}` } ); axios.get(`https://api.marktube.tv/v1/book/${book.id}`, { headers: `Bearer ${token}`, }); axios.patch( `https://api.marktube.tv/v1/book/${book.id}`, { title, message, author, url, }, { headers: `Bearer ${token}` } ); axios.delete(`https://api.marktube.tv/v1/book/${book.id}`, { headers: `Bearer ${token}`, }); url의 형태와 메소드의 조합으로 특정 리소스의 조회, 수정, 삭제 등을 함 결과물을 완전히 의도 데로 가져오기 힘든 경우가 있음 불필요하게 여러 번 요청해야 하는 경우가 있음 조회한 데이터가 불필요한 내용을 포함해서 용량이 커지는 경우가 있음 GraphQL # 쿼리를 보내서 결과로 원하는 데이터만 사용 CODE -\u0026gt; JavaScript -\u0026gt; Apollo Server 2. Apollo^ ^ ## GraphQL의 Apollo server 시작 npm init -y npm i apollo-server@3 graphql@15 # 수정시 자동으로 서버 새로고침하는 라이브러리 npm i nodemon@2 -D 3. typeDef \u0026amp; resolver #A. typeDef(s) # GraphQL Schema를 정의하는 곳 Object Query Mutation Input gql과 Tagged Template Literals로 작성 B. resolver(s) # Schema에 해당하는 구현을 하는 곳 요청을 받아 데이터를 조회, 수정, 삭제 4. 조회, 추가, 수정, 삭제 #// index.js const { ApolloServer, gql } = require(\u0026#34;apollo-server\u0026#34;); const { readFileSync, writeFileSync } = require(\u0026#34;fs\u0026#34;); const { join } = require(\u0026#34;path\u0026#34;); // The GraphQL schema const typeDefs = gql` type Query { books: [Book] book(bookId: Int): Book } type Mutation { addBook(title: String, message: String, author: String, url: String): Book editBook( bookId: Int title: String message: String author: String url: String ): Book deleteBook(bookId: Int): Book } type Book { bookId: Int title: String message: String author: String url: String } `; // A map of functions which return data for the schema. const resolvers = { Query: { books: () =\u0026gt; { return JSON.parse(readFileSync(join(__dirname, \u0026#34;books.json\u0026#34;)).toString()); }, book: (parent, args, context, info) =\u0026gt; { const books = JSON.parse( readFileSync(join(__dirname, \u0026#34;books.json\u0026#34;)).toString() ); return books.find((book) =\u0026gt; book.bookId === args.bookId); }, }, Mutation: { addBook: (parent, args, context, info) =\u0026gt; { const books = JSON.parse( readFileSync(join(__dirname, \u0026#34;books.json\u0026#34;)).toString() ); const maxId = Math.max(...books.map((book) =\u0026gt; book.bookId)); const newBook = { ...args, bookId: maxId + 1 }; writeFileSync( join(__dirname, \u0026#34;books.json\u0026#34;), JSON.stringify([...books, newBook]) ); return newBook; }, editBook: (parent, args, context, info) =\u0026gt; { const books = JSON.parse( readFileSync(join(__dirname, \u0026#34;books.json\u0026#34;)).toString() ); const newBooks = books.map((book) =\u0026gt; { if (book.bookId === args.bookId) { return args; } else { return book; } }); writeFileSync(join(__dirname, \u0026#34;books.json\u0026#34;), JSON.stringify(newBooks)); return args; }, deleteBook: (parent, args, context, info) =\u0026gt; { const books = JSON.parse( readFileSync(join(__dirname, \u0026#34;books.json\u0026#34;)).toString() ); const deletedBook = books.find((book) =\u0026gt; book.bookId === args.bookId); const newBooks = books.filter((book) =\u0026gt; book.bookId !== args.bookId); writeFileSync(join(__dirname, \u0026#34;books.json\u0026#34;), JSON.stringify(newBooks)); return deletedBook; }, }, }; const server = new ApolloServer({ typeDefs, resolvers, }); server.listen().then(({ url }) =\u0026gt; { console.log(`🚀 Server ready at ${url}`); }); // books.json [ { \u0026#34;bookId\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;title1\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;message1\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;author1\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;url1\u0026#34; }, { \u0026#34;bookId\u0026#34;: 2, \u0026#34;title\u0026#34;: \u0026#34;title2\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;message2\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;author2\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;url2\u0026#34; } ] query { books { bookId title message author url } book(bookId: 1) { bookId title message author url } } mutation { addBook( title: \u0026#34;제목\u0026#34;, message: \u0026#34;내용\u0026#34;, author: \u0026#34;저자\u0026#34;, url: \u0026#34;위치\u0026#34; ) { bookId title message author url } editBook( bookId: 3, title: \u0026#34;제목edit\u0026#34;, message: \u0026#34;내용edit\u0026#34;, author: \u0026#34;저자edit\u0026#34;, url: \u0026#34;위치edit\u0026#34; ) { bookId title message author url } deleteBook( bookId: 3) { bookId title message author url } } ","date":"30 December 2021","permalink":"/posts/bootcamp/bc-14w-4/","section":"Posts","summary":"1. Rest API \u0026amp; GraphQL #Rest API #axios.","title":"BC-14w-4 / {FC} GraphQL 맛보기"},{"content":"","date":null,"permalink":"/tags/graphql/","section":"Tags","summary":"","title":"GraphQL"},{"content":"1. OAuth 2.0 # 웹이나 앱에서 흔히 찾아볼 수 있는 소셜 로그인 인증 방식은 OAuth 2라는 기술을 바탕으로 구현 OAuth는 인증을 중개해 주는 메커니즘 보안된 리소스에 액세스하기 위해 클라이언트에게 권한을 제공하는 프로세스를 단순화하는 프로토콜 이미 사용자 정보를 가지고 있는 웹 서비스(GitHub, google, facebook 등)에서 사용자의 인증을 대신해 주고, 접근 권한에 대한 토큰을 발급한 후, 이를 이용해 내 서버에서 인증이 가능 여전히 사용자 정보가 내 서버에 저장되는 것은 변함이 없음 OAuth는 인증(Authentication)을 다른 서비스에 맡길 뿐, 접근 권한 관리(Authorization)는 순전히 서버의 몫 OAuth 란? # OAuth2.0은 인증을 위한 표준 프로토콜의 한 종류 보안 된 리소스에 액세스하기 위해 클라이언트에게 권한을 제공(Authorization)하는 프로세스를 단순화하는 프로토콜 중 한 방법 OAuth 사용 이유 # OAuth를 활용한다면 자주 사용하고 중요한 서비스들(예를 들어 google, github, facebook)의 ID와 Password만 기억해 놓고 해당 서비스들을 통해서 소셜 로그인을 할 수 있음 검증되지 않은 App에서 OAuth를 사용하여 로그인한다면, 직접 유저의 민감한 정보가 App에 노출될 일이 없고 인증 권한에 대한 허가를 미리 유저에게 구해야 하기 때문에 더 안전하게 사용할 수 있음 OAuth 용어 # Resource Owner 액세스 중인 리소스의 유저 Client Resource owner를 대신하여 보호된 리소스에 액세스하는 응용프로그램 클라이언트는 서버, 데스크탑, 모바일 또는 기타 장치에서 호스팅 할 수 있음 Resource server client의 요청을 수락하고 응답할 수 있는 서버 Authorization server Resource server가 액세스 토큰을 발급받는 서버 Authorization grant 클라이언트가 액세스 토큰을 얻을 때 사용하는 자격 증명의 유형 Authorization code access token을 발급받기 전에 필요한 code client ID로 이 code를 받아온 후, client secret과 code를 이용해 Access token 을 받아옴 Access token 보호된 리소스에 액세스하는 데 사용되는 credentials Authorization code와 client secret을 이용해 받아온 이 Access token으로 이제 resource server에 접근을 할 수 있음 Scope scope는 토큰의 권한을 정의 주어진 액세스 토큰을 사용하여 액세스할 수 있는 리소스의 범위 소셜 로그인 로직 플로우 # client가 OAuth에 Authorization code 요청 OAuth가 client에 redirect uri를 통해 Authorization code 부여 client가 server에 Authorization code 전달 server가 OAuth에 Authorization code를 보내서 Access token 요청 OAuth가 server에 Access token 부여 server가 client에 Access token 전달 2. OAuth 2.0 실습 # https://www.oauth.com/oauth2-servers/accessing-data/create-an-application/ ","date":"29 December 2021","permalink":"/posts/bootcamp/bc-14w-3/","section":"Posts","summary":"1. OAuth 2.","title":"BC-14w-3 / [인증/보안] OAuth"},{"content":"","date":null,"permalink":"/tags/security/","section":"Tags","summary":"","title":"Security"},{"content":"1. 토큰 기반 인증 (Token-based Authentication) # 세션 기반 인증은 서버(혹은 DB)에 유저 정보를 담는 인증 방식 매 요청마다 데이터베이스를 살펴보는 것이 불편하고, 이 부담을 덜어내고 싶어서, 토큰 기반 인증 사용 대표적인 것이 JWT (JSON Web Token) 토큰은 유저 정보를 암호화한 상태로 담을 수 있고, 암호화했기 때문에 클라이언트에 담을 수 있음 JWT 종류 # Access Token 실제로 권한을 얻는 데 사용하는 토큰 비교적 짧은 유효 기간 을 주어 탈취되더라도 오랫동안 사용할 수 없도록 함 Refresh Token Access token의 유효기간이 만료된다면 Refresh token을 사용하여 새로운 access token을 발급 JWT 구조 # aaaaaa(Header).bbbbbb(Payload).cccccc(Signature) Header 어떤 종류의 토큰인지, 어떤 알고리즘으로 sign할지가 적혀있음 { \u0026#34;alg\u0026#34;: \u0026#34;HS256\u0026#34;, \u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34; } Payload 정보가 담겨 있음 민감한 정보는 되도록 담지 않는 것이 좋음 { \u0026#34;sub\u0026#34;: \u0026#34;someInformation\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;phillip\u0026#34;, \u0026#34;iat\u0026#34;: 151623391 } Signature 원하는 비밀 키(암호화에 추가할 salt)를 사용하여 암호화 HMACSHA256(base64UrlEncode(header) + \u0026#39;.\u0026#39; + base64UrlEncode(payload), secret); 토큰기반 인증 절차 # 클라이언트가 서버에 아이디/비밀번호를 담아 로그인 요청을 보낸다. 아이디/비밀번호가 일치하는지 확인하고, 클라이언트에게 보낼 Signature 된 토큰을 생성한다. access/refresh 토큰을 모두 생성한다. 토큰에 담길 정보(payload)는 유저를 식별할 정보, 권한이 부여된 카테고리(사진, 연락처, 기타 등등)이 될 수 있다. 두 종류의 토큰이 같은 정보를 담을 필요는 없다 (이 스프린트에서는 같은 정보를 담아줍시다). 토큰을 클라이언트에게 보내주면, 클라이언트는 토큰을 저장한다. 저장하는 위치는 local storage, cookie, react의 state 등 다양하다. 클라이언트가 HTTP 헤더(authorization 헤더)에 토큰을 담아 보낸다. bearer authentication을 이용한다. 서버는 토큰을 해독하여 \u0026ldquo;아 우리가 발급해 준 토큰이 맞네!\u0026ldquo;라는 판단이 될 경우, 클라이언트의 요청을 처리한 후 응답을 보내준다. 토큰기반 인증의 장점 # Statelessness \u0026amp; Scalability (무상태성 \u0026amp; 확장성) 서버는 클라이언트에 대한 정보를 저장할 필요 없습니다 (토큰 해독이 되는지만 판단합니다) 클라이언트는 새로운 요청을 보낼 때마다 토큰을 헤더에 포함시키면 됩니다 서버를 여러 개 가지고 있는 서비스라면 더더욱 빛을 발휘합니다 (같은 토큰으로 여러 서버에서 인증 가능) 안전하다 signature을 받은 토큰을 사용하고, 암호화 키를 노출할 필요가 없기 때문에 안전합니다 어디서나 생성 가능하다 토큰을 확인하는 서버가 토큰을 만들어야 하는 법이 없습니다 토큰 생성용 서버를 만들거나, 다른 회사에서 토큰 관련 작업을 맡기는 것 등 다양한 활용이 가능합니다 권한 부여에 용이하다 토큰의 payload(내용물) 안에 어떤 정보에 접근 가능한지 정할 수 있습니다 ex) 서비스의 사진과 연락처 사용 권한만 부여 2. Token 실습 # jwt.sign()과 jwt.verify()를 사용해서 토큰 관리 \u0026ldquo;bearer \u0026quot; + token ","date":"28 December 2021","permalink":"/posts/bootcamp/bc-14w-2/","section":"Posts","summary":"1. 토큰 기반 인증 (Token-based Authentication) # 세션 기반 인증은 서버(혹은 DB)에 유저 정보를 담는 인증 방식 매 요청마다 데이터베이스를 살펴보는 것이 불편하고, 이 부담을 덜어내고 싶어서, 토큰 기반 인증 사용 대표적인 것이 JWT (JSON Web Token) 토큰은 유저 정보를 암호화한 상태로 담을 수 있고, 암호화했기 때문에 클라이언트에 담을 수 있음 JWT 종류 # Access Token 실제로 권한을 얻는 데 사용하는 토큰 비교적 짧은 유효 기간 을 주어 탈취되더라도 오랫동안 사용할 수 없도록 함 Refresh Token Access token의 유효기간이 만료된다면 Refresh token을 사용하여 새로운 access token을 발급 JWT 구조 # aaaaaa(Header).","title":"BC-14w-2 / [인증/보안] Token"},{"content":"1. HTTPS # HTTPS = HTTP + Secure 무결성, 기밀성 인증서(Certification) 데이터 제공자 신원 보장 도메인 종속 CA(Certification Authority) 공인 인증서 발급 기관 비대칭 키 암호화 key A로 암호화, key B로 복호화 SSL(Secure Socket Layer) or TLS(Transport Layer Security)\n*TLS는 SSL의 후속 버전이만, SSL이 일반적으로 더 많이 사용되는 용어 Hand Shake 비밀 키 생성 상호 키 검증 *ngrok: HTTP로 만들어진 서버를 HTTPS 프로토콜로 터널링 해주는 프로그램\n사설 인증서 발급 및 HTTPS 서버 구현 # mkcert 설치\n로컬 환경에서 신뢰할 수 있는 인증서를 만드는 프로그램 brew install mkcert 인증서 생성\n다음 명령어를 통해 로컬을 인증된 발급기관으로 추가 mkcert -install 로컬 환경에 대한 인증서를 만듦 mkcert -key-file key.pem -cert-file cert.pem localhost 127.0.0.1 ::1 옵션으로 추가한 localhost, 127.0.0.1(IPv4), ::1(IPv6)에서 사용할 수 있는 인증서가 완성 cert.pem, key.pem 이라는 파일이 생성 인증서는 공개키, 그리고 인증기관의 서명을 포함하고 있으므로 공개되어도 상관이 없지만, key.pem의 경우 개인 키이므로 git에 커밋하지 않고, 암호처럼 다루어야 함 HTTPS 서버 작성\nNode.js https 모듈 이용\nconst https = require(\u0026#34;https\u0026#34;); const fs = require(\u0026#34;fs\u0026#34;); https .createServer( { key: fs.readFileSync(__dirname + \u0026#34;/key.pem\u0026#34;, \u0026#34;utf-8\u0026#34;), cert: fs.readFileSync(__dirname + \u0026#34;/cert.pem\u0026#34;, \u0026#34;utf-8\u0026#34;), }, function (req, res) { res.write(\u0026#34;Congrats! You made https server now :)\u0026#34;); res.end(); } ) .listen(3001); express.js 이용\nconst https = require(\u0026#34;https\u0026#34;); const fs = require(\u0026#34;fs\u0026#34;); const express = require(\u0026#34;express\u0026#34;); const app = express(); https .createServer( { key: fs.readFileSync(__dirname + \u0026#34;/key.pem\u0026#34;, \u0026#34;utf-8\u0026#34;), cert: fs.readFileSync(__dirname + \u0026#34;/cert.pem\u0026#34;, \u0026#34;utf-8\u0026#34;), }, app.use(\u0026#34;/\u0026#34;, (req, res) =\u0026gt; { res.send(\u0026#34;Congrats! You made https server now :)\u0026#34;); }) ) .listen(3001); 2. Hashing # 모든 값에 대해 해시 값을 계산하는데 오래걸리지 않아야 한다. 최대한 해시 값을 피해야하며, 모든 값은 고유한 해시 값을 가진다. 아주 작은 단위의 변경이라도 완전히 다른 해시 값을 가져야 한다. Salt 암호화해야 하는 값에 어떤 별도의 값을 추가하여 결과를 변형하는 것 Salt는 절대 재사용하지 말아야 함 Salt는 DB의 유저 테이블에 같이 저장되어야 함 3. Cookie # 서버가 클라이언트에 데이터를 저장할 수 있음\nSet-Cookie\n쿠키 옵션\nDomain\n도메인이라는 것은 여러분들이 흔하게 보실 수 있는 www.google.com과 같은 서버에 접속할 수 있는 이름입니다. 쿠키 옵션에서 도메인은 포트 및 서브 도메인 정보, 세부 경로를 포함하지 않습니다. 여기서 서브 도메인이란 www 같은 도메인 앞에 추가로 작성되는 부분을 말합니다. 따라서 요청해야 할 URL이 http://www.localhost.com:3000/users/login 이라 하면 여기에서 Domain은 localhost.com이 됩니다. 만약 쿠키 옵션에서 도메인 정보가 존재한다면 클라이언트에서는 쿠키의 도메인 옵션과 서버의 도메인이 일치해야만 쿠키를 전송할 수 있습니다. Path\n세부 경로는 서버가 라우팅할 때 사용하는 경로입니다. 만약 요청해야 하는 URL이 http://www.localhost.com:3000/users/login 인 경우라면 여기에서 Path, 세부 경로는 /users/login이 됩니다. 명시하지 않으면 기본으로 / 으로 설정되어 있습니다. Path 옵션의 특징은 설정된 path를 전부 만족하는 경우 요청하는 Path가 추가로 더 존재하더라도 쿠키를 서버에 전송할 수 있습니다. 즉 Path가 /users로 설정되어 있고, 요청하는 세부 경로가 /users/login 인 경우라면 쿠키 전송이 가능합니다. 하지만 /user/login으로 전송되는 요청은 Path 옵션을 만족하지 못하기 때문에 서버로 쿠키를 전송할 수 없습니다. MaxAge or Expires\n쿠키가 유효한 기간을 정하는 옵션입니다. MaxAge는 앞으로 몇 초 동안 쿠키가 유효한지 설정하는 옵션입니다. Expires 은 MaxAge와 비슷합니다. 다만 언제까지 유효한지 Date를 지정합니다. 이때 클라이언트의 시간을 기준으로 합니다. 이후 지정된 시간, 날짜를 초과하게 되면 쿠키는 자동으로 파괴됩니다. 하지만 두 옵션이 모두 지정되지 않는 경우에는 브라우저의 탭을 닫아야만 쿠키가 제거될 수 있습니다. Secure\n쿠키를 전송해야 할 때 사용하는 프로토콜에 따른 쿠키 전송 여부를 결정합니다. 만약 해당 옵션이 true로 설정된 경우, \u0026lsquo;HTTPS\u0026rsquo; 프로토콜을 이용하여 통신하는 경우에만 쿠키를 전송할 수 있습니다. HttpOnly\n자바스크립트에서 브라우저의 쿠키에 접근 여부를 결정합니다. 만약 해당 옵션이 true로 설정된 경우, 자바스크립트에서는 쿠키에 접근이 불가합니다. 명시되지 않는 경우 기본으로 false로 지정되어 있습니다. 만약 이 옵션이 false인 경우 자바스크립트에서 쿠키에 접근이 가능하므로 \u0026lsquo;XSS\u0026rsquo; 공격에 취약합니다. SameSite\nCross-Origin 요청을 받은 경우 요청에서 사용한 메소드와 해당 옵션의 조합으로 서버의 쿠키 전송 여부를 결정하게 됩니다. 사용 가능한 옵션 Lax Cross-Origin 요청이면 \u0026lsquo;GET\u0026rsquo; 메소드에 대해서만 쿠키를 전송할 수 있습니다. Strict Cross-Origin이 아닌 same-site 인 경우에만 쿠키를 전송 할 수 있습니다. None 항상 쿠키를 보내줄 수 있습니다. 다만 쿠키 옵션 중 Secure 옵션이 필요합니다. 이때 \u0026lsquo;same-site\u0026rsquo;는 요청을 보낸 Origin과 서버의 도메인이 같은 경우를 말합니다. 이러한 옵션들을 지정한 다음 서버에서 클라이언트로 쿠키를 처음 전송하게 된다면 헤더에 Set-Cookie라는 프로퍼티에 쿠키를 담아 쿠키를 전송하게 됩니다. 이후 클라이언트 혹은 서버에서 쿠키를 전송해야 한다면 클라이언트는 헤더에 Cookie라는 프로퍼티에 쿠키를 담아 서버에 쿠키를 전송하게 됩니다. 4. Session # 사용자가 인증에 성공한 상태 서버가 Client에 유일하고 암호화된 ID를 부여 중요 데이터는 서버에서 관리 쿠키에는 서버에서 발급한 세션 아이디를 저장 로그아웃 서버의 세션 정보를 삭제 클라이언트의 쿠키를 set-cookie로 세션 아이디의 키값을 무효한 값으로 갱신 express-session 세션을 대신 관리해 주는 모듈 req.session이 바로 세션 객체이며 req.session은 세션 객체에 세션 데이터를 저장하거나 불러오기 위해 사용 5. Session 실습 # server express의 각종 미들웨어 사용법을 배웠다. (특히 session, cookie) cors 옵션 설정에 대해서 배웠다. client axios로 서버와 정보를 주고받는 법을 배웠다. 6. CSRF # 사이트 간 요청 위조(Cross-site Request Forgery) 해커가 직접 데이터(response)에 접근할 수 없음 CSRF 공격을 위한 조건 쿠키를 사용한 로그인 예측할 수 있는 요청/parameter를 가지고 있어야함 CSRF를 막는 법 CSRF 토큰 사용하기 Same-site cookie 사용하기 ","date":"27 December 2021","permalink":"/posts/bootcamp/bc-14w-1/","section":"Posts","summary":"1. HTTPS # HTTPS = HTTP + Secure 무결성, 기밀성 인증서(Certification) 데이터 제공자 신원 보장 도메인 종속 CA(Certification Authority) 공인 인증서 발급 기관 비대칭 키 암호화 key A로 암호화, key B로 복호화 SSL(Secure Socket Layer) or TLS(Transport Layer Security)","title":"BC-14w-1 / [인증/보안] Session"},{"content":"MongoDB #1) NoSQL 기반의 비관계형 데이터베이스를 사용하는 경우 # 비구조적인 대용량의 데이터를 저장하는 경우 클라우드 컴퓨팅 및 저장 공간을 최대한 활용하는 경우 NoSQL은 수평적 확장의 형태로 증설하므로, 이론상 무한대로 서버를 계속 분산시켜 DB를 증설할 수 있습니다. 빠르게 서비스를 구축하고 데이터 구조를 자주 업데이트 하는 경우 2) Atlas Cloud # MongoDB에서는 아틀라스(Atlas)로 클라우드에 데이터베이스를 설정합니다.\n아틀라스는 GUI와 CLI로 데이터를 시각화, 분석, 내보내기, 그리고 빌드하는 데에 사용할 수 있습니다.\n아틀라스 사용자는 클러스터를 배포할 수 있으며, 클러스터는 그룹화된 서버에 데이터를 저장합니다.\n용어 정리\n레플리카 세트 동일한 데이터를 저장하는 소수의 연결된 머신을 뜻합니다. 레플리카 세트 중 하나에 문제가 발생하더라도, 데이터를 그대로 유지할 수 있습니다. 인스턴스 로컬 또는 클라우드에서 특정 소프트웨어를 실행하는 단일 머신, MongoDB에서는 데이터베이스입니다. 클러스터 데이터를 저장하는 서버 그룹으로 여러 대의 컴퓨터를 네트워크를 통해 연결하여 하나의 단일 컴퓨터처럼 동작하도록 제작한 컴퓨터를 뜻합니다. Atlas Cluster 생성하기\nCreate an Organization을 선택합니다. 원하는 Organization 이름을 입력합니다. Cloud Service가 MongoDB Atlas로 되어 있는지 확인하고 다음으로 넘어갑니다. Create Organization을 누릅니다. New Project를 누릅니다. 프로젝트의 이름을 정한 뒤 다음으로 넘어갑니다. Create Project를 누릅니다. Build a Cluster를 누릅니다. 맨 오른쪽 FREE라고 써진 옵션의 Create a cluster를 누릅니다. Cloud Provider \u0026amp; Region에서 현재 위치에서 가장 가까운 지역을 선택한 뒤 Create Cluster를 누릅니다. 이 작업은 1-2분 정도 소요될 수 있습니다. 이제 Atlas 클러스터가 생성되었으니 여러분의 IP 주소에 대한 액세스 권한을 부여하고 데이터베이스의 유저를 생성해야 합니다. 클러스터 화면에서 Connect를 선택합니다. 오른쪽에 Allow Access from Anywhere 을 선택하고 Add IP Address를 클릭하여 선택 사항을 확인합니다. Allowing access from anywhere 는 보안상 위험할 수 있으므로 프로덕션 단계에서 사용되는 클러스터는 이 기능이 활성화되어있지 않아야 합니다. Connect with the mongo shell을 선택합니다. 3) MongoDB Document # 도큐먼트(Document) 필드 - 값 쌍으로 저장된 데이터 필드(Field) 데이터 포인트를 위한 고유한 식별자 값(Value) 주어진 식별자와 연결된 데이터 컬렉션(Collection) MongoDB의 도큐먼트로 구성된 저장소입니다. 일반적으로 도큐먼트 간의 공통 필드가 있습니다. 데이터베이스 당 많은 컬렉션이 있고, 컬렉션 당 많은 도큐먼트가 있을 수 있습니다. 4) JSON vs. BSON # JSON은 텍스트 형식이기 때문에 읽기 쉽지만, 파싱이 느리고 메모리 사용이 비효율적입니다. 그리고 JSON은 기본 데이터 타입만을 지원하기 때문에, 사용할 수 있는 데이터 타입에 제약이 있습니다. BSON은 컴퓨터의 언어에 가까운 이진법에 기반을 둔 표현법입니다. 따라서 JSON 보다 메모리 사용이 효율적이며 빠르고, 가볍고, 유연합니다. 뿐만 아니라, BSON의 사용으로 더 많은 데이터 타입을 사용할 수 있습니다. 5) Importing \u0026amp; Exporting # MongoDB의 데이터는 BSON의 형태로 저장이 되고, 보통 읽기 쉬운 JSON의 형태로 출력됩니다. JSON 형식으로 데이터를 가져오고 내보내기 위한 명령어 mongoimport, mongoexport BSON 형식으로 가져오고 내보내기 위한 명령 mongorestore, mongodump ","date":"24 December 2021","permalink":"/posts/bootcamp/bc-13w-5/","section":"Posts","summary":"MongoDB #1) NoSQL 기반의 비관계형 데이터베이스를 사용하는 경우 # 비구조적인 대용량의 데이터를 저장하는 경우 클라우드 컴퓨팅 및 저장 공간을 최대한 활용하는 경우 NoSQL은 수평적 확장의 형태로 증설하므로, 이론상 무한대로 서버를 계속 분산시켜 DB를 증설할 수 있습니다.","title":"BC-13w-5 / [데이터베이스] NoSQL"},{"content":"","date":null,"permalink":"/tags/database/","section":"Tags","summary":"","title":"Database"},{"content":"ORM(Object-Relational Mapping) # Sequelize a promise-based Node.js ORM 지원하는 RDBMS 종류 Postgres MySQL MariaDB SQLite Microsoft SQL Server id, created_at 자동으로 생성 1. Sequelize init #npm install --save sequelize npm install --save-dev sequelize-cli npx sequelize-cli init config // config/config.json // 데이터베이스에 연결 { \u0026#34;development\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;패스워드\u0026#34;, \u0026#34;database\u0026#34;: \u0026#34;데이터베이스명\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;dialect\u0026#34;: \u0026#34;mysql\u0026#34; } } models # 모델 생성 # npx sequelize-cli model:generate --name 모델명 --attributes 필드1:필드1_타입,필드2:필드2_타입 npx sequelize-cli model:generate --name url --attributes url:string,title:string,visits:integer // models/url.js // 초기값 수정 \u0026#34;use strict\u0026#34;; const { Model } = require(\u0026#34;sequelize\u0026#34;); module.exports = (sequelize, DataTypes) =\u0026gt; { class url extends Model { /** * Helper method for defining associations. * This method is not a part of Sequelize lifecycle. * The `models/index` file will call this method automatically. */ static associate(models) { // define association here } } url.init( { url: DataTypes.STRING, title: DataTypes.STRING, visits: { type: DataTypes.INTEGER, defaultValue: 0 }, }, { sequelize, modelName: \u0026#34;url\u0026#34;, } ); return url; }; migrations // migrations/...-create-url.js // 초기값 수정 \u0026#34;use strict\u0026#34;; module.exports = { up: async (queryInterface, Sequelize) =\u0026gt; { await queryInterface.createTable(\u0026#34;urls\u0026#34;, { id: { allowNull: false, autoIncrement: true, primaryKey: true, type: Sequelize.INTEGER, }, url: { type: Sequelize.STRING, }, title: { type: Sequelize.STRING, }, visits: { type: Sequelize.INTEGER, defaultValue: 0, }, createdAt: { allowNull: false, type: Sequelize.DATE, defaultValue: Sequelize.literal(\u0026#34;NOW()\u0026#34;), }, updatedAt: { allowNull: false, type: Sequelize.DATE, defaultValue: Sequelize.literal(\u0026#34;NOW()\u0026#34;), }, }); }, down: async (queryInterface, Sequelize) =\u0026gt; { await queryInterface.dropTable(\u0026#34;urls\u0026#34;); }, }; seeders # 마이그레이션 실행 npx sequelize-cli db:migrate 2. Controller \u0026amp; Route #1) controllers # Finders findAll() findOne() findOrCreate() // controllers/links/index.js const { getUrlTitle, isValidUrl } = require(\u0026#34;../../modules/utils\u0026#34;); const { url } = require(\u0026#34;../../models\u0026#34;); module.exports = { get: async (req, res) =\u0026gt; { try { const data = await url.findAll(); res.status(200).json(data); } catch (err) { res.status(500).send(\u0026#34;Error Code 500\u0026#34;); } }, get_id: async (req, res) =\u0026gt; { const inputtedId = req.params.id; try { const data = await url.findOne({ where: { id: inputtedId } }); if (!data) { res.status(404).send(\u0026#34;Error Code 404\u0026#34;); } else { data.update({ visits: data.visits + 1 }); res.status(301).redirect(data.url); } } catch (err) { res.status(500).send(\u0026#34;Error Code 500\u0026#34;); } }, post: (req, res) =\u0026gt; { const inputtedUrl = req.body.url; if (!isValidUrl(inputtedUrl)) { res.status(400).send(\u0026#34;Error Code 404\u0026#34;); } else { getUrlTitle(inputtedUrl, async (err, title) =\u0026gt; { if (err) res.status(500).send(\u0026#34;Error Code 500\u0026#34;); else { try { const [data, created] = await url.findOrCreate({ where: { url: inputtedUrl, title: title }, }); res.status(201).json(data); } catch (err) { res.status(500).send(\u0026#34;Err Code 500\u0026#34;); } } }); } }, }; // modules/utils.js const request = require(\u0026#34;request\u0026#34;); const rValidUrl = /^(?!mailto:)(?:(?:https?|ftp):\\/\\/)?(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:\\/[^\\s]*)?$/i; exports.getUrlTitle = (url, cb) =\u0026gt; { request(url, function (err, res, html) { if (err) { console.log(\u0026#34;Error reading url heading: \u0026#34;, err); return cb(err); } else { const tag = /\u0026lt;title\u0026gt;(.*)\u0026lt;\\/title\u0026gt;/; const match = html.match(tag); console.log(match.length); const title = match ? match[1] : url; return cb(err, title); } }); }; exports.isValidUrl = (url) =\u0026gt; { return url.match(rValidUrl); }; 2) routes #// routes/links.js const express = require(\u0026#34;express\u0026#34;); const router = express.Router(); const controller = require(\u0026#34;../controllers/links/index\u0026#34;); /* GET links listing. */ router.get(\u0026#34;/\u0026#34;, controller.get); router.post(\u0026#34;/\u0026#34;, controller.post); router.get(\u0026#34;/:id\u0026#34;, controller.get_id); module.exports = router; ","date":"23 December 2021","permalink":"/posts/bootcamp/bc-13w-4/","section":"Posts","summary":"ORM(Object-Relational Mapping) # Sequelize a promise-based Node.","title":"BC-13w-4 / [데이터베이스] MVC(3) ORM"},{"content":"Server Example #// app.js const express = require(\u0026#34;express\u0026#34;); const indexRouter = require(\u0026#34;./routes\u0026#34;); const cors = require(\u0026#34;cors\u0026#34;); const morgan = require(\u0026#34;morgan\u0026#34;); const app = express(); const port = 4000; app.use( morgan(\u0026#34; :method :url :status :res[content-length] - :response-time ms\u0026#34;) ); app.use(cors()); app.use(express.urlencoded({ extended: true })); app.use(express.json()); app.use(\u0026#34;/\u0026#34;, indexRouter); module.exports = app.listen(port, () =\u0026gt; { console.log(` 🚀 Server is starting on ${port}`); }); routes #// routes/index.js const express = require(\u0026#34;express\u0026#34;); const router = express.Router(); const itemsRouter = require(\u0026#34;./items\u0026#34;); const usersRouter = require(\u0026#34;./users\u0026#34;); router.use(\u0026#34;/items\u0026#34;, itemsRouter); router.use(\u0026#34;/users\u0026#34;, usersRouter); module.exports = router; // routes/items.js const router = require(\u0026#34;express\u0026#34;).Router(); const controller = require(\u0026#34;./../controllers\u0026#34;); router.get(\u0026#34;/\u0026#34;, controller.items.get); module.exports = router; // routes/users.js const router = require(\u0026#34;express\u0026#34;).Router(); const controller = require(\u0026#34;./../controllers\u0026#34;); router.get(\u0026#34;/\u0026#34;, controller.items.get); module.exports = router; db #// config/config.js const dotenv = require(\u0026#34;dotenv\u0026#34;); dotenv.config(); const config = { development: { host: \u0026#34;localhost\u0026#34;, user: \u0026#34;root\u0026#34;, password: process.env.DATABASE_SPRINT_PASSWORD, database: \u0026#34;cmarket\u0026#34;, }, test: { host: \u0026#34;localhost\u0026#34;, user: \u0026#34;root\u0026#34;, password: process.env.DATABASE_SPRINT_PASSWORD, database: \u0026#34;cmarket_test\u0026#34;, }, }; module.exports = config; // db/index.js const mysql = require(\u0026#34;mysql\u0026#34;); const dotenv = require(\u0026#34;dotenv\u0026#34;); const config = require(\u0026#34;../config/config\u0026#34;); dotenv.config(); const con = mysql.createConnection( config[process.env.NODE_ENV || \u0026#34;development\u0026#34;] ); con.connect((err) =\u0026gt; { if (err) throw err; }); module.exports = con; model #// models/index.js const db = require(\u0026#34;../db\u0026#34;); module.exports = { items: { // 모든 상품을 가져옴 get: (callback) =\u0026gt; { const queryString = `SELECT * FROM items`; db.query(queryString, (error, result) =\u0026gt; { callback(error, result); }); }, }, orders: { // 해당 유저가 작성한 모든 주문을 가져옴 get: (userId, callback) =\u0026gt; { const queryString = ` SELECT o.id, o.created_at, o.total_price, i.name, i.price,i.image, oi.order_quantity FROM orders AS o JOIN order_items AS oi ON o.id = oi.order_id JOIN items AS i ON oi.item_id = i.id WHERE o.user_id = ?;`; const params = [userId]; db.query(queryString, params, (err, result) =\u0026gt; { callback(err, result); }); }, // 해당 유저의 주문 요청을 데이터베이스에 생성 post: (userId, orders, totalPrice, callback) =\u0026gt; { const queryString = `INSERT INTO orders (user_id, total_price) VALUES (?, ?);`; const params = [userId, totalPrice]; db.query(queryString, params, (err, result) =\u0026gt; { if (result) { const queryString = ` INSERT INTO order_items (item_id, order_quantity, order_id) VALUES ?;`; const values = orders.map((order) =\u0026gt; [ order.itemId, order.quantity, result.insertId, ]); return db.query(queryString, [values], (err, result) =\u0026gt; { callback(err, result); }); } callback(err, result); }); }, }, }; controllers #// controllers/index.js const con = require(\u0026#34;../db\u0026#34;); const models = require(\u0026#34;../models\u0026#34;); module.exports = { items: { get: (req, res) =\u0026gt; { models.items.get((error, result) =\u0026gt; { if (error) { res.status(500).send(\u0026#34;Internal Server Error\u0026#34;); } else { res.status(200).json(result); } }); }, }, orders: { get: (req, res) =\u0026gt; { const userId = req.params.userId; if (!userId) { return res.status(400).send(\u0026#34;Error 400\u0026#34;); } models.orders.get(userId, (error, result) =\u0026gt; { if (error) { res.status(500).send(\u0026#34;Internal Server Error\u0026#34;); } else { res.status(200).json(result); } }); }, post: (req, res) =\u0026gt; { const userId = req.params.userId; const { orders, totalPrice } = req.body; const params = [userId, orders, totalPrice]; if (!orders || !totalPrice) { return res.status(400).send(\u0026#34;Error 400\u0026#34;); } models.orders.post(...params, (error, result) =\u0026gt; { if (error) { res.status(500).send(\u0026#34;Internal Server Error\u0026#34;); } else { res.status(201).json(result); } }); }, }, }; ","date":"22 December 2021","permalink":"/posts/bootcamp/bc-13w-3/","section":"Posts","summary":"Server Example #// app.","title":"BC-13w-3 / [데이터베이스] MVC(2)"},{"content":"1. MVC(Model-View-Controller) # SW Architecture Design Pattern separates application functionalities 1) Model # knowledge handles data interaction with \u0026ldquo;Database\u0026rdquo; and \u0026ldquo;Controller\u0026rdquo; 2) View # visual representation of a mode what the users see(UI) interaction with \u0026ldquo;Controller\u0026rdquo; 3) Controller # receives input(\u0026ldquo;Client\u0026rdquo;) process requests get data from a \u0026ldquo;Model\u0026rdquo; pass data to the \u0026ldquo;View\u0026rdquo; 2. js -\u0026gt; local database #-- schema.sql CREATE TABLE users ( id INT AUTO_INCREMENT, username varchar(255), PRIMARY KEY (id) ); CREATE TABLE items ( id INT AUTO_INCREMENT, name varchar(255), price INT, image varchar(255), PRIMARY KEY (id) ); CREATE TABLE orders ( id INT AUTO_INCREMENT, user_id INT, total_price INT, created_at datetime DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (id) ); CREATE TABLE order_items ( id INT AUTO_INCREMENT, order_id INT, item_id INT, order_quantity INT, PRIMARY KEY (id) ); ALTER TABLE orders ADD FOREIGN KEY (user_id) REFERENCES users (id); ALTER TABLE order_items ADD FOREIGN KEY (order_id) REFERENCES orders (id); ALTER TABLE order_items ADD FOREIGN KEY (item_id) REFERENCES items (id); -- seed.sql INSERT INTO items (name, price, image) VALUES (\u0026#34;노른자 분리기\u0026#34;, 9900, \u0026#34;../images/egg.png\u0026#34;), (\u0026#34;2020년 달력\u0026#34;, 12000, \u0026#34;../images/2020.jpg\u0026#34;), (\u0026#34;개구리 안대\u0026#34;, 2900, \u0026#34;../images/frog.jpg\u0026#34;), (\u0026#34;뜯어온 보도블럭\u0026#34;, 4900, \u0026#34;../images/block.jpg\u0026#34;), (\u0026#34;칼라 립스틱\u0026#34;, 2900, \u0026#34;../images/lip.jpg\u0026#34;), (\u0026#34;잉어 슈즈\u0026#34;, 3900, \u0026#34;../images/fish.jpg\u0026#34;), (\u0026#34;웰컴 매트\u0026#34;, 6900, \u0026#34;../images/welcome.jpg\u0026#34;), (\u0026#34;강시 모자\u0026#34;, 9900, \u0026#34;../images/hat.jpg\u0026#34;); INSERT INTO users (username) VALUES (\u0026#34;김코딩\u0026#34;) mysql -u root \u0026lt; server/schema.sql -p -D데이터베이스_이름 mysql -u root \u0026lt; server/seed.sql -p -D데이터베이스_이름 ","date":"21 December 2021","permalink":"/posts/bootcamp/bc-13w-2/","section":"Posts","summary":"1. MVC(Model-View-Controller) # SW Architecture Design Pattern separates application functionalities 1) Model # knowledge handles data interaction with \u0026ldquo;Database\u0026rdquo; and \u0026ldquo;Controller\u0026rdquo; 2) View # visual representation of a mode what the users see(UI) interaction with \u0026ldquo;Controller\u0026rdquo; 3) Controller # receives input(\u0026ldquo;Client\u0026rdquo;) process requests get data from a \u0026ldquo;Model\u0026rdquo; pass data to the \u0026ldquo;View\u0026rdquo; 2.","title":"BC-13w-2 / [데이터베이스] MVC(1)"},{"content":"추가 요구조건과 스키마 #1) schema #CREATE TABLE `category` ( `id` int PRIMARY KEY AUTO_INCREMENT, `name` varchar(255) not NULL ); CREATE TABLE `content_category` ( `id` int PRIMARY KEY AUTO_INCREMENT, `contentId` int not NULL, FOREIGN KEY (`contentId`) REFERENCES `content` (`id`), `categoryId` int not NULL, FOREIGN KEY (`categoryId`) REFERENCES `category` (`id`) ); CREATE TABLE `role` ( `id` int PRIMARY KEY AUTO_INCREMENT, `name` varchar(255) not NULL ); ALTER TABLE `user` ADD roleId int; ALTER TABLE `user` ADD FOREIGN KEY (`roleId`) REFERENCES `role` (`id`); 2) script #// category 테이블의 구조를 보기위한 SQL을 작성해주세요. const PART5_1 = `DESC category`; // category 테이블에 존재하는 데이터에서 id, name을 찾는 SQL을 작성해주세요. const PART5_2 = `SELECT id, name FROM category`; // user의 name과 email 그리고 그 user가 속한 role name(컬럼명: roleName)을 찾기 위한 SQL을 작성해주세요. // 속한 role이 없더라도, user의 name과 email,role name을 모두 찾아야합니다. const PART5_3 = ` SELECT user.name, user.email, role.name AS roleName FROM user LEFT JOIN role ON user.roleId = role.id `; // 어느 role에도 속하지 않는 user의 모든 컬럼 데이터를 찾기위한 SQL을 작성해주세요. const PART5_4 = ` SELECT * FROM user WHERE roleId IS NULL `; // jiSungPark이 작성한 content의 title을 찾기위한 SQL을 작성해주세요. const PART5_5 = ` SELECT content.title FROM user JOIN content ON user.id = content.userId WHERE user.name = \u0026#34;jiSungPark\u0026#34; `; // category의 name이 soccer인 content의 title, body, created_at, user의 name을 찾기위한 SQL을 작성해주세요. const PART5_6 = ` SELECT content.title, content.body, content.created_at, user.name FROM user JOIN content ON user.id = content.userId JOIN content_category ON content.id = content_category.contentId JOIN category ON content_category.categoryId = category.id WHERE category.name = \u0026#34;soccer\u0026#34; `; // duRiCha가 작성한 글의 개수 (컬럼명: ContentCount)를 출력하기 위한 SQL을 작성해주세요. const PART5_2_9 = ` SELECT COUNT(*) AS ContentCount FROM content JOIN user ON content.userId = user.id WHERE user.name = \u0026#34;duRiCha\u0026#34; `; // 각 user(컬럼명: name)가 작성한 글의 개수 (컬럼명: ContentCount)를 출력하기 위한 SQL을 작성해주세요. const PART5_2_10 = ` SELECT user.name AS name, COUNT(content.userId) AS ContentCount FROM user LEFT JOIN content ON user.id = content.userId GROUP BY user.name `; ","date":"20 December 2021","permalink":"/posts/bootcamp/bc-13w-1/","section":"Posts","summary":"추가 요구조건과 스키마 #1) schema #CREATE TABLE `category` ( `id` int PRIMARY KEY AUTO_INCREMENT, `name` varchar(255) not NULL ); CREATE TABLE `content_category` ( `id` int PRIMARY KEY AUTO_INCREMENT, `contentId` int not NULL, FOREIGN KEY (`contentId`) REFERENCES `content` (`id`), `categoryId` int not NULL, FOREIGN KEY (`categoryId`) REFERENCES `category` (`id`) ); CREATE TABLE `role` ( `id` int PRIMARY KEY AUTO_INCREMENT, `name` varchar(255) not NULL ); ALTER TABLE `user` ADD roleId int; ALTER TABLE `user` ADD FOREIGN KEY (`roleId`) REFERENCES `role` (`id`); 2) script #// category 테이블의 구조를 보기위한 SQL을 작성해주세요.","title":"BC-13w-1 / [데이터베이스] 관계형 데이터베이스(3)"},{"content":" An intuitive Redux side effect manager; middleware\nRef. redux-saga\nRef. redux-saga/effects API\nnpm i redux-saga 1) createSagaMiddleware() \u0026amp; sagaMiddleware.run() #import { applyMiddleware, createStore } from \u0026#34;redux\u0026#34;; import reducers from \u0026#34;./modules/reducers\u0026#34;; import createSagaMiddleware from \u0026#34;redux-saga\u0026#34;; import rootSaga from \u0026#34;./modules/rootSaga\u0026#34;; // sagaMiddleware 생성 const sagaMiddleware = createSagaMiddleware(); const store = createStore( reducers, // sagaMiddleware 등록 applyMiddleware(sagaMiddleware) ); // sagaMiddleware 실행 준비 sagaMiddleware.run(rootSaga); export default store; 2) rootSaga #import { all } from \u0026#34;redux-saga/effects\u0026#34;; import { 사가_이펙트, ... } from \u0026#34;./...\u0026#34;; export default function* rootSaga() { yield all([사가_이펙트, ...]); } 3) redux-saga in a Module #import axios form \u0026#34;axios\u0026#34; import { put, call, takeEvery } from \u0026#34;redux-saga/effects\u0026#34;; // 1) Saga Function 작성 function* 사가_함수(action) { try { yield put(액션_생성자_시작()); // yield delay(ms) const res = yield call(axios.get, \u0026#34;경로\u0026#34;); yield put(액션_생성자_성공(res.data)); } catch (err) { yield put(액션_생성자_실패(err)); } } // 2) Saga Type 정의 const 사가_타입 = \u0026#34;액션_사가_타입\u0026#34;; // 3) Saga Creator 작성 // params(payload)는 옵션 export function 사가_생성자(params) { return { type: 사가_타입, param, ... }; } // 4) Saga Effect 작성 export function* 사가_이펙트() { yield throttle(ms, 사가_타입, 사가_함수); ... } 4) Saga Creator in a Container #import { useDispatch } from \u0026#34;react-redux\u0026#34;; import { useCallback } from \u0026#34;react\u0026#34;; import { 사가_생성자 } from \u0026#34;../redux/modules/모듈\u0026#34;; const dispatch = useDispatch(); const getUsers = useCallback(() =\u0026gt; { dispatch(사가_생성자(옵션)); }, [dispatch]); ","date":"19 December 2021","permalink":"/posts/bootcamp/bc-12w-7/","section":"Posts","summary":"An intuitive Redux side effect manager; middleware","title":"BC-12w-7 / {FC} Redux-saga"},{"content":" A Predictable State Container for JS Apps\nHave a Single Store\nRef. Redux API\nnpm i redux react-redux Redux Basic⋯ #1. Action #// 1) Action Type 정의 const 액션_타입 = \u0026#34;액션_타입\u0026#34;; // 2) Action Creator(Action 객체 반환) 작성 // params(payload)는 옵션 function 액션_생성자(params) { return { type: 액션_타입, parm: 값, ... }; } 2. Reducer # Reducer has to be a \u0026ldquo;Pure Function\u0026rdquo; State has to be \u0026ldquo;Immutable\u0026rdquo; // 3) combineReducers로 reducers 작성 import { combineReducers } from \u0026#34;redux\u0026#34;; const reducers = combineReducers({ 리듀서 ..., }); export default reducers; // 4) 개별 Reducer 작성 function 리듀서(state = initState, action) { if (action.type === ??) return newState; // params(payload) 있으면 action.param 사용 가능 ... return state } 3. Store #import reducers from \u0026#34;./modules/reducers\u0026#34;; import { createStore } from \u0026#34;redux\u0026#34;; // 5) reducers로 store 생성 const store = createStore(reducers); // Store의 State들을 반환 store.getState(); // Store에 Action을 보냄 store.dispatch(액션_생성자(옵션)); // Change listener // unsubscribe() 할 때까지 변화 시 subscribe 함수 작동 const unsubscribe = store.subscribe(() =\u0026gt; {}); export default store; 4. Provider #import { Provider } from \u0026#34;react-redux\u0026#34;; import store from \u0026#34;./redux/store\u0026#34;; // 6) Provider로 App 전체에 전달 \u0026lt;Provider store={store}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/Provider\u0026gt;; 5. useSelector() \u0026amp; useDispatch() #import { useSelector, useDispatch } from \u0026#34;react-redux\u0026#34;; import 액션_생성자 from \u0026#34;./redux/modules/모듈\u0026#34;; // 최적화를 위해서는 reducer의 결과로 나온 state에서 각각 data를 뽑아서 할당 const state = useSelector((state) =\u0026gt; state.reducer.data); const dispatch = useDispatch(); const func = useCallback(() =\u0026gt; { dispatch(액션_생성자(옵션)); }, [dispatch]); *Ducks Pattern\n\u0026ldquo;Reducer\u0026quot;는 export default \u0026ldquo;Action Type\u0026quot;과 \u0026ldquo;Action Creator\u0026quot;는 export project components/ \u0026hellip; containers/ \u0026hellip; redux/ modules/ reducers.js filter.js todos.js users.js store.js app.js index.js Redux Advance #1. Redux Middleware # 디스패치 앞뒤에 코드 추가 가능 import { applyMiddleware, createStore } from \u0026#34;redux\u0026#34;; import reducers from \u0026#34;./reducers/reducers\u0026#34;; const store = createStore(reducers, applyMiddleware(미들웨어)); export default store; 2. redux-devtools-extension^ # Chrome에서 Redux Extension 활성화 npm i redux-devtools-extension -D import { applyMiddleware, createStore } from \u0026#34;redux\u0026#34;; import reducer from \u0026#34;./reducers/reducer\u0026#34;; import { composeWithDevTools } from \u0026#34;redux-devtools-extension\u0026#34;; // const store = createStore(reducer, composeWithDevTools()); const store = createStore(reducer, composeWithDevTools(applyMiddleware())); export default store; 3. redux-thunk^ ⋯ # Redux의 비동기 처리를 위한 라이브러리 미들웨어 Action Creator가 함수 반환 가능 npm i redux-thunk import { applyMiddleware, createStore } from \u0026#34;redux\u0026#34;; import reducer from \u0026#34;./reducers/reducer\u0026#34;; import { composeWithDevTools } from \u0026#34;redux-devtools-extension\u0026#34;; import thunk from \u0026#34;redux-thunk\u0026#34;; const store = createStore(reducer, composeWithDevTools(applyMiddleware(thunk))); export default store; 4. connected-react-router^ ⋯ #npm i connected-react-router Redux에서 관리하는 history를 React에서 사용하게 만드는 미들웨어 // history 객체 생성 import { createBrowserHistory } from \u0026#34;history\u0026#34;; const history = createBrowserHistory(); export default history; // middleware 등록 ... import { routerMiddleware } from \u0026#34;connected-react-router\u0026#34;; const store = createStore( reducers, composeWithDevTools(applyMiddleware(routerMiddleware(history))) ); export default store; // router 리듀서 작성 ... import { connectRouter } from \u0026#34;connected-react-router\u0026#34;; ... const reducers = combineReducers({ router: connectRouter(history), ... }); export default reducers; // ConnectedRouter로 history 전달 ... import { ConnectedRouter } from \u0026#34;connected-react-router\u0026#34;; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;Provider store={store}\u0026gt; \u0026lt;ConnectedRouter history={history}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ConnectedRouter\u0026gt; \u0026lt;/Provider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;) ); push(\u0026ldquo;경로\u0026rdquo;)가 Action Creator 처럼 쓰임\n5. redux-logger #npm i redux-logger -D redux에서 dispatch()의 실행으로 바뀔 prevState와 바뀐 newState가 콘솔에 찍혀 디버깅 쉽게 해주는 라이브러리 ","date":"18 December 2021","permalink":"/posts/bootcamp/bc-12w-6/","section":"Posts","summary":"A Predictable State Container for JS Apps","title":"BC-12w-6 / {FC} Redux"},{"content":"1. Instagram Schema Design # https://dbdiagram.io/home 2. 데이터베이스 연결과 스키마 #.env # .gitignore 필요 DATABASE_USERNAME=\u0026#39;root\u0026#39; DATABASE_PASSWORD=\u0026#39;1234\u0026#39; DATABASE_NAME=\u0026#39;mylearnsql\u0026#39; Dotenv #const dotenv = require(\u0026#39;dotenv\u0026#39;); const mysql = require(\u0026#39;mysql\u0026#39;); ... constructor() { super(); this.config = { host: \u0026#39;localhost\u0026#39;, user: process.env.DATABASE_USERNAME || \u0026#39;root\u0026#39;, password: process.env.DATABASE_PASSWORD || \u0026#39;\u0026#39;, database: process.env.DATABASE_NAME || \u0026#39;learnmysql\u0026#39; }; init() { this.connection = mysql.createConnection({ ...this.config, multipleStatements: true }); ... schema.sql #USE learnmysql; CREATE TABLE `user` ( `id` int PRIMARY KEY AUTO_INCREMENT, `name` varchar(255) not NULL, `email` varchar(255) not NULL ); CREATE TABLE `content` ( `id` int PRIMARY KEY AUTO_INCREMENT, `title` varchar(255) not NULL, `body` varchar(255) not NULL, `created_at` timestamp not NULL DEFAULT CURRENT_TIMESTAMP, `userId` int, FOREIGN KEY (`userId`) REFERENCES `user` (`id`) ); Script #// 현재 있는 데이터베이스에 존재하는 모든 테이블 정보를 보기위한 SQL을 작성해주세요. const PART3_1 = `show tables`; // user 테이블의 구조를 보기위한 SQL을 작성해주세요. const PART3_2 = `DESC user`; // content 테이블의 구조를 보기위한 SQL을 작성해주세요. const PART3_3 = `DESC content`; + Redux with FastCampus #1. Redux 개요 # Single Store [만들기] 단일 스토어 사용 준비 import redux Action을 정의하고, Action을 사용하는, Reducer를 만들고, Reducer들을 합침 최종 합쳐진 Reducer를 인자로, Single Store를 만듦 [사용하기] 준비한 스토어를 리액트 컴포넌트에서 사용 import react-redux connect 함수를 이용해서 컴포넌트에 연결 npm i redux 1) Actions # Action of Redux\n액션은 사실 그냥 객체(object) 두 가지 형태의 액션 payload 없는 액션 { type: \u0026lsquo;TEST\u0026rsquo; } payload 있는 액션 { type: \u0026lsquo;TEST\u0026rsquo;, params: \u0026lsquo;hello\u0026rsquo; } type만이 필수 프로퍼티이며, type은 문자열 Action Creator of Redux\n함수를 통해 액션을 생성해서, 액션 객체를 리턴 function 액션생성자(...arg) { return 액션; } Redux에서 Action의 역할\n액션 생성자를 통해 액션을 만듦 만든 액션 객체를 리덕스 스토어로 보냄 리덕스 그토어가 액션 객체를 받으면 스토어의 상태 값이 변경 변경된 상태값에 의해 해당 상태를 이용하고 있는 컴포넌트가 변경 Action 준비\n액션의 타입을 정의하여 변수로 빼는 단계 강제는 아닙니다. (그러므로 안해도 됩니다.) 그냥 타입을 문자열로 넣기에는 실수를 유발할 가능성이 큽니다. 미리 정의한 변수를 사용하면, 스펠링에 주의를 덜 기울여도 됩니다. 액션 객체를 만들어 내는 함수를 만드는 단계 하나의 액션 객체를 만들기 위해 하나의 함수를 만들어냅니다. 액션의 타입은 미리 정의한 타입 변수로 부터 가져와서 사용합니다. /* actions.js */ // 1) 액션의 type 정의 // 액션의 타입 =\u0026gt; 액션 생성자 이름 // ADD_TODO =\u0026gt; addTodo export const ADD_TODO = \u0026#34;ADD_TODO\u0026#34;; export const COMPLETE_TODO = \u0026#34;COMPLETE_TODO\u0026#34;; export const SHOW_ALL = \u0026#34;SHOW_ALL\u0026#34;; export const SHOW_COMPLETE = \u0026#34;SHOW_COMPLETE\u0026#34;; // 2) 액션 생산자 // 액션의 타입은 미리 정의한 타입으로 부터 가져와서 사용하며, // 사용자가 인자로 주지 않습니다. export function addTodo(text) { return { type: ADD_TODO, text }; // { type: ADD_TODO, text: \u0026#34;todo\u0026#34; } } export function completeTodo(index) { return { type: COMPLETE_TODO, index }; // { type: COMPLETE_TODO, index: num } } export function showAll() { return { type: SHOW_ALL }; // { type: SHOW_ALL } } export function showComplete() { return { type: SHOW_COMPLETE }; // { type: SHOW_COMPLETE } } 2) Reducers # 액션을 주면, 그 액션이 적용된 결과를 만듦 Pure Function 시간에 따라 달라지는 결과를 가지는 등의 코드는 들어가면 안됨 Immutable 원래 state와 바뀐 state가 별도로 만들어 져야함 리듀서를 통해 스테이트가 달라졌음을 리덕스가 인지하는 방식이라서 function 리듀서(previousState, action) { return newState; } 액션을 받아서 스테이트를 리턴하는 구조 인자로 들어오는 previousState 와 리턴되는 newState 는 다른 참조를 가지도록 해야함(immutable) /* reducers.js */ import { ADD_TODO, COMPLETE_TODO, SHOW_ALL, SHOW_COMPLETE } from \u0026#34;./actions\u0026#34;; const initState = { todos: [], filter: \u0026#34;ALL\u0026#34; }; export function todoApp(prevState = initState, action) { if (action.type === ADD_TODO) { return { ...prevState, todos: [...prevState.todos, { text: action.text, completed: false }], }; } if (action.type === COMPLETE_TODO) { return { ...prevState, todos: prevState.todos.map((todo, index) =\u0026gt; { if (index === action.index) { return { ...todo, completed: true }; } return todo; }), }; } if (action.type === SHOW_COMPLETE) { return { ...prevState, filter: \u0026#34;COMPLETE\u0026#34;, }; } if (action.type === SHOW_ALL) { return { ...prevState, filter: \u0026#34;ALL\u0026#34;, }; } return prevState; } 3) createStore \u0026amp; dispatch \u0026amp; subscribe #/* store.js */ import { todoApp } from \u0026#34;./reducers\u0026#34;; import { createStore } from \u0026#34;redux\u0026#34;; import { addTodo, completeTodo } from \u0026#34;./actions\u0026#34;; const store = createStore(todoApp); setTimeout(() =\u0026gt; { store.dispatch(addTodo(\u0026#34;hello\u0026#34;)); setTimeout(() =\u0026gt; { store.dispatch(completeTodo(0)); }, 1000); }, 1000); export default store; /* index.js */ ... import store from \u0026#34;./redux/store\u0026#34;; import { addTodo, completeTodo, showAll, showComplete } from \u0026#34;./redux/actions\u0026#34;; /* const unsubscribe = store.subscribe(() =\u0026gt; { console.log(store.getState()); }); store.dispatch(addTodo(\u0026#34;코딩\u0026#34;)); store.dispatch(addTodo(\u0026#34;운동\u0026#34;)); store.dispatch(addTodo(\u0026#34;독서\u0026#34;)); unsubscribe(); store.dispatch(addTodo(\u0026#34;코딩\u0026#34;)); store.dispatch(addTodo(\u0026#34;운동\u0026#34;)); store.dispatch(addTodo(\u0026#34;독서\u0026#34;)); console.log(store.getState()); */ store.subscribe(() =\u0026gt; { console.log(store.getState()); }); store.dispatch(addTodo(\u0026#34;할일\u0026#34;)); // {todos: [{text: \u0026#34;할일\u0026#34;, completed: false}], filter: \u0026#34;ALL\u0026#34;} store.dispatch(completeTodo(0)); // {todos: [{text: \u0026#34;할일\u0026#34;, completed: true}], filter: \u0026#34;ALL\u0026#34;} store.dispatch(showComplete()); // {todos: [{text: \u0026#34;할일\u0026#34;, completed: true}], filter: \u0026#34;COMPLETE\u0026#34;} store.dispatch(showAll()); // {todos: [{text: \u0026#34;할일\u0026#34;, completed: true}], filter: \u0026#34;ALL\u0026#34;} ... store.getState() store.dispatch(액션);\nstore.dispatch(액션생성자()); const unsubscribe = store.subscribe(() =\u0026gt; {}); 리턴이 unsubscribe 즉, unsubscribe(); 하면 제거 2. combineReducers #1) action.js #// action.js // 1) 액션의 type 정의 export const ADD_TODO = \u0026#34;ADD_TODO\u0026#34;; export const COMPLETE_TODO = \u0026#34;COMPLETE_TODO\u0026#34;; export const SHOW_ALL = \u0026#34;SHOW_ALL\u0026#34;; export const SHOW_COMPLETE = \u0026#34;SHOW_COMPLETE\u0026#34;; // 2) 액션 생산자 export function addTodo(text) { return { type: ADD_TODO, text }; // { type: ADD_TODO, text: \u0026#34;todo\u0026#34; } } export function completeTodo(index) { return { type: COMPLETE_TODO, index }; // { type: COMPLETE_TODO, index: num } } export function showAll() { return { type: SHOW_ALL }; // { type: SHOW_ALL } } export function showComplete() { return { type: SHOW_COMPLETE }; // { type: SHOW_COMPLETE } } 2) reducers #// reducers/reducer.js // combineReducers import { combineReducers } from \u0026#34;redux\u0026#34;; import todos from \u0026#34;./todos\u0026#34;; import filter from \u0026#34;./filter\u0026#34;; const reducer = combineReducers({ todos: todos, filter: filter, }); export default reducer; // reducers/todos.js import { ADD_TODO, COMPLETE_TODO } from \u0026#34;../actions\u0026#34;; const initState = []; export default function todos(prevState = initState, action) { if (action.type === ADD_TODO) { return [...prevState, { text: action.text, completed: false }]; } if (action.type === COMPLETE_TODO) { return prevState.map((todo, index) =\u0026gt; { if (index === action.index) { return { ...todo, completed: true }; } return todo; }); } return prevState; } // reducers/filter.js import { SHOW_ALL, SHOW_COMPLETE } from \u0026#34;../actions\u0026#34;; const initState = \u0026#34;ALL\u0026#34;; export default function filter(prevState = initState, action) { if (action.type === SHOW_COMPLETE) { return \u0026#34;COMPLETE\u0026#34;; } if (action.type === SHOW_ALL) { return \u0026#34;ALL\u0026#34;; } return prevState; } 3) store.js #/* store.js */ import reducer from \u0026#34;./reducers/reducer\u0026#34;; import { createStore } from \u0026#34;redux\u0026#34;; const store = createStore(reducer); export default store; 3. React-Redux # index.js App.js /redux actions.js /reducer reducer.js /reducers todos.js filter.js store.js /components TodoList.jsx TodoForm.jsx /containers TodoListContainer.jsx TodoFormContainer.jsx A. Redux #1) actions.js #// redux/actions.js // 1) 액션 Type export const ADD_TODO = \u0026#34;ADD_TODO\u0026#34;; export const COMPLETE_TODO = \u0026#34;COMPLETE_TODO\u0026#34;; export const SHOW_ALL = \u0026#34;SHOW_ALL\u0026#34;; export const SHOW_COMPLETE = \u0026#34;SHOW_COMPLETE\u0026#34;; // 2) 액션 생성자 export function addTodo(text) { return { type: ADD_TODO, text }; // { type: ADD_TODO, text: \u0026#34;todo\u0026#34; } } export function completeTodo(index) { return { type: COMPLETE_TODO, index }; // { type: COMPLETE_TODO, index: num } } export function showAll() { return { type: SHOW_ALL }; // { type: SHOW_ALL } } export function showComplete() { return { type: SHOW_COMPLETE }; // { type: SHOW_COMPLETE } } 2) /reducer # combineReducers()\n// redux/reducer/reducer.js import { combineReducers } from \u0026#34;redux\u0026#34;; import todos from \u0026#34;./reducers/todos\u0026#34;; import filter from \u0026#34;./reducers/filter\u0026#34;; const reducer = combineReducers({ todos: todos, filter: filter, }); export default reducer; // redux/reducer/reducers/todos.js import { ADD_TODO, COMPLETE_TODO } from \u0026#34;../../actions\u0026#34;; const initState = []; export default function todos(state = initState, action) { if (action.type === ADD_TODO) { return [...state, { text: action.text, completed: false }]; } if (action.type === COMPLETE_TODO) { return state.map((todo, index) =\u0026gt; { if (index === action.index) { return { ...todo, completed: true }; } return todo; }); } return state; } // redux/reducer/reducers/filter.js import { SHOW_ALL, SHOW_COMPLETE } from \u0026#34;../../actions\u0026#34;; const initState = \u0026#34;ALL\u0026#34;; export default function filter(state = initState, action) { if (action.type === SHOW_ALL) { return \u0026#34;ALL\u0026#34;; } if (action.type === SHOW_COMPLETE) { return \u0026#34;COMPLETE\u0026#34;; } return state; } 3) store.js # createStore()\n/* redux/store.js */ import reducer from \u0026#34;./reducer/reducer\u0026#34;; import { createStore } from \u0026#34;redux\u0026#34;; const store = createStore(reducer); export default store; B. react-redux # npm i react-redux 1) index.js # Provider\n// index.js import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import App from \u0026#34;./App\u0026#34;; import reportWebVitals from \u0026#34;./reportWebVitals\u0026#34;; import store from \u0026#34;./redux/store\u0026#34;; import { Provider } from \u0026#34;react-redux\u0026#34;; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;Provider store={store}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/Provider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;) ); reportWebVitals(); 2) containers # useSelector()\n// containers/TodoListContainer.jsx import TodoList from \u0026#34;../components/TodoList\u0026#34;; import { useSelector } from \u0026#34;react-redux\u0026#34;; export default function TodoListContainer() { const todos = useSelector((store) =\u0026gt; store.todos); return \u0026lt;TodoList todos={todos} /\u0026gt;; } useDispatch()\n// containers/TodoFormContainer.jsx import TodoForm from \u0026#34;../components/TodoForm\u0026#34;; import { useDispatch } from \u0026#34;react-redux\u0026#34;; import { useCallback } from \u0026#34;react\u0026#34;; import { addTodo } from \u0026#34;../redux/actions\u0026#34;; export default function TodoFormContainer() { const dispatch = useDispatch(); const add = useCallback( (text) =\u0026gt; { dispatch(addTodo(text)); }, [dispatch] ); return \u0026lt;TodoForm add={add} /\u0026gt;; } // App.js import TodoFormContainer from \u0026#34;./containers/TodoFormContainer\u0026#34;; import TodoListContainer from \u0026#34;./containers/TodoListContainer\u0026#34;; function App() { return ( \u0026lt;\u0026gt; \u0026lt;TodoFormContainer /\u0026gt; \u0026lt;TodoListContainer /\u0026gt; \u0026lt;/\u0026gt; ); } export default App; 3) components #// components/TodoList.jsx export default function TodoList({ todos }) { return ( \u0026lt;ul\u0026gt; {todos.map((todo) =\u0026gt; { return \u0026lt;li\u0026gt;{todo.text}\u0026lt;/li\u0026gt;; })} \u0026lt;/ul\u0026gt; ); } // components/TodoForm.jsx import { useRef } from \u0026#34;react\u0026#34;; export default function TodoForm({ add }) { const inputRef = useRef(); return ( \u0026lt;div\u0026gt; \u0026lt;input ref={inputRef} /\u0026gt; \u0026lt;button onClick={click}\u0026gt;add\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); function click() { add(inputRef.current.value); } } ","date":"17 December 2021","permalink":"/posts/bootcamp/bc-12w-5/","section":"Posts","summary":"1. Instagram Schema Design # https://dbdiagram.","title":"BC-12w-5 / [데이터베이스] 관계형 데이터베이스(2) + {FC} Redux Basic"},{"content":"1. SQL intro #1) 데이터베이스의 필요성 # In-Memory 프로그램이 종료될 때 해당 프로그램이 사용하던 데이터도 사라짐 File I/O 데이터가 필요할 때마다 전체 파일을 매번 읽어야 함 파일의 크기가 커질수록 이 작업은 버겁고, 비효율적임 데이터베이스를 사용하여 데이터를 영속성있게(persistently) 저장할 필요가 있음 2) Structured Query Language (SQL) # 데이터베이스 언어로, 주로 관계형 데이터베이스에서 사용 MySQL, Oracle, SQLite, PostgreSQL 등 다양한 데이터베이스에서 SQL 구문을 사용 2. SQL vs. NoSQL #1) 관계형 데이터베이스 # SQL(구조화 쿼리 언어) MySQL, Oracle, SQLite, PostgresSQL, MariaDB 등 테이블의 구조와 데이터 타입 등을 사전에 정의하고, 테이블에 정의된 내용에 알맞은 형태의 데이터만 삽입할 수 있음 행(row)과 열(column)로 구성된 테이블에 데이터를 저장 각 열은 하나의 속성에 대한 정보를 저장하고, 행에는 각 열의 데이터 형식에 맞는 데이터가 저장 관계형 데이터베이스에서는 스키마가 뚜렷하게 보임 사용 해야하는 상황 데이터베이스의 ACID 성질을 준수해야 하는 경우 소프트웨어에 사용되는 데이터가 구조적이고 일관적인 경우 2) 비관계형 데이터베이스 # NoSQL(비구조화 쿼리 언어) Ex. MongoDB, Casandra 등 데이터가 고정되어 있지 않은 데이터베이스 데이터를 읽어올 때 스키마에 따라 데이터를 읽음(schema on read) 사용 해야하는 상황 데이터의 구조가 거의 또는 전혀 없는 대용량의 데이터를 저장하는 경우 클라우드 컴퓨팅 및 저장 공간을 최대한 활용하는 경우 빠르게 서비스를 구축하는 과정에서 데이터 구조를 자주 업데이트하는 경우 3. ACID # 데이터베이스 내에서 일어나는 하나의 트랜잭션(transaction)의 안전성을 보장하기 위해 필요한 성질 Atomicity(원자성) 하나의 트랜잭션에 속해있는 모든 작업이 전부 성공하거나 전부 실패해서 결과를 예측할 수 있어야 함 Consistency(일관성) 하나의 트랜잭션 이전과 이후, 데이터베이스의 상태는 이전과 같이 유효해야 함 Isolation(격리성) 모든 트랜잭션은 다른 트랜잭션으로부터 독립되어야 함 동시에 여러 개의 트랜잭션들이 수행될 때, 각 트랜잭션은 고립 되어 있어 연속으로 실행된 것과 동일한 결과를 가짐 Durability(지속성) 하나의 트랜잭션이 성공적으로 수행되었다면, 해당 트랜잭션에 대한 로그가 남아야 함 4. MySQL #1) Start ## install brew install mysql # start brew services start mysql # login mysql -u root -p # password ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;비밀번호\u0026#39;; 2) Using ## database 보기 SHOW DATABASES; # database 생성 CREATE DATABASE 데이터베이스_이름; # database 사용 USE 데이터베이스_이름; # table 보기 SHOW TABLES; # table 정보 보기 DESC 테이블_이름; # table 생성 CREATE TABLE 테이블_이름 ( Field Type Key Extra ); 5. Reference # http://www.tcpschool.com/mysql/mysql_intro_relationalDB https://www.w3schools.com/sql/sql_quickref.asp https://websitesetup.org/wp-content/uploads/2020/08/SQL-Cheat-Sheet-websitesetup.pdf 6. Designing Schema # 스키마(Schema) 데이터베이스에서 데이터가 구성되는 방식과 서로 다른 엔티티(Entity; Table) 간의 관계 데이터베이스의 청사진 관계형 데이터베이스(Relational database) 데이터(data) 각 항목에 저장되는 값 테이블(table; relation) 사전에 정의된 열의 데이터 타입대로 작성된 데이터가 행으로 축적\\ 칼럼(column; field) 테이블의 한 열 레코드(record; tuple) 테이블의 한 행에 저장된 데이터 키(key) 테이블의 각 레코드를 구분할 수 있는 값 각 레코드마다 고유한 값을 가짐 기본키(primary key)와 외래키(foreign key) 등이 있음 관계(Relation) 1:1 관계 자주 사용하지 않음 1:N 관계 가장 많이 사용 N:N 관계 Join 테이블을 만들어 관리 Join 테이블을 위한 기본키는 반드시 있어야 함 1:N과 1:N 관계로 중간에서 중개 자기참조 관계 테이블 내에서도 관계가 필요 예를 들어 추천인이 누구인지 파악하기 위해 사용 ","date":"16 December 2021","permalink":"/posts/bootcamp/bc-12w-4/","section":"Posts","summary":"1. SQL intro #1) 데이터베이스의 필요성 # In-Memory 프로그램이 종료될 때 해당 프로그램이 사용하던 데이터도 사라짐 File I/O 데이터가 필요할 때마다 전체 파일을 매번 읽어야 함 파일의 크기가 커질수록 이 작업은 버겁고, 비효율적임 데이터베이스를 사용하여 데이터를 영속성있게(persistently) 저장할 필요가 있음 2) Structured Query Language (SQL) # 데이터베이스 언어로, 주로 관계형 데이터베이스에서 사용 MySQL, Oracle, SQLite, PostgreSQL 등 다양한 데이터베이스에서 SQL 구문을 사용 2.","title":"BC-12w-4 / [데이터베이스] 관계형 데이터베이스(1)"},{"content":"1. 순열 / 조합 # 순열(순서 O) 공식 : nPr = n! / (n - r)! Ex. 5장에서 3장을 선택하는 모든 순열의 수\n= 5P3\n= (5 X 4 X 3 X 2 X 1) / (2 X 1)\n= 60 조합(순서 X) 공식 : nCr = n! / (r! * (n - r)!) Ex. 5장에서 3장을 무작위로 선택하는 조합에서 모든 경우의 수\n= 5C3\n= 5! / (3! * 2!)\n= 10 2. GCD / LCM # 약수: 어떤 수를 나누어떨어지게 하는 수\n배수: 어떤 수의 1, 2, 3, \u0026hellip;n 배하여 얻는 수 공약수: 둘 이상의 수의 공통인 약수\n공배수: 둘 이상의 수의 공통인 배수 최대 공약수(GCD. Greatest Common Divisor): 둘 이상의 공약수 중에서 최대인 수\n최소 공배수(LCM. Least Common Multiple): 둘 이상의 공배수 중에서 최소인 수 최소 공배수 예시 문제 # A는 55분마다 9개를, B는 70분마다 15개를, C는 85분마다 25개의 방역용 마스크를 만들 수 있습니다. 이 회사의 사람들은 05:00 시부터 동시에 마스크를 만들기 시작하여 각 55분, 70분, 85분 동안 연속으로 마스크를 제작한 후, 5분씩 휴식을 취합니다. 이들 세 명이 처음으로 동시에 쉬는 시점이 퇴근 시간이라면, 이날 하루에 제작한 마스크는 모두 몇 개인가요? (휴식시간과 퇴근시간이 겹치는 경우, 휴식을 취한 뒤 퇴근합니다.) 세 명이 동시에 휴식을 취하는 시점은 세 명이 쉬고 난 직후가 같을 시점이 됩니다. 따라서 쉬고 난 직후가 처음으로 같을 시점을 구해야 함 LCM(60, 75, 90)은 900 A는 900/60 = 15 번 작업하고, 15번 X 9개 = 135개\nB는 900/75 = 12번의 작업을 반복하고 12턴 X 15개 = 180개,\nC는 900/90 = 10번의 작업을 반복하고 10턴 X 25개 = 250개 최대 공약수 예시 문제 # 가로 24cm, 세로 12cm인 직사각형 모양 조형물의 가장자리에 조명을 설치하려고 합니다. 네 모퉁이에는 조명을 반드시 설치해야하고, 나머지 조명은 일정한 간격으로 설치하려고 할 때, 필요한 최소한의 조명 개수는 몇 개일까요? 이때, 꼭지점을 제외한 직사각형의 모든 변에는 최소 하나 이상의 조명이 반드시 설치되어야 합니다. (단, 설치한 조명의 간격은 정수로 이루어진 cm 단위입니다.) 든 조명을 일정한 간격으로 설치해야 하므로, 가로변과 세로변의 공약수를 구해야 함 GCD(12, 24)는 12 각 변의 길이를 최대 공약수 12로 나누어 최소로 필요한 조명의 개수를 구할 수 있음 (12/12 + 24/12) X 2 = 3 X 2 = 6개 그러나 이 문제에서는 꼭지점을 제외한 직사각형의 모든 변에, 최소 하나 이상의 조명이 설치되어야 하므로 12를 제외한 최대 공약수로 문제를 해결해야 함 (12/6 + 24/6) X 2 = 6 X 2 = 12개 코드 # 최대 공약수의 약수는 공약수 const getGCD = (a, b) =\u0026gt; { let gcd = 1; for (let i = 2; i \u0026lt;= Math.min(a, b); i++) { if (a % i === 0 \u0026amp;\u0026amp; b % i === 0) { gcd = i; } } return gcd; }; // 유클리드 호제법 // GCD(a, b) = GCD(b, a % b) // a % b 가 0일 때, b가 최대 공약수 // b \u0026gt; a일 때, 알아서 스왑 됨 const getGCD1 = (a, b) =\u0026gt; (b \u0026gt; 0 ? getGCD(b, a % b) : a); 3. 멱집합 # 집합의 모든 부분집합 집합 {1, 2, 3}의 모든 부분집합은 {}, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3} Step A: 1을 제외한 {2, 3}의 부분집합을 나열합니다. Step B: 2를 제외한 {3}의 부분집합을 나열합니다. Step C: 3을 제외한 {}의 부분집합을 나열합니다. → {} Step C: {}의 모든 부분집합에 {3}을 추가한 집합들을 나열합니다. → {3} Step B: {3}의 모든 부분집합에 {2}를 추가한 집합들을 나열합니다. Step C: {3}의 모든 부분집합에 {2}를 추가한 집합들을 나열하려면, {}의 모든 부분집합에 {2}를 추가한 집합들을 나열한 다음 {}의 모든 부분집합에 {2, 3}을 추가한 집합들을 나열합니다. → {2}, {2, 3} Step A: {2, 3}의 모든 부분집합에 {1}을 추가한 집합들을 나열합니다. Step B: {2, 3}의 모든 부분집합에 {1}을 추가한 집합들을 나열하려면, {3}의 모든 부분집합에 {1}을 추가한 집합들을 나열한 다음 {3}의 모든 부분집합에 {1, 2}를 추가한 집합들을 나열합니다. Step C: {3}의 모든 부분집합에 {1}을 추가한 집합을 나열하려면, {}의 모든 부분집합에 {1}을 추가한 집합들을 나열한 다음 {}의 모든 부분집합에 {1, 3}을 추가한 집합들을 나열합니다. → {1}, {1, 3} Step C: {3}의 모든 부분집합에 {1, 2}를 추가한 집합을 나열하려면, {}의 모든 부분집합에 {1, 2}를 추가한 집합들을 나열한 다음 {}의 모든 부분집합에 {1, 2, 3}을 추가한 집합들을 나열합니다. → {1, 2}, {1, 2, 3} 원소가 있는지, 없는지 2가지 경우를 고려하기 때문에 집합의 요소가 n 개일 때 모든 부분집합의 개수는 2n개 문제 #1) 중복 순열(재귀) # 라운드(기본 3라운드)에 따른 가위바위보 순열 const rockPaperScissors = function (rounds) { rounds = rounds || 3; const rps = [\u0026#34;rock\u0026#34;, \u0026#34;paper\u0026#34;, \u0026#34;scissors\u0026#34;]; const result = []; const recur = (curRounds, curArr) =\u0026gt; { // 1) 재귀 종료 조건 if (curRounds === 0) { result.push(curArr); return; } for (let el of rps) { const curEl = el; // 2) 재귀 반복 // immutable // 해당 라운드에 해당하는 묵, 찌, 빠를 각각 넣음 recur(curRounds - 1, curArr.concat(curEl)); } }; recur(rounds, []); return result; }; 2) 순열(재귀) # 2진법으로 구성된 재료로 조합(순서에 따라 맛이 달라짐) 가능한 조합의 수 function newChickenRecipe(stuffArr, choiceNum) { // 상한 재료 거르기 let freshArr = []; for (let stuff of stuffArr) { const cntZero = stuff .toString() .split(\u0026#34;\u0026#34;) .filter((el) =\u0026gt; el === \u0026#34;0\u0026#34;).length; if (cntZero \u0026lt; 3) { freshArr.push(stuff); } } // 정렬 freshArr.sort((a, b) =\u0026gt; a - b); // 엣지 케이스 처리 for 효율성 const len = freshArr.length; if (len === 0 || len \u0026lt; choiceNum) return []; const result = []; const recur = (curArr, curNum) =\u0026gt; { // 1) 재귀 종료 조건 if (curNum === 0) { result.push(curArr); return; } for (let el of freshArr) { const curEl = el; if (!curArr.includes(curEl)) { // 2) 조건을 만족할 때 재귀 반복 recur(curArr.concat(curEl), curNum - 1); } } }; recur([], choiceNum); return result; } // 이 재귀가 조금 더 깔끔 const recur = (restArr, curArr, curNum) =\u0026gt; { if (curNum === 0) { result.push(curArr); return; } for (let i = 0; i \u0026lt; restArr.length; i++) { const curEl = restArr[i]; const cutArr = [...restArr]; cutArr.splice(i, 1); recur(cutArr, curArr.concat(curEl), curNum - 1); } }; recur(freshArr, [], choiceNum); 3) 조합 #// 그룹이 아니라 더한 수에서 중복을 없에서 틀림 function boringBlackjack(cards) { const listOfArr = []; const recur = (restCards, curCards, curNum) =\u0026gt; { if (curNum === 3) { listOfArr.push(curCards); return; } for (let i = 0; i \u0026lt; restCards.length; i++) { const curEl = restCards[i]; const cutCards = [...restCards]; cutCards.splice(i, 1); recur(cutCards, curCards.concat(curEl), curNum + 1); } }; recur(cards, [], 0); const listOfNum = listOfArr.map((el) =\u0026gt; el.reduce((acc, cur) =\u0026gt; acc + cur)); const setOfNum = [...new Set(listOfNum)]; const isPrime = (num) =\u0026gt; { if (num === 2) { return true; } for (let i = 2; i \u0026lt;= Math.floor(Math.sqrt(num)); i++) { if (num % i === 0) { return false; } } return true; }; return setOfNum.filter((num) =\u0026gt; isPrime(num)).length; } function boringBlackjack(cards) { const listOfArr = []; const recur = (restCards, curCards, curNum) =\u0026gt; { if (curNum === 3) { listOfArr.push(curCards); return; } for (let i = 0; i \u0026lt; restCards.length; i++) { const curEl = restCards[i]; const cutCards = [...restCards]; cutCards.splice(i, 1); recur(cutCards, curCards.concat(curEl), curNum + 1); } }; recur(cards, [], 0); const listOfStr = listOfArr .map((arr) =\u0026gt; arr.sort((a, b) =\u0026gt; a - b)) .map((arr) =\u0026gt; arr.join()); const setOfStr = [...new Set(listOfStr)]; const setOfStrArr = setOfStr.map((str) =\u0026gt; str.split(\u0026#34;,\u0026#34;)); const setOfNumArr = setOfStrArr.map((arr) =\u0026gt; arr.map((str) =\u0026gt; Number(str))); const setOfNum = setOfNumArr.map((arr) =\u0026gt; arr.reduce((acc, cur) =\u0026gt; acc + cur) ); const isPrime = (num) =\u0026gt; { if (num === 2) { return true; } for (let i = 2; i \u0026lt;= Math.floor(Math.sqrt(num)); i++) { if (num % i === 0) { return false; } } return true; }; return setOfNum.filter((num) =\u0026gt; isPrime(num)).length; } function boringBlackjack(cards) { const isPrime = (num) =\u0026gt; { if (num === 2) { return true; } for (let i = 2; i \u0026lt;= Math.floor(Math.sqrt(num)); i++) { if (num % i === 0) { return false; } } return true; }; let count = 0; let len = cards.length; // 중복 x, 순서 x for (let i = 0; i \u0026lt; len; i++) { for (let j = i + 1; j \u0026lt; len; j++) { for (let k = j + 1; k \u0026lt; len; k++) { const number = cards[i] + cards[j] + cards[k]; if (isPrime(number)) count++; } } } return count; } 4) GCD #// 비효율적 function divideChocolateStick(M, N) { // GCD(a, b) = GCD(b, a % b)에서 a % b는 0일 때, b가 최대 공약수 // a \u0026lt; b 면 자동 스왑 const getGCD = (a, b) =\u0026gt; (b \u0026gt; 0 ? getGCD(b, a % b) : a); gcd = getGCD(M, N) const listOfCD = [] for (let i = 1; i \u0026lt;= gcd; i++) { if (gcd % i === 0) listOfCD.push(i) } const result = new Array(listOfCD.length).fill(0).map(() =\u0026gt; Array()) for (let i = 0; i \u0026lt; listOfCD.length; i++) { const cd = listOfCD[i] result[i][0] = cd result[i][1] = M / cd result[i][2] = N / cd } function divideChocolateStick(M, N) { const getGCD = (a, b) =\u0026gt; (b \u0026gt; 0 ? getGCD(b, a % b) : a); GCD = getGCD(M, N); const result = []; const sqrt = Math.floor(Math.sqrt(GCD)); for (let left = 1; left \u0026lt;= sqrt; left++) { if (GCD % left === 0) { result.push([left, M / left, N / left]); if (left * left \u0026lt; GCD) { // 최대 공약수를 제곱근이 아닌 수로 나누면 제곱근 보다 큰 약수를 구할 수 있다. right = GCD / left; result.push([right, M / right, N / right]); } } } result.sort((arr1, arr2) =\u0026gt; arr1[0] - arr2[0]); return result; } ","date":"15 December 2021","permalink":"/posts/bootcamp/bc-12w-3/","section":"Posts","summary":"1. 순열 / 조합 # 순열(순서 O) 공식 : nPr = n!","title":"BC-12w-3 / [자료구조/알고리즘] 순열/조합 \u0026 GCD/LCM \u0026 멱집합"},{"content":"Intro to Algorithm # 알고리즘이란 문제를 해결하는 최선의 선택 문제 이해 해결 전략 구상(with 수도 코드) 수도 코드를 바탕으로 코드 작성 1. Time Complexity #시간 복잡도 # 입력값의 변화에 따라 연산을 실행할 때, 연산 횟수에 비해 시간이 얼마만큼 걸리는가? Big-O는 상한, Big-Θ(theta)는 평균, Big-Ω(omega)는 하한 Big-O 표기법 # 프로그램이 실행되는 과정에서 소요되는 최악의 시간까지 고려 O(1)\nconstant complexity 입력값이 증가하더라도 시간이 늘어나지 않음 function O_1_algorithm(arr, index) { return arr[index]; } let arr = [1, 2, 3, 4, 5]; let index = 1; let result = O_1_algorithm(arr, index); console.log(result); // 2 O(n)\nlinear complexity 입력값이 증가함에 따라 시간 또한 같은 비율로 증가 Ex. DFS(재귀 함수) function O_n_algorithm(n) { for (let i = 0; i \u0026lt; n; i++) { // do something for 1 second } } function another_O_n_algorithm(n) { for (let i = 0; i \u0026lt; 2n; i++) { // do something for 1 second } } n이 커질 수록 계수의 영향력이 퇴색되서 O(kn)도 모두 O(n) O(log n)\nlogarithmic complexity O(1) 다음으로 빠른 시간 복잡도 Ex. BFS(Queue) O(n^2)\nquadratic complexity 입력값이 증가함에 따라 시간이 n의 제곱수의 비율로 증가 function O_quadratic_algorithm(n) { for (let i = 0; i \u0026lt; n; i++) { for (let j = 0; j \u0026lt; n; j++) { // do something for 1 second } } } function another_O_quadratic_algorithm(n) { for (let i = 0; i \u0026lt; n; i++) { for (let j = 0; j \u0026lt; n; j++) { for (let k = 0; k \u0026lt; n; k++) { // do something for 1 second } } } } n이 커질 수록 지수의 영향력이 퇴색되서 O(n^k)도 모두 O(n^2) O(2^n)\nexponential complexity Big-O 표기법 중 가장 느린 시간 복잡도 function fibonacci(n) { if (n \u0026lt;= 1) { return 1; } return fibonacci(n - 1) + fibonacci(n - 2); } 대략적인 데이터 크기에 따른 시간 복잡도 데이터 크기 제한 예상되는 시간 복잡도 사용 알고리즘 n ≤ 1,000,000 O(n) or O (log n) DFS(재귀함수) or BFS(Queue) n ≤ 10,000 O(n2) 2중 반복문 n ≤ 500 O(n3) 3중 반복문 2-1. Greedy Algorithm # 선택의 순간마다 당장 눈앞에 보이는 최적의 상황만을 쫓아 최종적인 해답에 도달하는 방법 선택 절차(Selection Procedure) 현재 상태에서의 최적의 해답을 선택합니다. 적절성 검사(Feasibility Check) 선택된 해가 문제의 조건을 만족하는지 검사합니다. 해답 검사(Solution Check) 원래의 문제가 해결되었는지 검사하고, 해결되지 않았다면 선택 절차로 돌아가 위의 과정을 반복합니다 Ex.\n선택 절차 거스름돈의 동전 개수를 줄이기 위해 현재 가장 가치가 높은 동전을 우선 선택합니다. 적절성 검사 1번 과정을 통해 선택된 동전들의 합이 거슬러 줄 금액을 초과하는지 검사합니다. 초과하면 가장 마지막에 선택한 동전을 삭제하고, 1번으로 돌아가 한 단계 작은 동전을 선택합니다. 해답 검사 선택된 동전들의 합이 거슬러 줄 금액과 일치하는지 검사합니다. 액수가 부족하면 1번 과정부터 다시 반복합니다. 항상 최적의 결과를 보장하지는 못함(Ex. 도둑질)\nBut, 어느 정도 최적에 근사한 값을 빠르게 도출할 수 있는 장점이 있음\n탐욕 알고리즘을 적용하려면 해결하려는 문제가 다음의 2가지 조건을 성립하여야 함\n탐욕적 선택 속성(Greedy Choice Property) 앞의 선택이 이후의 선택에 영향을 주지 않습니다. 최적 부분 구조(Optimal Substructure) 문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 문제 해결 방법으로 구성됩니다. 완전 탐색 # 문제를 무조건 해결할 수 있는 장점이 있으나, 효율적으로 동작하지 못할 가능성이 높음 Ex. Brute Force(무차별 대입, 조건/반복을 사용하여 해결), 재귀, 순열, DFS/BFS 등 시뮬레이션 # 모든 과정과 조건이 제시되어, 그 과정을 거친 결과가 무엇인지 확인하는 유형 문제 해결을 떠올리는 것 자체는 쉬울 수 있으나 길고 자세하여 코드로 옮기는 작업이 까다로울 수 있음 2-2. Dynamic Programming # 모든 경우의 수를 조합해 최적의 해법을 찾는 방식 주어진 문제를 여러 개의 하위 문제로 나누어 풀고, 하위 문제들의 해결 방법을 결합하여 최종 문제를 해결하는 문제 해결 방식 동적 프로그래밍을 적용하려면 해결하려는 문제가 다음의 2가지 조건을 성립하여야 함 큰 문제를 작은 문제로 나눌 수 있고, 이 작은 문제가 중복해서 발견된다. (Overlapping Sub-problems) 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 같다. 즉, 작은 문제에서 구한 정답을 큰 문제에서도 사용할 수 있다. (Optimal Substructure) 주어진 문제를 단순히 반복 계산하여 해결하는 것이 아니라, 작은 문제의 결과가 큰 문제를 해결하는 데에 여러 번 사용될 수 있어야 합니다.(Ex. 효율적인 피보나치) Recursion + Memoization (재귀) # Top-down 방식 시간과 메모리 사용량을 줄일 수 있음 function fibMemo(n, memo = []) { // 이미 해결한 하위 문제인지 찾아본다 if (memo[n] !== undefined) return memo[n]; if (n \u0026lt;= 2) return 1; // 없다면 재귀로 결괏값을 도출하여 res 에 할당 let res = fibMemo(n - 1, memo) + fibMemo(n - 2, memo); // 추후 동일한 문제를 만났을 때 사용하기 위해 리턴 전에 memo 에 저장 memo[n] = res; return res; } Iteration + Tabulation (반복) # Bottom-up 방식 function fibTab(n) { if (n \u0026lt;= 2) return 1; let fibNum = [0, 1, 1]; // n 이 1 \u0026amp; 2일 때의 값을 미리 배열에 저장해 놓는다 for (let i = 3; i \u0026lt;= n; i++) { fibNum[i] = fibNum[i - 1] + fibNum[i - 2]; // n \u0026gt;= 3 부터는 앞서 배열에 저장해 놓은 값들을 이용하여 // n번째 피보나치 수를 구한 뒤 배열에 저장 후 리턴한다 } return fibNum[n]; } PS. 개발자 도구에서 함수 실행 시간 측정 방법 #var t0 = performance.now(); func(50); var t1 = performance.now(); console.log(\u0026#34;runtime: \u0026#34; + (t1 - t0) + \u0026#34;ms\u0026#34;); 문제 #1) Greedy(1) # 모든 짐을 옮기기 위해 필요한 박스(최대 두 개, 제한 무게 이하) 개수의 최솟값을 숫자로 반환 function movingStuff(stuff, limit) { let count = 0; stuff.sort((a, b) =\u0026gt; a - b); let left = 0; let right = stuff.length - 1; while (left \u0026lt;= right) { if (stuff[left] + stuff[right] \u0026lt;= limit) { left++; right--; count++; } else { right--; count++; } } return count; } 2) Greedy(2) # 거스름돈을 만드는데 필요한 동전 개수의 최솟값 function partTimeJob(k) { let coins = [500, 100, 50, 10, 5, 1]; let count = 0; let remainder = k; for (let coin of coins) { let quotient = Math.floor(remainder / coin); count += quotient; remainder = remainder % coin; } return count; } 3) Simulation #function boardGame(board, operation) { let point = 0; let row = 0; let col = 0; const directions = operation.split(\u0026#34;\u0026#34;); const len = board.length; for (let direction of directions) { if (direction === \u0026#34;U\u0026#34;) row -= 1; if (direction === \u0026#34;D\u0026#34;) row += 1; if (direction === \u0026#34;L\u0026#34;) col -= 1; if (direction === \u0026#34;R\u0026#34;) col += 1; if (row \u0026lt; 0 || col \u0026lt; 0 || len \u0026lt; row || len \u0026lt; col) { return \u0026#34;OUT\u0026#34;; } point += board[row][col]; } return point; } // LOOK UP TABLE을 사용한다면 조건문을 추상화 function boardGame(board, operation) { const DIR = { U: [-1, 0], D: [1, 0], L: [0, -1], R: [0, 1], }; const len = board.length; const isValid = (row, col) =\u0026gt; 0 \u0026lt;= row \u0026amp;\u0026amp; row \u0026lt; len \u0026amp;\u0026amp; 0 \u0026lt;= col \u0026amp;\u0026amp; col \u0026lt; len; let row = 0; let col = 0; let score = 0; for (let i = 0; i \u0026lt; operation.length; i++) { const [dRow, dCol] = DIR[operation[i]]; row += dRow; col += dCol; if (!isValid(row, col)) return \u0026#34;OUT\u0026#34;; score += board[row][col]; } return score; } 4) Dynamic Programming, Bottom-up 방식 #function ocean(target, type) { // 0을 만드는 방법은 1가지(초기값) const memo = [1].concat(Array(target).fill(0)); // 각 화폐 탐색 for (let currency of type) { // 해당 화폐로 j를 만들 수 있는 경우의 수를 memo에 저장 for (let j = 1; j \u0026lt;= target; j++) { // 기존 경우의 수에 현재 화폐를 뺀 금액을 만들 수 있는 경우의 수(+1)를 더해준다 if (currency \u0026lt;= j) memo[j] += memo[j - currency]; } } return memo[target]; } Ex. cur 0 20 30 40 50 10 1 1 1 1 1 20 - 2 2 3 3 50 - - - - 4 10으로 10 만들고, 10과 10으로 20 만들고, 10과 10과 10으로 30을 만들고, \u0026hellip; 20으로 20 만들고, 10과 10으로 20 만들고, \u0026hellip; + React with FastCampus Project #프로젝트 개요 # Context API 와 Hooks 를 이용한 전역 상태 관리 ERROR #node:internal/modules/cjs/loader:488 throw e; ^ Error [ERR_PACKAGE_PATH_NOT_EXPORTED]: Package subpath \u0026#39;./lib/tokenize\u0026#39; is not defined by \u0026#34;exports\u0026#34; in /Users/zzz/Develop/my-app/node_modules/postcss-safe-parser/node_modules/postcss/package.json at new NodeError (node:internal/errors:371:5) at throwExportsNotFound (node:internal/modules/esm/resolve:416:9) at packageExportsResolve (node:internal/modules/esm/resolve:669:3) at resolveExports (node:internal/modules/cjs/loader:482:36) at Function.Module._findPath (node:internal/modules/cjs/loader:522:31) at Function.Module._resolveFilename (node:internal/modules/cjs/loader:919:27) at Function.Module._load (node:internal/modules/cjs/loader:778:27) at Module.require (node:internal/modules/cjs/loader:999:19) at require (node:internal/modules/cjs/helpers:102:18) at Object. (/Users/zzz/Develop/my-app/node_modules/postcss-safe-parser/lib/safe-parser.js:1:17) { code: \u0026#39;ERR_PACKAGE_PATH_NOT_EXPORTED\u0026#39; } Node.js v17.0.1 nvm use 16 으로 Node 버전을 16으로 바꿔서 해결 상품 선택과 상품 삭제를 주문에서 보여주기 #/* App.js */ import Footer from \u0026#34;./components/Footer\u0026#34;; import Header from \u0026#34;./components/Header\u0026#34;; import Orders from \u0026#34;./components/Orders\u0026#34;; import Prototypes from \u0026#34;./components/Prototypes\u0026#34;; import AppStateProvider from \u0026#34;./providers/AppStateProvider\u0026#34;; function App() { return ( \u0026lt;AppStateProvider\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;Prototypes /\u0026gt; \u0026lt;Orders /\u0026gt; \u0026lt;Footer /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/AppStateProvider\u0026gt; ); } export default App; React.createContext()\n/* contexts/AppStateContext */ import React from \u0026#34;react\u0026#34;; const AppStateContext = React.createContext(); export default AppStateContext; Context.Provider\n/* providers/AppStateProvider */ import { useState, useCallback } from \u0026#34;react\u0026#34;; import AppStateContext from \u0026#34;../contexts/AppStateContext\u0026#34;; const AppStateProvider = ({ children }) =\u0026gt; { // State const [prototypes, setPrototype] = useState([...]) const [orders, setOrders] = useState([]); // Function const addToOrder = useCallback((id) =\u0026gt; { setOrders((orders) =\u0026gt; { const isOrdered = !!orders.find((order) =\u0026gt; order.id === id); if (!isOrdered) { return [...orders, { id, quantity: 1 }]; } else { return orders.map((order) =\u0026gt; { if (order.id === id) { return { id, quantity: order.quantity + 1, }; } else { return order; } }); } }); }, []); const remove = useCallback((id) =\u0026gt; { setOrders((orders) =\u0026gt; orders.filter((order) =\u0026gt; order.id !== id)); }, []); const removeAll = useCallback(() =\u0026gt; { setOrders([]); }, []); return ( \u0026lt;AppStateContext.Provider value={{ prototypes, orders, addToOrder, remove, removeAll, }} \u0026gt; {children} \u0026lt;/AppStateContext.Provider\u0026gt; ); }; export default AppStateProvider; useContext \u0026amp; 사용자 정의 Hook\n/* hooks/useActions */ import { useContext } from \u0026#34;react\u0026#34;; import AppStateContext from \u0026#34;../contexts/AppStateContext\u0026#34;; export default function useActions() { const { addToOrder, remove, removeAll } = useContext(AppStateContext); return { addToOrder, remove, removeAll }; } /* hooks/useOrders */ import { useContext } from \u0026#34;react\u0026#34;; import AppStateContext from \u0026#34;../contexts/AppStateContext\u0026#34;; export default function useOrders() { const { orders } = useContext(AppStateContext); return orders; } /* hooks/usePrototypes */ import { useContext } from \u0026#34;react\u0026#34;; import AppStateContext from \u0026#34;../contexts/AppStateContext\u0026#34;; export default function usePrototypes() { const { prototypes } = useContext(AppStateContext); return prototypes; } import useActions from \u0026#34;../hooks/useActions\u0026#34;; import useOrders from \u0026#34;../hooks/useOrders\u0026#34;; import usePrototypes from \u0026#34;../hooks/usePrototypes\u0026#34;; export default function Orders() { const orders = useOrders(); const prototypes = usePrototypes(); const { remove, removeAll } = useActions(); ... } ","date":"14 December 2021","permalink":"/posts/bootcamp/bc-12w-2/","section":"Posts","summary":"Intro to Algorithm # 알고리즘이란 문제를 해결하는 최선의 선택 문제 이해 해결 전략 구상(with 수도 코드) 수도 코드를 바탕으로 코드 작성 1.","title":"BC-12w-2 / [자료구조/알고리즘] 시간 복잡도 \u0026 탐욕 알고리즘 + {FC} Context로 전역 상태 관리하기"},{"content":"1. 사용 권한 #ls -l # 권한을 확인하는 명령어\n첫 시작인 - 와 d 는 각각 not directory와 directory r, w, x는 각각 read permission, write permission, execute permission 순서대로 user, group, other에 대한 권한을 표시 Ex) -rw-r\u0026ndash;r\u0026ndash; -\u0026gt; -/rw-/r\u0026ndash;/r\u0026ndash; drwxr-xr-x -\u0026gt; d/rwx/r-x/r-x chmod # 권한을 변경하는 명령어\n만약 OS에 로그인한 사용자와, 폴더나 파일의 소유자가 다를 경우에는 관리자 권한을 획득하는 명령어 sudo 를 이용해 폴더나 파일의 권한을 변경할 수 있습니다. chmod 로 권한을 변경하는 두 가지 방식 Symbolic method - 더하기(+), 빼기(-), 할당(=)과 액세서 유형을 표기해서 변경 Access class u(user), g(group), o(other), a(all: u, g, o) Operator +(add access), -(remove access), =(set exact access) Access type r(read), w(write), x(execute) Ex) chmod a=rw helloworld.js # -rw-rw-rw-\rchmod u= helloworld.js # ----rw-rw-\rchmod a+rx helloworld.js # -r-xrwxrwx\rchmod go-wx helloworld.js # -r-xr--r--\rchmod a= helloworld.js # ----------\rchmod u+rwx helloworld.js # -rwx------\rchmod u=rwx linux # drwxrwxrwx Absolute form rwx를 3 bit로 해석하여, 숫자 3자리로 권한을 표기해서 변경 2. 환경 변수 #export # 환경변수 확인하기 \u0026amp;\u0026amp; 환경변수 임시 적용\n환경변수 확인하기 export 환경변수 임시 적용 export 변수명=값 export urclass=\u0026#34;is good\u0026#34; echo $urclass # 명령어 echo 와 함께 환경변수를 입력하면, 환경변수의 값을 확인 가능 # 이때 환경변수의 앞에는 달러사인($)을 입력하여, 변수라는 뜻을 터미널에 전달해야함 dotenv # 자바스크립트에서 환경변수 사용하기\ndotenv 모듈 .env 파일에 저장한 내용을 불러오기 위해서는, dotenv 모듈이 필요 mkdir environment_variable cd environment_variable npm init npm i dotenv nano .env # myname=kimcoding nano index.js # const dotenv = require(\u0026#34;dotenv\u0026#34;); # dotenv.config(); # console.log(process.env.myname); # console.log(process.env); node index.js .env # Node.js에서 환경변수 영구 적용\n명령어 export 로 적용한 환경변수는 현재 사용 중인 터미널에서만 임시로 사용이 가능 환경변수를 Linux 운영체제에 저장하는 방법은 여러 가지가 있지만, Node.js에서는 파일 .env를 만들어 저장하는 방법을 사용 하나의 변수 이름을 환경에 따라 다르게 설정할 수 있음 개발, 테스트, 제품 환경으로 구분 ","date":"13 December 2021","permalink":"/posts/bootcamp/bc-12w-1/","section":"Posts","summary":"1. 사용 권한 #ls -l # 권한을 확인하는 명령어","title":"BC-12w-1 / [Linux] 사용 권한, 환경 변수"},{"content":"","date":null,"permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux"},{"content":"HA-Algorithm, HA-react # 알고리즘 문제는 코플릿 보다 쉽게 나와서 어렵지 않게 풀었다. react의 경우에도 문제 난이도는 어렵지 않았다. useEffect를 사용할 때, setTimeout과 clean-up(clearTimeout)을 사용해 줘야하는데 이 부분이 아직 명확하게 이해되지 않는다. Section2 회고 # 백 부분에 대해서 걱정을 조금 했으나 기초 부분이어서 그런지 무난하게 해나갈 수 있었다. 기본적으로는 프런트 앤드 개발자를 목적으로 공부하고 있으나, 백도 매력적이란 것을 알게 되었다. 데이터를 요청하고 받을 때 성공적으로 해내니 기분이 너무 좋았다. 리액트는 알면 알수록 더 매력적인 것 같다. 특히 컴포넌트와 Custom Hook으로 반복 작성을 줄이고 유지 보수를 쉽게 할 수 있는 부분이 매력적으로 다가왔다. Section3가 끝나고 하게 될 프로젝트에서 주로 다룰 것이라 틈틈이 더욱더 완벽히 사용할 수 있도록 연습할 것이다. section2를 통과하였으나, 개인적인 사정으로 한 회차 쉬어간 뒤, section3로 넘어가게 되었다. 틈틈히 이제까지 배운 내용들을 다시 공식 문서를 통해 복습하며, WIL에 정리할 것이다. section3은 12월 13일에 다시 재개한다. ","date":"5 November 2021","permalink":"/posts/bootcamp/bc-11w-3/","section":"Posts","summary":"HA-Algorithm, HA-react # 알고리즘 문제는 코플릿 보다 쉽게 나와서 어렵지 않게 풀었다.","title":"BC-11w-3 / HA-Algorithm, HA-react, Section2 회고"},{"content":"Today I learned #Sprint - Cmarket Redux #index.js #import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import App from \u0026#34;./App\u0026#34;; import store from \u0026#34;./store/store\u0026#34;; import { Provider } from \u0026#34;react-redux\u0026#34;; import * as serviceWorker from \u0026#34;./serviceWorker\u0026#34;; ReactDOM.render( \u0026lt;Provider store={store}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/Provider\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;) ); serviceWorker.unregister(); store/store.js #import { compose, createStore, applyMiddleware } from \u0026#34;redux\u0026#34;; import rootReducer from \u0026#34;../reducers/index\u0026#34;; import thunk from \u0026#34;redux-thunk\u0026#34;; const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose; const store = createStore( rootReducer, composeEnhancers(applyMiddleware(thunk)) ); export default store; app.js #import React from \u0026#34;react\u0026#34;; import Nav from \u0026#34;./components/Nav\u0026#34;; import ItemListContainer from \u0026#34;./pages/ItemListContainer\u0026#34;; import NotificationCenter from \u0026#34;./components/NotificationCenter\u0026#34;; import \u0026#34;./App.css\u0026#34;; import { BrowserRouter as Router, Switch, Route } from \u0026#34;react-router-dom\u0026#34;; import ShoppingCart from \u0026#34;./pages/ShoppingCart\u0026#34;; function App() { return ( \u0026lt;Router\u0026gt; \u0026lt;Nav /\u0026gt; \u0026lt;Switch\u0026gt; \u0026lt;Route exact={true} path=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;ItemListContainer /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#34;/shoppingcart\u0026#34;\u0026gt; \u0026lt;ShoppingCart /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;/Switch\u0026gt; \u0026lt;NotificationCenter /\u0026gt; \u0026lt;/Router\u0026gt; ); } export default App; pages/ItemListContainer.js #import React from \u0026#34;react\u0026#34;; import { addToCart, notify } from \u0026#34;../actions/index\u0026#34;; import { useSelector, useDispatch } from \u0026#34;react-redux\u0026#34;; import Item from \u0026#34;../components/Item\u0026#34;; function ItemListContainer() { const state = useSelector((state) =\u0026gt; state.itemReducer); const { items, cartItems } = state; const dispatch = useDispatch(); const handleClick = (item) =\u0026gt; { if (!cartItems.map((el) =\u0026gt; el.itemId).includes(item.id)) { dispatch(addToCart(item.id)); dispatch(notify(`장바구니에 ${item.name}이(가) 추가되었습니다.`)); } else { dispatch(notify(\u0026#34;이미 추가된 상품입니다.\u0026#34;)); } }; return ( \u0026lt;div id=\u0026#34;item-list-container\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;item-list-body\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;item-list-title\u0026#34;\u0026gt;쓸모없는 선물 모음\u0026lt;/div\u0026gt; {items.map((item, idx) =\u0026gt; ( \u0026lt;Item item={item} key={idx} handleClick={() =\u0026gt; { handleClick(item); }} /\u0026gt; ))} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default ItemListContainer; pages/ShoppingCart #import React, { useState } from \u0026#34;react\u0026#34;; import { useDispatch, useSelector } from \u0026#34;react-redux\u0026#34;; import { removeFromCart, setQuantity } from \u0026#34;../actions\u0026#34;; import CartItem from \u0026#34;../components/CartItem\u0026#34;; import OrderSummary from \u0026#34;../components/OrderSummary\u0026#34;; export default function ShoppingCart() { const state = useSelector((state) =\u0026gt; state.itemReducer); const { cartItems, items } = state; const dispatch = useDispatch(); const [checkedItems, setCheckedItems] = useState( cartItems.map((el) =\u0026gt; el.itemId) ); const handleCheckChange = (checked, id) =\u0026gt; { if (checked) { setCheckedItems([...checkedItems, id]); } else { setCheckedItems(checkedItems.filter((el) =\u0026gt; el !== id)); } }; const handleAllCheck = (checked) =\u0026gt; { if (checked) { setCheckedItems(cartItems.map((el) =\u0026gt; el.itemId)); } else { setCheckedItems([]); } }; const handleQuantityChange = (quantity, itemId) =\u0026gt; { dispatch(setQuantity(itemId, quantity)); }; const handleDelete = (itemId) =\u0026gt; { setCheckedItems(checkedItems.filter((el) =\u0026gt; el !== itemId)); dispatch(removeFromCart(itemId)); }; const getTotal = () =\u0026gt; { let cartIdArr = cartItems.map((el) =\u0026gt; el.itemId); let total = { price: 0, quantity: 0, }; for (let i = 0; i \u0026lt; cartIdArr.length; i++) { if (checkedItems.indexOf(cartIdArr[i]) \u0026gt; -1) { let quantity = cartItems[i].quantity; let price = items.filter((el) =\u0026gt; el.id === cartItems[i].itemId)[0] .price; total.price = total.price + quantity * price; total.quantity = total.quantity + quantity; } } return total; }; const renderItems = items.filter( (el) =\u0026gt; cartItems.map((el) =\u0026gt; el.itemId).indexOf(el.id) \u0026gt; -1 ); const total = getTotal(); return ( \u0026lt;div id=\u0026#34;item-list-container\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;item-list-body\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;item-list-title\u0026#34;\u0026gt;장바구니\u0026lt;/div\u0026gt; \u0026lt;span id=\u0026#34;shopping-cart-select-all\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; checked={checkedItems.length === cartItems.length ? true : false} onChange={(e) =\u0026gt; handleAllCheck(e.target.checked)} \u0026gt;\u0026lt;/input\u0026gt; \u0026lt;label\u0026gt;전체선택\u0026lt;/label\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;div id=\u0026#34;shopping-cart-container\u0026#34;\u0026gt; {!cartItems.length ? ( \u0026lt;div id=\u0026#34;item-list-text\u0026#34;\u0026gt;장바구니에 아이템이 없습니다.\u0026lt;/div\u0026gt; ) : ( \u0026lt;div id=\u0026#34;cart-item-list\u0026#34;\u0026gt; {renderItems.map((item, idx) =\u0026gt; { const quantity = cartItems.filter( (el) =\u0026gt; el.itemId === item.id )[0].quantity; return ( \u0026lt;CartItem key={idx} handleCheckChange={handleCheckChange} handleQuantityChange={handleQuantityChange} handleDelete={handleDelete} item={item} checkedItems={checkedItems} quantity={quantity} /\u0026gt; ); })} \u0026lt;/div\u0026gt; )} \u0026lt;OrderSummary total={total.price} totalQty={total.quantity} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } actions/index.js #// action types export const ADD_TO_CART = \u0026#34;ADD_TO_CART\u0026#34;; export const REMOVE_FROM_CART = \u0026#34;REMOVE_FROM_CART\u0026#34;; export const SET_QUANTITY = \u0026#34;SET_QUANTITY\u0026#34;; export const NOTIFY = \u0026#34;NOTIFY\u0026#34;; export const ENQUEUE_NOTIFICATION = \u0026#34;ENQUEUE_NOTIFICATION\u0026#34;; export const DEQUEUE_NOTIFICATION = \u0026#34;DEQUEUE_NOTIFICATION\u0026#34;; // actions creator functions export const addToCart = (itemId) =\u0026gt; { return { type: ADD_TO_CART, payload: { quantity: 1, itemId, }, }; }; export const removeFromCart = (itemId) =\u0026gt; { return { type: \u0026#34;REMOVE_FROM_CART\u0026#34;, payload: { itemId, }, }; }; export const setQuantity = (itemId, quantity) =\u0026gt; { return { type: \u0026#34;SET_QUANTITY\u0026#34;, payload: { itemId, quantity, }, }; }; export const notify = (message, dismissTime = 5000) =\u0026gt; (dispatch) =\u0026gt; { const uuid = Math.random(); dispatch(enqueueNotification(message, dismissTime, uuid)); setTimeout(() =\u0026gt; { dispatch(dequeueNotification()); }, dismissTime); }; export const enqueueNotification = (message, dismissTime, uuid) =\u0026gt; { return { type: ENQUEUE_NOTIFICATION, payload: { message, dismissTime, uuid, }, }; }; export const dequeueNotification = () =\u0026gt; { return { type: DEQUEUE_NOTIFICATION, }; }; reducer/index.js #import { combineReducers } from \u0026#34;redux\u0026#34;; import itemReducer from \u0026#34;./itemReducer\u0026#34;; import notificationReducer from \u0026#34;./notificationReducer\u0026#34;; const rootReducer = combineReducers({ itemReducer, notificationReducer, }); export default rootReducer; reducer/itemReducer.js #import { REMOVE_FROM_CART, ADD_TO_CART, SET_QUANTITY } from \u0026#34;../actions/index\u0026#34;; import { initialState } from \u0026#34;./initialState\u0026#34;; const itemReducer = (state = initialState, action) =\u0026gt; { switch (action.type) { case ADD_TO_CART: return Object.assign({}, state, { cartItems: [...state.cartItems, action.payload], }); case REMOVE_FROM_CART: const filteredItems = state.cartItems.filter( (el) =\u0026gt; el.itemId !== action.payload.itemId ); return Object.assign({}, state, { cartItems: filteredItems, }); case SET_QUANTITY: const idx = state.cartItems.findIndex( (el) =\u0026gt; el.itemId === action.payload.itemId ); return { ...state, cartItems: [ ...state.cartItems.slice(0, idx), action.payload, ...state.cartItems.slice(idx + 1), ], }; default: return state; } }; export default itemReducer; Today\u0026rsquo;s takeaway # redux를 사용해서 상태 관리를 좀 더 쉽게 할 수 있다. 대부분이 미리 작성되어 있어서 문제는 쉽게 풀었다. 하지만 아직 redux에 대해 완전한 이해가 되지 않아서 따로 강의를 듣고 추가로 정리할 것이다. ","date":"3 November 2021","permalink":"/posts/bootcamp/bc-11w-2/","section":"Posts","summary":"Today I learned #Sprint - Cmarket Redux #index.","title":"BC-11w-2 / [React] 상태 관리(2) redux"},{"content":"Today I learned #\r상태 관리 # 상태 변경이 일어나는 곳과 상태 변경의 영향을 받는 곳 Side Effect 함수(또는 컴포넌트)의 입력 외에도 함수의 결과에 영향을 미치는 요인 Ex. 네트워크 요청(API 요청) Presentation 컴포넌트 데이터가 가짜라도 컴포넌트는 표현 그 자체에 집중 Side Effect에 의존적인 상태는 로딩화면 고려 State(상태)의 중복배제원칙 Ex.\n제품의 원본 목록, 유저가 입력한 검색어, 체크박스의 값, 필터링 된 제품들의 목록\n-\u0026gt; 유저가 입력한 검색어, 체크박스의 값 State(상태)를 로컬과 전역으로 구분 데이터 무결성 데이터의 정확성을 보장하기 위해 데이터의 변경이나 수정 시 제한을 두어 안정성을 저해하는 요소를 막고 데이터 상태들을 항상 옳게 유지하는 것 Single source of truth 상태 관리 툴 React Context, Redux, Mobx 전역 상태를 위한 저장소 제공 props drilling 문제를 해결 Sprint - Cmarket Hooks #function App() { const [items] = useState(initialState.items); const [cartItems, setCartItems] = useState(initialState.cartItems); ... } function ItemListContainer({ cartItems, items, setCartItems }) { const handleClick = (itemId) =\u0026gt; { const curItem = cartItems.filter((it) =\u0026gt; it.itemId === itemId)[0]; if (curItem === undefined) { setCartItems([...cartItems, { itemId: itemId, quantity: 1 }]); } else { curItem.quantity = curItem.quantity + 1; setCartItems([ ...cartItems.filter((it) =\u0026gt; it.itemId !== itemId), curItem, ]); } // const curItem = cartItems.find((it) =\u0026gt; it.itemId === itemId); // const curIdx = cartItems.findIndex((it) =\u0026gt; it.itemId === itemId); // if (curItem === undefined) { // setCartItems([...cartItems, { itemId: itemId, quantity: 1 }]); // } else { // const tempItems = cartItems; // tempItems[curIdx].quantity += 1; // setCartItems(tempItems); // } } ... } function ShoppingCart({ items, cartItems, setCartItems }) { const [checkedItems, setCheckedItems] = useState( cartItems.map((el) =\u0026gt; el.itemId) ); const handleCheckChange = (checked, id) =\u0026gt; { if (checked) { setCheckedItems([...checkedItems, id]); } else { setCheckedItems(checkedItems.filter((el) =\u0026gt; el !== id)); } }; const handleAllCheck = (checked) =\u0026gt; { if (checked) { setCheckedItems(cartItems.map((el) =\u0026gt; el.itemId)); } else { setCheckedItems([]); } }; const handleQuantityChange = (quantity, itemId) =\u0026gt; { const curItem = cartItems.filter((it) =\u0026gt; it.itemId === itemId)[0]; curItem.quantity = quantity; setCartItems([...cartItems.filter((it) =\u0026gt; it.itemId !== itemId), curItem]); }; const handleDelete = (itemId) =\u0026gt; { setCartItems([...cartItems.filter((it) =\u0026gt; it.itemId !== itemId)]); }; const getTotal = () =\u0026gt; { let cartIdArr = cartItems.map((el) =\u0026gt; el.itemId); let total = { price: 0, quantity: 0, }; for (let i = 0; i \u0026lt; cartIdArr.length; i++) { if (checkedItems.indexOf(cartIdArr[i]) \u0026gt; -1) { let quantity = cartItems[i].quantity; let price = items.filter((el) =\u0026gt; el.id === cartItems[i].itemId)[0] .price; total.price = total.price + quantity * price; total.quantity = total.quantity + quantity; } } return total; }; const renderItems = items.filter( (el) =\u0026gt; cartItems.map((el) =\u0026gt; el.itemId).indexOf(el.id) \u0026gt; -1 ); const total = getTotal(); ... } Today\u0026rsquo;s takeaway # 이 과제는 복잡한 구조가 아니라 props로 state를 넘겨줘도 크게 복잡하지 않았지만, 구조가 복잡해지면 일일이 props로 state를 넘기기는 힘들 것이다. 그 점을 해결하기 위해서 useContext나 REDUX를 사용한다. 리스트 추가는 find로 요소를 찾고, findIndex로 요소의 인덱스를 찾아서 값을 바꿔주는 방식으로도 가능했는데, 양을 바꾸는 것은 이 방식으로는 되지 않았다. 이유를 계속 찾았으나 아직은 찾지 못했다. 이제 리액트의 기본적인 구조를 어느 정도 이해한 것 같다. ","date":"1 November 2021","permalink":"/posts/bootcamp/bc-11w-1/","section":"Posts","summary":"Today I learned #\r상태 관리 # 상태 변경이 일어나는 곳과 상태 변경의 영향을 받는 곳 Side Effect 함수(또는 컴포넌트)의 입력 외에도 함수의 결과에 영향을 미치는 요인 Ex.","title":"BC-11w-1 / [React] 상태 관리(1)"},{"content":"Today I learned #Sprint - React Custom Component #Autocomplete #import { useState, useEffect } from \u0026#34;react\u0026#34;; import styled from \u0026#34;styled-components\u0026#34;; const deselectedOptions = [ \u0026#34;rustic\u0026#34;, \u0026#34;antique\u0026#34;, \u0026#34;vinyl\u0026#34;, \u0026#34;vintage\u0026#34;, \u0026#34;refurbished\u0026#34;, \u0026#34;신품\u0026#34;, \u0026#34;빈티지\u0026#34;, \u0026#34;중고A급\u0026#34;, \u0026#34;중고B급\u0026#34;, \u0026#34;골동품\u0026#34;, ]; const boxShadow = \u0026#34;0 4px 6px rgb(32 33 36 / 28%)\u0026#34;; const activeBorderRadius = \u0026#34;1rem 1rem 0 0\u0026#34;; const inactiveBorderRadius = \u0026#34;1rem 1rem 1rem 1rem\u0026#34;; export const InputContainer = styled.div` margin-top: 8rem; background-color: #ffffff; display: flex; flex-direction: row; padding: 1rem; border: 1px solid rgb(223, 225, 229); border-radius: ${inactiveBorderRadius}; z-index: 3; box-shadow: 0; \u0026amp;:focus-within { box-shadow: ${boxShadow}; border-radius: ${activeBorderRadius}; } \u0026gt; input { flex: 1 0 0; background-color: transparent; border: none; margin: 0; padding: 0; outline: none; font-size: 16px; } \u0026gt; div.delete-button { cursor: pointer; } `; export const DropDownContainer = styled.ul` background-color: #ffffff; display: block; margin-left: auto; margin-right: auto; list-style-type: none; margin-block-start: 0; margin-block-end: 0; margin-inline-start: 0px; margin-inline-end: 0px; padding-inline-start: 0px; margin-top: -1px; padding: 0.5rem 0; border: 1px solid rgb(223, 225, 229); border-radius: 0 0 1rem 1rem; box-shadow: ${boxShadow}; z-index: 3; \u0026gt; li { padding: 0 1rem; } `; export const Autocomplete = () =\u0026gt; { const [hasText, setHasText] = useState(false); const [inputValue, setInputValue] = useState(\u0026#34;\u0026#34;); const [options, setOptions] = useState(deselectedOptions); const [selected, setSelected] = useState(-1); useEffect(() =\u0026gt; { if (inputValue === \u0026#34;\u0026#34;) { setHasText(false); } }, [inputValue]); const handleInputChange = (event) =\u0026gt; { const { value } = event.target; if (value.includes(\u0026#34;\\\\\u0026#34;)) return null; value ? setHasText(true) : setHasText(false); setInputValue(value); const filterRegex = new RegExp(value, \u0026#34;i\u0026#34;); const resultOptions = deselectedOptions.filter((option) =\u0026gt; option.match(filterRegex) ); setOptions(resultOptions); }; const handleDropDownClick = (clickedOption) =\u0026gt; { setInputValue(clickedOption); const resultOptions = deselectedOptions.filter( (option) =\u0026gt; option === clickedOption ); setOptions(resultOptions); }; const handleDeleteButtonClick = () =\u0026gt; { setInputValue(\u0026#34;\u0026#34;); }; const handleKeyUp = (event) =\u0026gt; { // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState#example // eslint-disable-next-line if (hasText) { if (event.code === \u0026#34;ArrowDown\u0026#34; \u0026amp;\u0026amp; options.length - 1 \u0026gt; selected) { setSelected(selected + 1); } if (event.code === \u0026#34;ArrowUp\u0026#34; \u0026amp;\u0026amp; selected \u0026gt;= 0) { setSelected(selected - 1); } if (event.code === \u0026#34;Enter\u0026#34; \u0026amp;\u0026amp; selected \u0026gt;= 0) { handleDropDownClick(options[selected]); setSelected(-1); } } }; return ( \u0026lt;div className=\u0026#34;autocomplete-wrapper\u0026#34; onKeyUp={handleKeyUp}\u0026gt; \u0026lt;InputContainer hasText={hasText}\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; className=\u0026#34;autocomplete-wrapper\u0026#34; onChange={handleInputChange} value={inputValue} /\u0026gt; \u0026lt;div className=\u0026#34;delete-button\u0026#34; onClick={handleDeleteButtonClick}\u0026gt; \u0026amp;times; \u0026lt;/div\u0026gt; \u0026lt;/InputContainer\u0026gt; {hasText ? ( \u0026lt;DropDown options={options} handleDropDownClick={handleDropDownClick} selected={selected} /\u0026gt; ) : null} \u0026lt;/div\u0026gt; ); }; export const DropDown = ({ options, handleDropDownClick, selected }) =\u0026gt; { return ( \u0026lt;DropDownContainer\u0026gt; {options.map((option, idx) =\u0026gt; ( \u0026lt;li key={idx} onClick={() =\u0026gt; handleDropDownClick(option)} className={selected === idx ? \u0026#34;selected\u0026#34; : \u0026#34;\u0026#34;} \u0026gt; {option} \u0026lt;/li\u0026gt; ))} \u0026lt;/DropDownContainer\u0026gt; ); }; ClickToEdit #import { useEffect, useState, useRef } from \u0026#34;react\u0026#34;; import styled from \u0026#34;styled-components\u0026#34;; export const InputBox = styled.div` text-align: center; display: inline-block; width: 150px; height: 30px; border: 1px #bbb dashed; border-radius: 10px; margin-left: 1rem; `; export const InputEdit = styled.input` text-align: center; display: inline-block; width: 150px; height: 30px; `; export const InputView = styled.div` text-align: center; align-items: center; margin-top: 3rem; div.view { margin-top: 3rem; } `; export const MyInput = ({ value, handleValueChange }) =\u0026gt; { const inputEl = useRef(null); const [isEditMode, setEditMode] = useState(false); const [newValue, setNewValue] = useState(value); useEffect(() =\u0026gt; { if (isEditMode) { inputEl.current.focus(); } }, [isEditMode]); useEffect(() =\u0026gt; { setNewValue(value); }, [value]); const handleClick = () =\u0026gt; { setEditMode(false); setEditMode(!isEditMode); }; const handleBlur = () =\u0026gt; { handleValueChange(newValue); }; const handleInputChange = (e) =\u0026gt; { setNewValue(e.target.value); }; return ( \u0026lt;InputBox\u0026gt; {isEditMode ? ( \u0026lt;InputEdit type=\u0026#34;text\u0026#34; value={newValue} ref={inputEl} onBlur={handleBlur} onChange={handleInputChange} /\u0026gt; ) : ( \u0026lt;span onClick={handleClick}\u0026gt;{newValue}\u0026lt;/span\u0026gt; )} \u0026lt;/InputBox\u0026gt; ); }; const cache = { name: \u0026#34;김코딩\u0026#34;, age: 20, }; export const ClickToEdit = () =\u0026gt; { const [name, setName] = useState(cache.name); const [age, setAge] = useState(cache.age); return ( \u0026lt;\u0026gt; \u0026lt;InputView\u0026gt; \u0026lt;label\u0026gt;이름\u0026lt;/label\u0026gt; \u0026lt;MyInput value={name} handleValueChange={(newValue) =\u0026gt; setName(newValue)} /\u0026gt; \u0026lt;/InputView\u0026gt; \u0026lt;InputView\u0026gt; \u0026lt;label\u0026gt;나이\u0026lt;/label\u0026gt; \u0026lt;MyInput value={age} handleValueChange={(newValue) =\u0026gt; setAge(newValue)} /\u0026gt; \u0026lt;/InputView\u0026gt; \u0026lt;InputView\u0026gt; \u0026lt;div className=\u0026#34;view\u0026#34;\u0026gt; 이름 {name} 나이 {age} \u0026lt;/div\u0026gt; \u0026lt;/InputView\u0026gt; \u0026lt;/\u0026gt; ); }; Today\u0026rsquo;s takeaway # 컴포넌트 예제 사이트 컴포넌트 예제 사이트를 참조해서 풀었다. 아직 혼자서 구현하기는 힘들지만 예제사이트를 참조하면서 하면 충분히 할 수 있다. 앞으로 틈틈히 컴포넌트 예제 사이트를 참조해서 컴포넌트들을 하나씩 만들어 봐야겠다. ","date":"29 October 2021","permalink":"/posts/bootcamp/bc-10w-5/","section":"Posts","summary":"Today I learned #Sprint - React Custom Component #Autocomplete #import { useState, useEffect } from \u0026#34;react\u0026#34;; import styled from \u0026#34;styled-components\u0026#34;; const deselectedOptions = [ \u0026#34;rustic\u0026#34;, \u0026#34;antique\u0026#34;, \u0026#34;vinyl\u0026#34;, \u0026#34;vintage\u0026#34;, \u0026#34;refurbished\u0026#34;, \u0026#34;신품\u0026#34;, \u0026#34;빈티지\u0026#34;, \u0026#34;중고A급\u0026#34;, \u0026#34;중고B급\u0026#34;, \u0026#34;골동품\u0026#34;, ]; const boxShadow = \u0026#34;0 4px 6px rgb(32 33 36 / 28%)\u0026#34;; const activeBorderRadius = \u0026#34;1rem 1rem 0 0\u0026#34;; const inactiveBorderRadius = \u0026#34;1rem 1rem 1rem 1rem\u0026#34;; export const InputContainer = styled.","title":"BC-10w-5 / [React] 컴포넌트 디자인-실습(2)"},{"content":"Today I learned #\rSprint - React Custom Component # 빌드 컴포넌트 📚 스토리북(Storybook) UI 컴포넌트 개발과 자동으로 문서를 생성할 때 사용 ⚛️ 리액트(React) 선언 중심 컴포넌트 UI(create-react-app)를 사용 💅 스타일 컴포넌트(Styled-components) 컴포넌트 단위의 스타일링에 사용. ✨ 프리티어(Prettier) 자동화된 코드 포맷팅에 사용 Storybook #/* MyComponent.stories.js */ import React from \u0026#34;react\u0026#34;; import { MyComponent } from \u0026#34;../components/MyComponent\u0026#34;; export default { title: \u0026#34;Example/MyComponent\u0026#34;, component: MyComponent, }; const Template = (args) =\u0026gt; \u0026lt;MyComponent {...args} /\u0026gt;; export const Primary = Template.bind({}); Primary.args = { primary: true, label: \u0026#34;MyComponent\u0026#34;, }; \u0026lt;MyComponent label=\u0026#34;MyComponent\u0026#34; primary /\u0026gt; Modal #import { useState } from \u0026#34;react\u0026#34;; import styled from \u0026#34;styled-components\u0026#34;; export const ModalContainer = styled.div` //? 왜 여기서 margin: 8rem을 해줘야 할까? margin: 8rem; display: flex; justify-content: center; `; export const ModalBackdrop = styled.div` position: fixed; z-index: 1000; top: 0; left: 0; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; background-color: rgba(0, 0, 0, 0.5); `; export const ModalBtn = styled.button` background-color: #4000c7; text-decoration: none; border: none; padding: 20px; color: white; border-radius: 30px; cursor: pointer; `; export const ModalXBtn = styled.div` position: absolute; top: 5%; cursor: pointer; `; export const ModalView = styled.div.attrs((props) =\u0026gt; ({ // attrs 메소드를 이용해서 아래와 같이 div 엘리먼트에 속성을 추가할 수 있습니다. role: \u0026#34;dialog\u0026#34;, }))` position: relative; width: 16rem; height: 8rem; background: #fff; border-radius: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center; `; export const Modal = () =\u0026gt; { const [isOpen, setIsOpen] = useState(false); const openModalHandler = (e) =\u0026gt; { // TODO : isOpen의 상태를 변경하는 메소드를 구현합니다. // 하위로의 이벤트 전파를 막음 if (e.target !== e.currentTarget) return; setIsOpen(!isOpen); }; return ( \u0026lt;\u0026gt; \u0026lt;ModalContainer\u0026gt; \u0026lt;ModalBtn // TODO : 클릭하면 Modal이 열린 상태(isOpen)를 boolean 타입으로 변경하는 메소드가 실행되어야 합니다. onClick={openModalHandler} \u0026gt; {/* TODO : 조건부 렌더링을 활용해서 Modal이 열린 상태(isOpen이 true인 상태)일 때는 ModalBtn의 내부 텍스트가 \u0026#39;Opened!\u0026#39; 로 Modal이 닫힌 상태(isOpen이 false인 상태)일 때는 ModalBtn 의 내부 텍스트가 \u0026#39;Open Modal\u0026#39;이 되도록 구현해야 합니다. */} {isOpen ? \u0026#34;Opened!\u0026#34; : \u0026#34;Open Modal\u0026#34;} \u0026lt;/ModalBtn\u0026gt; {/* TODO : 조건부 렌더링을 활용해서 Modal이 열린 상태(isOpen이 true인 상태)일 때만 모달창과 배경이 뜰 수 있게 구현해야 합니다. */} {isOpen ? ( \u0026lt;ModalBackdrop onClick={openModalHandler}\u0026gt; {/* \u0026lt;Modal onClick={(e) =\u0026gt; e.stopPropagation()}\u0026gt; 으로 막을 수도 있음*/} \u0026lt;ModalView\u0026gt; \u0026lt;ModalXBtn onClick={openModalHandler}\u0026gt;X\u0026lt;/ModalXBtn\u0026gt; Hello CodeStates! \u0026lt;/ModalView\u0026gt; \u0026lt;/ModalBackdrop\u0026gt; ) : ( \u0026#34;\u0026#34; )} \u0026lt;/ModalContainer\u0026gt; \u0026lt;/\u0026gt; ); }; Toggle #import { useState } from \u0026#34;react\u0026#34;; import styled from \u0026#34;styled-components\u0026#34;; const ToggleContainer = styled.div` position: relative; margin-top: 8rem; left: 47%; cursor: pointer; \u0026gt; .toggle-container { width: 50px; height: 24px; border-radius: 30px; background-color: #8b8b8b; \u0026amp;.toggle--checked { background-color: #4000c7; } } \u0026gt; .toggle-circle { position: absolute; top: 1px; left: 1px; width: 22px; height: 22px; border-radius: 50%; background-color: #ffffff; transition-duration: 0.5s; \u0026amp;.toggle--checked { left: 27px; } } `; const Desc = styled.div` // TODO : 설명 부분의 CSS를 구현합니다. position: relative; margin-top: 5px; margin-left: 10px; `; export const Toggle = () =\u0026gt; { const [isOn, setisOn] = useState(false); const toggleHandler = () =\u0026gt; { // TODO : isOn의 상태를 변경하는 메소드를 구현합니다. setisOn(!isOn); }; return ( \u0026lt;\u0026gt; \u0026lt;ToggleContainer onClick={toggleHandler}\u0026gt; \u0026lt;div className={`toggle-container ${isOn ? \u0026#34;toggle--checked\u0026#34; : \u0026#34;\u0026#34;}`} /\u0026gt; \u0026lt;div className={`toggle-circle ${isOn ? \u0026#34;toggle--checked\u0026#34; : \u0026#34;\u0026#34;}`} /\u0026gt; \u0026lt;/ToggleContainer\u0026gt; \u0026lt;Desc\u0026gt;{isOn ? \u0026#34;Toggle Switch ON\u0026#34; : \u0026#34;Toggle Switch OFF\u0026#34;}\u0026lt;/Desc\u0026gt; \u0026lt;/\u0026gt; ); }; Tab #import { useState } from \u0026#34;react\u0026#34;; import styled from \u0026#34;styled-components\u0026#34;; const TabMenu = styled.ul` background-color: #dcdcdc; color: rgba(73, 73, 73, 0.5); font-weight: bold; display: flex; list-style: none; .submenu { padding: 0.8rem; text-align: center; cursor: pointer; border-radius: 10px; } .focused { color: #ffffff; background-color: #4900ce; } `; const Desc = styled.div` margin-top: 6rem; `; export const Tab = () =\u0026gt; { const [currentTab, setCurrentTab] = useState(0); const menuArr = [ { name: \u0026#34;Tab1\u0026#34;, content: \u0026#34;Tab menu ONE\u0026#34; }, { name: \u0026#34;Tab2\u0026#34;, content: \u0026#34;Tab menu TWO\u0026#34; }, { name: \u0026#34;Tab3\u0026#34;, content: \u0026#34;Tab menu THREE\u0026#34; }, ]; const selectMenuHandler = (index) =\u0026gt; { setCurrentTab(index); }; return ( \u0026lt;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;TabMenu\u0026gt; {menuArr.map((menu, idx) =\u0026gt; ( \u0026lt;li key={idx} className={idx === currentTab ? \u0026#34;submenu focused\u0026#34; : \u0026#34;submenu\u0026#34;} onClick={() =\u0026gt; selectMenuHandler(idx)} \u0026gt; {menu.name} \u0026lt;/li\u0026gt; ))} \u0026lt;/TabMenu\u0026gt; \u0026lt;Desc\u0026gt; \u0026lt;p\u0026gt;{menuArr[currentTab].content}\u0026lt;/p\u0026gt; \u0026lt;/Desc\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/\u0026gt; ); }; Tag #import { useState } from \u0026#34;react\u0026#34;; import styled from \u0026#34;styled-components\u0026#34;; export const TagsInput = styled.div` margin: 8rem auto; display: flex; align-items: flex-start; flex-wrap: wrap; min-height: 48px; width: 480px; padding: 0 8px; border: 1px solid rgb(214, 216, 218); border-radius: 6px; \u0026gt; ul { display: flex; flex-wrap: wrap; padding: 0; margin: 8px 0 0 0; \u0026gt; .tag { width: auto; height: 32px; display: flex; align-items: center; justify-content: center; color: #fff; padding: 0 8px; font-size: 14px; list-style: none; border-radius: 6px; margin: 0 8px 8px 0; background: #4000c7; \u0026gt; .tag-close-icon { display: block; width: 16px; height: 16px; line-height: 16px; text-align: center; font-size: 14px; margin-left: 8px; color: #4000c7; border-radius: 50%; background: #fff; cursor: pointer; } } } \u0026gt; input { flex: 1; border: none; height: 46px; font-size: 14px; padding: 4px 0 0 0; :focus { outline: transparent; } } \u0026amp;:focus-within { border: 1px solid #4000c7; } `; export const Tag = () =\u0026gt; { const initialTags = [\u0026#34;CodeStates\u0026#34;, \u0026#34;kimcoding\u0026#34;]; const [tags, setTags] = useState(initialTags); const removeTags = (indexToRemove) =\u0026gt; { setTags(tags.filter((tag, idx) =\u0026gt; indexToRemove !== idx)); }; const addTags = (event) =\u0026gt; { if (!tags.includes(event.target.value) \u0026amp;\u0026amp; event.target.value !== \u0026#34;\u0026#34;) { setTags([...tags, event.target.value]); event.target.value = \u0026#34;\u0026#34;; } }; return ( \u0026lt;\u0026gt; \u0026lt;TagsInput\u0026gt; \u0026lt;ul id=\u0026#34;tags\u0026#34;\u0026gt; {tags.map((tag, index) =\u0026gt; ( \u0026lt;li key={index} className=\u0026#34;tag\u0026#34;\u0026gt; \u0026lt;span className=\u0026#34;tag-title\u0026#34;\u0026gt;{tag}\u0026lt;/span\u0026gt; \u0026lt;span className=\u0026#34;tag-close-icon\u0026#34; onClick={() =\u0026gt; removeTags(index)} \u0026gt; x \u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;input className=\u0026#34;tag-input\u0026#34; type=\u0026#34;text\u0026#34; onKeyUp={(e) =\u0026gt; (e.key === \u0026#34;Enter\u0026#34; ? addTags(e) : null)} placeholder=\u0026#34;Press enter to add tags\u0026#34; /\u0026gt; \u0026lt;/TagsInput\u0026gt; \u0026lt;/\u0026gt; ); }; Today\u0026rsquo;s takeaway # 기능의 구현 자체는 어렵지 않았다. CSS를 다루는 것이 어려웠다. 실제 페이지와 Storybook 모두에서 균형을 맞추는 것이 어려웠다. Storybook에 대해서 좀 더 알아보니 조금 더 많은 신경을 써야 하고 어렵지만 컴포넌트 위주의 코딩에는 좀 더 적합했다. 하지만 소규모 프로젝트이며 시간제한이 짧은 파이널 프로젝트를 할 때는 안 써도 될 거 같다. ","date":"28 October 2021","permalink":"/posts/bootcamp/bc-10w-4/","section":"Posts","summary":"Today I learned #\rSprint - React Custom Component # 빌드 컴포넌트 📚 스토리북(Storybook) UI 컴포넌트 개발과 자동으로 문서를 생성할 때 사용 ⚛️ 리액트(React) 선언 중심 컴포넌트 UI(create-react-app)를 사용 💅 스타일 컴포넌트(Styled-components) 컴포넌트 단위의 스타일링에 사용.","title":"BC-10w-4 / [React] 컴포넌트 디자인-실습(1)"},{"content":"Today I learned #\r컴포넌트 단위로 개발하기 #Component Driven Development(CDD) # 컴포넌트 생성 -\u0026gt; 컴포넌트 결합 -\u0026gt; 페이지 조립 예시 BBC 컴포넌트 UI 개발을 위한 Storybook # Component Explorer (컴포넌트 탐색기)\n재사용성을 확대하기 위해 컴포넌트를 문서화하고, 자동으로 컴포넌트를 시각화하여 시뮬레이션할 수 있는 다양한 테스트 상태 확인 가능\n회사의 UI 라이브러리로써 사용하거나, 외부 공개용 디자인 시스템을 개발하기 위한 기본 플랫폼으로 사용\nStorybook에서 지원하는 주요 기능\nUI 컴포넌트들 카탈로그화 컴포넌트 변화를 Stories로 저장 핫 모듈 재 로딩과 같은 개발 툴 경험 제공 리액트를 포함한 다양한 뷰 레이어 지원 설치 및 세팅\n# Clone the template npx degit chromaui/intro-storybook-react-template taskbox cd taskbox # Install dependencies yarn CSS in JS 방법론 #구조적인 CSS 작성 방법의 발전 # 방법론의 목적 코드의 재사용 코드의 간결화(유지보수 용이) 코드의 확장성 코드의 예측성(클래스 명으로 의미 예측) SASS(Syntactically Awesome Style Sheets) CSS 전처리기(preprocessor) CSS 파일 용량이 커짐 BEM(Block, Element, Modifier) Block__Element\u0026ndash;Modifier 클래스 이름이 너무 장황해짐 Styled-Component CSS-in-JS 캡슐화 빠른 페이지 로드에 불리함 컴포넌트 기반 CSS 작성에 적합한 Styled-Component # 기존 CSS 문법으로도 스타일 속성이 추가된 React 컴포넌트를 만들 수 있음\nAutomatic critical CSS\nStyled Component 는 화면에 어떤 컴포넌트가 렌더링 되었는지 추적해서 해당하는 컴포넌트에 대한 스타일을 자동으로 삽입합니다. 코드를 적절히 분배해 놓으면 사용자가 어플리케이션을 사용할 때 최소한의 코드만으로 화면이 띄워지도록 할 수 있습니다. No class name bugs\nStyled Component 는 스스로 유니크한 className 을 생성합니다. className 의 중복이나 오타로 인한 버그를 줄여줍니다. Easier deletion of CSS\n기존에는 더 이상 사용하지 않거나 삭제한 컴포넌트에 해당하는 스타일 속성을 제거하기위해 CSS 파일 안의 className을 이리저리 찾아야 했습니다. 하지만 Styled Component 는 모든 스타일 속성이 특정 컴포넌트와 연결되어 있기 때문에 만약 컴포넌트를 더 이상 사용하지 않아 삭제할 경우 이에 대한 스타일 속성도 함께 삭제됩니다. Simple dynamic styling\nclassName을 일일이 수동으로 관리할 필요 없이 React 의 props 나 전역 속성을 기반으로 컴포넌트에 스타일 속성을 부여하기 때문에 간단하고 직관적입니다. Painless maintenance\n컴포넌트에 스타일을 상속하는 속성을 찾아 다른 CSS 파일들을 검색하지 않아도 되기 때문에 코드의 크기가 커지더라도 유지보수가 어렵지 않습니다. Automatic vendor prefixing\n개별 컴포넌트마다 기존의 CSS 를 이용하여 스타일 속성을 정의하면 될 뿐입니다. 이외의 것들은 Styled Component 가 알아서 처리해 줍니다. 설치\nnpm i package.json에 다음 코드 추가를 권장 {\n\u0026ldquo;resolutions\u0026rdquo;: {\n\u0026ldquo;styled-components\u0026rdquo;: \u0026ldquo;^5\u0026rdquo;\n}\n} 사용\nconst Component = styled.tag` // css `; const SubComponent = styled(Component)` // css `; (1) Getting Started\nimport styled from \u0026#34;styled-components\u0026#34;; // \u0026lt;h1\u0026gt; 태그를 렌더링 할 title component를 만듭니다. const Title = styled.h1` font-size: 1.5em; text-align: center; color: palevioletred; `; // \u0026lt;section\u0026gt; 태그를 렌더링 할 Wrapper component를 만듭니다. const Wrapper = styled.section` padding: 4em; background: papayawhip; `; export default function App() { // 일반적으로 컴포넌트를 사용하는 것처럼 Title과 Wrapper를 사용하시면 됩니다! return ( \u0026lt;Wrapper\u0026gt; \u0026lt;Title\u0026gt;Hello World!\u0026lt;/Title\u0026gt; \u0026lt;/Wrapper\u0026gt; ); } (2) Adapting based on props \u0026amp; Extending Styles\nimport \u0026#34;./styles.css\u0026#34;; import styled from \u0026#34;styled-components\u0026#34;; // 특정 props가 있을 때 조건부 속성 const Button = styled.button` /* Adapt the colors based on primary prop */ background: ${(props) =\u0026gt; (props.primary ? \u0026#34;palevioletred\u0026#34; : \u0026#34;white\u0026#34;)}; color: ${(props) =\u0026gt; (props.primary ? \u0026#34;white\u0026#34; : \u0026#34;palevioletred\u0026#34;)}; font-size: 1em; margin: 1em; padding: 0.25em 1em; border: 2px solid palevioletred; border-radius: 3px; `; // 해당 컴포넌트 만을 위한 추가 속성 // const Tomato = styled(Button)` color: tomato; border-color: tomato; `; export default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Button\u0026gt;Normal\u0026lt;/Button\u0026gt; \u0026lt;Button primary\u0026gt;Primary\u0026lt;/Button\u0026gt; \u0026lt;Tomato\u0026gt;Tomato\u0026lt;/Tomato\u0026gt; \u0026lt;/div\u0026gt; ); } (3) Passed props\nimport styled from \u0026#34;styled-components\u0026#34;; // Styled Component로 만들어진 Input 컴포넌트 입니다. // 특정 props가 있을 때 조건부 속성 // const Input = styled.input` padding: 0.5em; margin: 0.5em; color: ${(props) =\u0026gt; props.inputColor || \u0026#34;red\u0026#34;}; background: papayawhip; border: none; border-radius: 3px; `; export default function App() { return ( \u0026lt;div\u0026gt; {/* 아래 Input 컴포넌트는 styled component인 Input 컴포넌트에 지정된 inputColor(red)가 적용되었습니다. */} \u0026lt;Input defaultValue=\u0026#34;김코딩\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; {/* 아래 Input 컴포넌트는 props로 전달된 커스텀 inputColor(blue)가 적용되었습니다. */} \u0026lt;Input defaultValue=\u0026#34;박해커\u0026#34; type=\u0026#34;text\u0026#34; inputColor=\u0026#34;blue\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } (4) GlobalStyle\n// GlobalStyle.jsx import { createGlobalStyle } from \u0026#34;styled-components\u0026#34;; const GlobalStyle = createGlobalStyle` *, *::before, *::after { box-sizing: border-box; } body { font-family: \u0026#34;Helvetica\u0026#34;, \u0026#34;Arial\u0026#34;, sans-serif; line-height: 1.5; } h2, p { margin: 0; } h2 { font-size: 1.5rem; } p { font-size: 1rem; } `; export default GlobalStyle; // App.jsx import GlobalStyle from \u0026#34;./GlobalStyle\u0026#34;; import BlogPost from \u0026#34;./BlogPost\u0026#34;; function App() { return ( \u0026lt;\u0026gt; \u0026lt;GlobalStyle /\u0026gt; \u0026lt;BlogPost title=\u0026#34;Styled Components 전역 스타일링\u0026#34;\u0026gt; 이번 포스팅에서는 Styled Components로 전역 스타일을 정의하는 방법에 대해서 알아보겠습니다. \u0026lt;/BlogPost\u0026gt; \u0026lt;/\u0026gt; ); } export default App; DOM reference를 잘 활용할 수 있는 useRef #// example(1) import React, { useRef } from \u0026#34;react\u0026#34;; const Focus = () =\u0026gt; { const firstRef = useRef(null); const secondRef = useRef(null); const thirdRef = useRef(null); const handleInput = (event) =\u0026gt; { console.log(event.key, event); if (event.key === \u0026#34;Enter\u0026#34;) { if (event.target === firstRef.current) { secondRef.current.focus(); event.target.value = \u0026#34;\u0026#34;; } else if (event.target === secondRef.current) { thirdRef.current.focus(); event.target.value = \u0026#34;\u0026#34;; } else if (event.target === thirdRef.current) { firstRef.current.focus(); event.target.value = \u0026#34;\u0026#34;; } else { return; } } }; return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;타자연습\u0026lt;/h1\u0026gt; \u0026lt;h3\u0026gt;각 단어를 바르게 입력하고 엔터를 누르세요.\u0026lt;/h3\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label\u0026gt;hello \u0026lt;/label\u0026gt; \u0026lt;input ref={firstRef} onKeyUp={handleInput} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label\u0026gt;world \u0026lt;/label\u0026gt; \u0026lt;input ref={secondRef} onKeyUp={handleInput} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label\u0026gt;codestates \u0026lt;/label\u0026gt; \u0026lt;input ref={thirdRef} onKeyUp={handleInput} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); }; export default Focus; Today\u0026rsquo;s takeaway # 오늘은 React의 style을 만드는 법을 배웠다.\n여러 방법들이 생겨났고 앞으로 생겨날 것이다.\n각 방법들의 장단점을 알고 적절히 활용하자!\n방법 장점 단점 CSS - 일관된 패턴을 갖기 어려움, !important의 남용 SASS(preprocessor) 변수/함수/상속을 활용해 재사용(CSS 구조화) 디버깅 어렵고, 컴파일한 CSS파일이 거대해짐 BEM 전처리 과정 불필요 선택자 이름이 장황하고, 클래스 목록이 너무 많아짐 Styled-Component(CSS-in-JS) CSS를 컴포넌트 안으로 캡슐화, 네이밍이나 최적화를 신경쓸 필요X 빠른 페이지 로드에 불리함 아직은 감이 잘 잡히지 않으나 이틀 동안 실습을 통해 익힐 것이다.\n","date":"27 October 2021","permalink":"/posts/bootcamp/bc-10w-3/","section":"Posts","summary":"Today I learned #\r컴포넌트 단위로 개발하기 #Component Driven Development(CDD) # 컴포넌트 생성 -\u0026gt; 컴포넌트 결합 -\u0026gt; 페이지 조립 예시 BBC 컴포넌트 UI 개발을 위한 Storybook # Component Explorer (컴포넌트 탐색기)","title":"BC-10w-3 / [React] 컴포넌트 디자인-기본"},{"content":"Today I learned #\rSprint - StatesAirline Server #mini server(1) #const express = require(\u0026#34;express\u0026#34;); const cors = require(\u0026#34;cors\u0026#34;); // 서버 시작 const app = express(); // 모든 요청에 대해 CORS 를 허용 app.use(cors()); // strict의 기본값은 true: 배열과 객체만 받음 // false일 때, 원시 데이터 타입도 JSON 형태로 파싱 가능 app.use(express.json({ strict: false })); // MiddleWay const myLogger = (req, res, next) =\u0026gt; { const { method, url } = req; console.log(method, url); next(); }; app.use(myLogger); const port = 5000; const ip = \u0026#34;localhost\u0026#34;; app.post(\u0026#34;/upper\u0026#34;, (req, res) =\u0026gt; { let body = req.body; body = body.toUpperCase(); res.json(body); }); app.post(\u0026#34;/lower\u0026#34;, (req, res) =\u0026gt; { let body = req.body; body = body.toLowerCase(); res.json(body); }); app.listen(port, () =\u0026gt; { console.log(`http server listen on ${ip}:${port}`); }); app.get(\u0026#34;/\u0026#34;, (req, res) =\u0026gt; { res.send(\u0026#34;Hello World!\u0026#34;); }); mini server(2) # 파일에 주석으로 정리 Today\u0026rsquo;s takeaway # 기본 세팅\nconst express = require(\u0026#34;express\u0026#34;); const cors = require(\u0026#34;cors\u0026#34;); const app = express(); app.use(cors()); app.use(express.json()); app.listen(port); Request 메소드\nreq.params url 파라미터 정보 조회 req.query 쿼리 문자열을 조회 req.body 요청 바디를 조회 Response 메소드\nres.send() res.json() res.status() res.set() 응답 상태\n2XX(성공) 200 성공 201 POST의 자원 추가 요청 성공 204 응답할 body가 없을 경우 3XX(클라이언트 요청 에러) 4XX(서버 응답 에러) 400 Bad Request 401 Unauthorized 403 Forbidden. 401과 유사. 로그인 실패 404 Not found 409 Conflict. POST의 자원 추가 요청에 대해 자원이 이미 있어서 실패 ","date":"26 October 2021","permalink":"/posts/bootcamp/bc-10w-2/","section":"Posts","summary":"Today I learned #\rSprint - StatesAirline Server #mini server(1) #const express = require(\u0026#34;express\u0026#34;); const cors = require(\u0026#34;cors\u0026#34;); // 서버 시작 const app = express(); // 모든 요청에 대해 CORS 를 허용 app.","title":"BC-10w-2 / [Web Server] 기초(3)"},{"content":"","date":null,"permalink":"/tags/network/","section":"Tags","summary":"","title":"Network"},{"content":"Today I learned #\rChapter - Refactor Express # npm install express \u0026ndash;save 라우팅 메소드와 URL(/lower, /upper 등)로 분기점을 만드는 것 /* 순수 node.js */ const requestHandler = (req, res) =\u0026gt; { if (req.url === \u0026#34;/lower\u0026#34;) { if (req.method === \u0026#34;GET\u0026#34;) { res.end(data); } else if (req.method === \u0026#34;POST\u0026#34;) { req.on(\u0026#34;data\u0026#34;, (req, res) =\u0026gt; { // do something }); } } }; /* Express */ const app = express(); app.get(\u0026#34;/lower\u0026#34;, (req, res) =\u0026gt; { res.send(data); }); app.post(\u0026#34;/lower\u0026#34;, (req, res) =\u0026gt; { // do something }); 미들웨어\n미들웨어를 사용하는 상황\n모든 요청에 대해 url이나 메소드를 확인할 때\nconst express = require(\u0026#34;express\u0026#34;); const app = express(); const myLogger = function (req, res, next) { console.log( `http request method is ${req.method}, url is ${request.url}` ); next(); }; app.use(myLogger); app.get(\u0026#34;/\u0026#34;, function (req, res) { res.send(\u0026#34;Hello World!\u0026#34;); }); app.listen(5000); POST 요청 등에 포함된 body(payload)를 구조화할 때\n모든 요청/응답에 CORS 헤더를 붙여야 할 때\n/* 순수 Node.js */ const defaultCorsHeader = { \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;GET, POST, PUT, DELETE, OPTIONS\u0026#34;, \u0026#34;Access-Control-Allow-Headers\u0026#34;: \u0026#34;Content-Type, Accept\u0026#34;, \u0026#34;Access-Control-Max-Age\u0026#34;: 10, }; if (req.method === \u0026#34;OPTIONS\u0026#34;) { res.writeHead(201, defaultCorsHeader); res.end(); } /* Express */ const cors = require(\u0026#34;cors\u0026#34;); app.use(cors()); 요청 헤더에 사용자 인증 정보가 담겨있는지 확인할 때\napp.use((req, res, next) =\u0026gt; { // 토큰 있니? 없으면 받아줄 수 없어! if (req.headers.token) { req.isLoggedIn = true; next(); } else { res.status(400).send(\u0026#34;invalid user\u0026#34;); } }); /* Mini Node Server(3)-Express */ const express = require(\u0026#34;express\u0026#34;); const cors = require(\u0026#34;cors\u0026#34;); // 서버 시작 const app = express(); // 모든 요청에 대해 CORS 를 허용 app.use(cors()); // 원시 데이터 타입도 JSON 형태로 파싱 가능 // strict의 기본값이 true(배열과 객체만 받음) app.use(express.json({ strict: false })); const port = 5000; const ip = \u0026#34;localhost\u0026#34;; app.post(\u0026#34;/upper\u0026#34;, (req, res) =\u0026gt; { let body = req.body; body = body.toUpperCase(); res.json(body); }); app.post(\u0026#34;/lower\u0026#34;, (req, res) =\u0026gt; { let body = req.body; body = body.toLowerCase(); res.json(body); }); app.listen(port, () =\u0026gt; { console.log(`http server listen on ${ip}:${port}`); }); app.get(\u0026#34;/\u0026#34;, (req, res) =\u0026gt; { res.send(\u0026#34;Hello World!\u0026#34;); }); Today\u0026rsquo;s takeaway # Express는 Node.js를 위한 빠르고 개방적인 간결한 웹 프레임워크이다. 자유롭게 활용할 수 있는 수많은 HTTP 유틸리티 메소드 및 미들웨어를 통해 쉽고 빠르게 강력한 API를 작성할 수 있다. 아직 적응이 안 됐지만 내일 실습과 공식 문서 탐독을 통해 익히겠다. Express의 장점 라우팅할 때 if 안 써도 됨 body 받기가 편함 CORS 적용 간편 ","date":"25 October 2021","permalink":"/posts/bootcamp/bc-10w-1/","section":"Posts","summary":"Today I learned #\rChapter - Refactor Express # npm install express \u0026ndash;save 라우팅 메소드와 URL(/lower, /upper 등)로 분기점을 만드는 것 /* 순수 node.","title":"BC-10w-1 / [Web Server] 기초(2)"},{"content":"Today I learned #Algorithm Test 12 treeBFS #let func = function (node) { // 반복문 밖의 변수에 누적 const queue = [node]; const result = []; while (queue.length \u0026gt; 0) { // queue라서 순서데로 const node = queue.shift(); // node의 값을 먼저 넣고 result.push(node.value); // 자식 노드들을 큐에 넣음 node.children.forEach((childNode) =\u0026gt; { queue.push(childNode); }); } return result; }; let Node = function (value) { this.value = value; this.children = []; }; CORS(Cross Origin Resource Sharing) # 보안 상의 이유로, 브라우저들은 스크립트 내에서 초기화되는 cross-origin HTTP 요청을 제한 개발자들은 브라우저 벤더사들에세 XMLHttpRequest가 cross-origin을 요청할 수 있도록 요청 서버가 Allow 한 범위내에서 cross-origin 요청 허용 const defaultCorsHeader = { \u0026#34;access-control-allow-origin\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;access-control-allow-methods\u0026#34;: \u0026#34;GET, POST, PUT, DELETE, OPTION\u0026#34;, \u0026#34;access-control-allow-headers\u0026#34;: \u0026#34;content-type, accept\u0026#34;, \u0026#34;access-control-max-age\u0026#34;: 10, // Seconds. }; /* 모든 도메인(*) 허용 메소드는 GET, POST, PUT, DELETE, OPTION만 허용 헤더에는 control-type과 accept만 허용 preflight request는 10초까지 허용 */ OPTIONS preflight request 클라이언트가 서버에서 Allow 하는 조건들을 다 맞추고 있는가 사전에 서버에 확인하는 요청 Sprint - Mini Node Server # Web Server HTTP 요청을 처리하고 응답을 보내 주는 프로그램 Node.js의 http 모듈로 Web Server 제작 HTTP 트랜잭션 해부 서버 실행 node server/basic-server.js 서버 생성\nconst http = require(\u0026#34;http\u0026#34;); const PORT = ... const server = http .createServer((request, response) =\u0026gt; { // 여기서 작업이 진행됩니다! }) .listen(PORT); HTTP 요청이 서버에 오면 \u0026ldquo;.createServer()\u0026rdquo; 메소드로 request와 response 객체를 전달하며 요청 핸들러 함수를 호출 요청을 처리하려면 \u0026ldquo;.listen()\u0026rdquo; 메소드가 server 객체에서 호출되어야 하는데, 대부분 서버가 사용하고자 하는 포트 번호를 listen에 전달하기만 하면 됨 method, URL, header\nconst { method, url, headers } = request; const userAgent = headers[\u0026#34;user-agent\u0026#34;]; method는 일반적인 HTTP 메소드/동사 url은 전체 URL에서 서버, 프로토콜, 포트를 제외한 것으로, 세 번째 슬래시 이후의 나머지 전부 모든 header는 소문자로만 표현 요청 바디\nlet body = []; request .on(\u0026#34;data\u0026#34;, (chunk) =\u0026gt; { body.push(chunk); }) .on(\u0026#34;end\u0026#34;, () =\u0026gt; { body = Buffer.concat(body).toString(); }); request 객체는 \u0026ldquo;data\u0026quot;와 \u0026ldquo;end\u0026rdquo; 이벤트로 데이터를 받을 수 있음 각 \u0026ldquo;data\u0026rdquo; 이벤트에서 발생시킨 \u0026ldquo;chunk\u0026quot;는 Buffer \u0026ldquo;chunk\u0026quot;가 문자열 데이터일 때, 이 데이터를 배열에 담고, \u0026ldquo;end\u0026rdquo; 이벤트에서 이어 붙인 다음 문자열로 만드는 것이 가장 좋음 메소드 정리 request.on(\u0026ldquo;data\u0026rdquo;, (chunk) =\u0026gt; {})\nrequest.on(\u0026ldquo;end\u0026rdquo;, () =\u0026gt; {}) response.writeHead(응답 넘버, 응답 헤더)\nresponse.end(전달하고 싶은 데이터) /* Mini Node Server(1) */ const http = require(\u0026#34;http\u0026#34;); const PORT = 5000; const ip = \u0026#34;localhost\u0026#34;; const server = http.createServer((req, res) =\u0026gt; { // 요청이 OPTIONS일 때, 클라이언트의 preflight request에 대한 응답을 돌려줌 if (req.method === \u0026#34;OPTIONS\u0026#34;) { // 명시적으로 응답 스트림에 헤더를 작성 res.writeHead(200, defaultCorsHeader); res.end(); } if (req.method === \u0026#34;POST\u0026#34;) { let body = []; req // 요청의 data chunk를 body에 넣음 .on(\u0026#34;data\u0026#34;, (chunk) =\u0026gt; { body.push(chunk); }) // 요청이 끝날 때 body를 문자열로 변환 후 응답 .on(\u0026#34;end\u0026#34;, () =\u0026gt; { body = Buffer.concat(body).toString(); res.writeHead(201, defaultCorsHeader); if (req.url === \u0026#34;/lower\u0026#34;) { // 응답이 끝날 때 body를 대문자로 내보냄 res.end(body.toLowerCase()); } else if (req.url === \u0026#34;/upper\u0026#34;) { // 응답이 끝날 때 body를 소문자로 내보냄 res.end(body.toUpperCase()); } else { // 에러 전달 res.writeHead(404, defaultCorsHeader); res.end(); } }); } }); // 요청 처리 server.listen(PORT, ip, () =\u0026gt; { console.log(`http server listen on ${ip}:${PORT}`); }); // 응답 헤더 const defaultCorsHeader = { \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;GET, POST, PUT, DELETE, OPTIONS\u0026#34;, \u0026#34;Access-Control-Allow-Headers\u0026#34;: \u0026#34;Content-Type, Accept\u0026#34;, \u0026#34;Access-Control-Max-Age\u0026#34;: 10, }; /* Mini Node Server(2) */ const http = require(\u0026#34;http\u0026#34;); const PORT = 5000; const server = http .createServer((req, res) =\u0026gt; { if (req.method === \u0026#34;OPTIONS\u0026#34;) { res.writeHead(200, defaultCorsHeader); res.end(); } if (req.method === \u0026#34;POST\u0026#34;) { let body = \u0026#34;\u0026#34;; req .on(\u0026#34;data\u0026#34;, (chunk) =\u0026gt; { body += chunk; }) .on(\u0026#34;end\u0026#34;, () =\u0026gt; { res.writeHead(201, defaultCorsHeader); if (req.url === \u0026#34;/upper\u0026#34;) { res.end(body.toUpperCase()); } else if (req.url === \u0026#34;/lower\u0026#34;) { res.end(body.toLowerCase()); } else { res.writeHead(404, defaultCorsHeader); res.end(); } }); } }) .listen(PORT); const defaultCorsHeader = { \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;GET, POST, PUT, DELETE, OPTIONS\u0026#34;, \u0026#34;Access-Control-Allow-Headers\u0026#34;: \u0026#34;Content-Type, Accept\u0026#34;, \u0026#34;Access-Control-Max-Age\u0026#34;: 10, }; Today\u0026rsquo;s takeaway # 기본적인 서버 설계에 대해서 배웠다. 서버를 만드는 것은 처음이라 아직 어렵다. 주소를 통해서 request를 보내고, 서버에서 처리를 한 다음 response를 보낸다. 데이터는 body를 통해서 보내고, 조회는 query와 params를 이용한다. ","date":"22 October 2021","permalink":"/posts/bootcamp/bc-9w-5/","section":"Posts","summary":"Today I learned #Algorithm Test 12 treeBFS #let func = function (node) { // 반복문 밖의 변수에 누적 const queue = [node]; const result = []; while (queue.","title":"BC-9w-5 / [Web Server] 기초(1)"},{"content":"Today I learned #\r+ React with FastCampus(8) Deploy React App #SPA 프로젝트 배포 이해하기 # npm run build long term caching techniques SPA Deploy 특징 모든 요청을 서버에 하고 받아오는 형태가 아님 라우팅 경로에 상관없이 리액트 앱을 받아 실행 라우팅은 받아온 리액트 앱을 실행 후 적용 static 파일을 제외한 모든 요청을 index.html로 응답해 주도록 작업 SPA Deploy 방식 serve -s build https://github.com/zeit/serve AWS S3 NginX node.js express serve 패키지 #npm i serve -g serve -s build # -s 옵션은 어떤 라우팅으로 요청해도 index.html을 응답하도록 함 AWS S3 # 버킷 만들고 해당 버킷으로 이동 모든 파일(build 내부) 추가 static 폴더(build 내부) 추가 업로드 속성으로 이동 정적 웹사이트 호스팅 활성화 인덱스 문서와 오류 문서는 index.html 권한으로 이동 퍼블릭 엑세스 차단 해제 버킷 정책 편집 { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;PublicReadGetObject\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;allow\u0026#34;, \u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: [\u0026#34;s3:GetObject\u0026#34;], \u0026#34;Resource\u0026#34;: [\u0026#34;arn:aws:s3:::버킷이름/*\u0026#34;] } ] } *https와 ssl을 적용하고 싶으면 \u0026ldquo;cloud front\u0026quot;라는 cdn을 달아야함\nNginX #node.js의 express #npm i express // server.js const express = require(\u0026#34;express\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const app = express(); // express.static() -\u0026gt; static server 셍성 // path.join() -\u0026gt; 경로 // __dirname -\u0026gt; node.js global 변수, 현재 루트 폴더명 // \u0026#39;build\u0026#39; -\u0026gt; ...의 build를 join app.use(express.static(path.join(__dirname, \u0026#34;build\u0026#34;))); // app.get(\u0026#39;/\u0026#39;, function(req, res) { app.get(\u0026#34;*\u0026#34;, function (req, res) { res.sendFile(path.join(__dirname, \u0026#34;build\u0026#34;, \u0026#34;index.html\u0026#34;)); }); app.listen(9000); 서버사이드 랜더링 # ReactDOMServer import ReactDOMServer from \u0026#34;react-dom/server\u0026#34;; Server Side Rendering 서버에서 응답을 가져올때, 기존 처럼 static file 만을 가져오는 것이 아니고, 먼저 서버에서 응답 값을 만들어서 내려주고, 그 후에 static file 을 내려줍니다. static file 을 다 내려받고, 리액트 앱을 브라우저에서 실행한 뒤에는 SPA 처럼 동작하게 됩니다. React Server Side Rendering React Component 를 브라우저가 아니라 Node.js 에서 사용 ReactDOMServer.renderToString(\u0026lt;App /\u0026gt;); 결과가 문자열 이것을 응답으로 내려준다. 라우팅, 리덕스 와 같은 처리를 서버에서 진행하고 내려준다. 복잡, 어렵 JSX 가 포함된 리액트 코드를 서버에서 읽을 수 있도록 babel 설정을 해야 한다. // 서버 사이드 랜더링과 클라이언트 사이드 랜더링이 다를때 자동으로 덮어써줌 // server.js const express = require(\u0026#34;express\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const app = express(); const ReactDOMServer = require(\u0026#34;react-dom/server\u0026#34;); const react = require(\u0026#34;React\u0026#34;); const fs = require(\u0026#34;fs\u0026#34;); app.use(express.static(path.join(__dirname, \u0026#34;build\u0026#34;))); app.get(\u0026#34;/test\u0026#34;, (req, res) =\u0026gt; { // \u0026lt;div data-reactroot\u0026#34;\u0026#34;\u0026gt;Hello\u0026lt;/div\u0026gt; const ssr = ReactDOMServer.renderToString( React.createElement(\u0026#34;div\u0026#34;, null, \u0026#34;Hello\u0026#34;) ); const indexHtml = fs .readFileSync(path.join(__dirname, \u0026#34;build\u0026#34;, \u0026#34;index.html\u0026#34;)) .toString() .replace(\u0026#39;\u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;, `\u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt;${ssr}\u0026lt;/div\u0026gt;`); res.send(indexHtml); }); app.get(\u0026#34;*\u0026#34;, function (req, res) { res.sendFile(path.join(__dirname, \u0026#34;build\u0026#34;, \u0026#34;index.html\u0026#34;)); }); app.listen(9000); Today\u0026rsquo;s takeaway # 서버를 구현하는 여러 방식이 있다. 맛보기로만 대충 배워서, 이런 방식들이 있다는 것만 머리에 넣어두고, 하나하나 직접 검색해서 사용법을 알아볼 것이다. ","date":"21 October 2021","permalink":"/posts/bootcamp/bc-9w-4/","section":"Posts","summary":"Today I learned #\r+ React with FastCampus(8) Deploy React App #SPA 프로젝트 배포 이해하기 # npm run build long term caching techniques SPA Deploy 특징 모든 요청을 서버에 하고 받아오는 형태가 아님 라우팅 경로에 상관없이 리액트 앱을 받아 실행 라우팅은 받아온 리액트 앱을 실행 후 적용 static 파일을 제외한 모든 요청을 index.","title":"BC-9w-4 / {FC} React(8) Deploy React App"},{"content":"Today I learned #\rReact 데이터 흐름 # 데이터 흐름\n컴포넌트를 만들고, 조립해서 페이지를 만듦(상향식) 컴포넌트는 단일 책임 원칙(하나의 컴포넌트는 하나의 일만 담당) 데이터는 위에서 아래로 흐름(props)(하향식) -\u0026gt; 단방향 데이터 흐름(one-way data flow) 상태(state)는 최소화하는 것이 좋음 부모로부터 props를 통해 전달되지 않고, 시간이 지날 때 변하며, 컴포넌트 안의 다른 state나 props를 가지고 계산 가능할 때, state 하나의 상태를 기반으로 두 컴포넌트가 영향을 받는다면 이때는 공통 소유 컴포넌트를 찾아 그곳에 상태를 위치해야 함 State and Lifecycle State 끌어올리기 (Lifting State Up)\n상위 컴포넌트의 \u0026ldquo;상태를 변경하는 함수\u0026rdquo; 그 자체를 하위 컴포넌트로 전달하고, 이 함수를 하위 컴포넌트가 실행한다\nfunction ParentComponent() { const [value, setValue] = useState(\u0026#34;1\u0026#34;); const handleChangeValue = (newValue) =\u0026gt; { setValue(newValue); }; return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;값은 {value} 입니다\u0026lt;/div\u0026gt; \u0026lt;ChildComponent handleChangeValue={handleChangeValue} /\u0026gt; \u0026lt;/div\u0026gt; ); } function ChildComponent({ handleChangeValue }) { // 함수의 실행 자체를 넘겨주면 안됨 const handleClick = () =\u0026gt; { handleChangeValue(\u0026#34;2\u0026#34;); }; return \u0026lt;button onClick={handleClick}\u0026gt;값 변경\u0026lt;/button\u0026gt;; } Effect Hook #Side Effect # Side Effect (부수 효과)\n// 전역 변수 foo를 bar라는 함수가 수정하는 예제 let foo = \u0026#34;hello\u0026#34;; function bar() { foo = \u0026#34;world\u0026#34;; } bar(); Pure Function (순수 함수)\n오직 함수의 입력만이 함수의 결과에 영향을 주는 함수 어떤 전달 인자가 주어질 경우, 항상 똑같은 값이 리턴됨 예측 가능한 함수 function upper(str) { // toUpperCase is immutable return str.toUpperCase(); } upper(\u0026#34;hello\u0026#34;); // \u0026#39;HELLO\u0026#39; 우리가 앞서 배운 React의 함수 컴포넌트는, props가 입력으로, JSX Element가 출력으로 나감 (순수 함수)\nAJAX 요청이 필요하거나, LocalStorage 또는 타이머와 같은 React와 상관없는 API를 사용하는 경우 발생하는 Side Effect를 다루기 위한 Hook인 Effect Hook을 제공\nEffect Hook (1) - 기본 #function Proverb({ saying }) { // side effect useEffect(() =\u0026gt; { document.title = saying; }); return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;오늘의 명언\u0026lt;/h3\u0026gt; \u0026lt;div\u0026gt;{saying}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } 아래와 같이 매 번 새롭게 컴포넌트가 렌더링될 때, Effect Hook이 실행 컴포넌트 생성 후 처음 화면에 렌더링(표시) 컴포넌트에 새로운 props가 전달되며 렌더링 컴포넌트에 상태(state)가 바뀌며 렌더링 Hook을 쓸 때 주의할 점 최상위에서만 Hook을 호출 React 함수 내에서 Hook을 호출 Effect Hook (2) - 조건부 실행 #useEffect(() =\u0026gt; { const result = getProverbs(filter); setProverbs(result); }, [filter]); useEffect(함수) 렌더링 마다 실행 useEffect(함수, []) 첫 렌더링 때만 실행 useEffect(함수, [종속성1, 종속성2, \u0026hellip;]) 배열의 인자들 값이 변할 때 마다 실행 AJAX 요청 # 장점 단점 예시 컴포넌트 내부에서 처리 HTTP 요청의 빈도를 줄임 브라우저(클라이언트)의 메모리상에 많은 데이터를 갖게 되므로, 클라이언트의 부담이 늘어남 처음 단 한번, 외부 API로부터 명언 목록을 받아오고, filter 함수를 이용 컴포넌트 외부에서 처리 클라이언트가 필터링 구현을 생각하지 않아도 됨 빈번한 HTTP 요청이 일어나게 되며, 서버가 필터링을 처리하므로 서버가 부담을 가져감 검색어가 바뀔 때마다, 외부 API를 호출 컴포넌트 외부에서 처리 with 로딩 화면(loading indicator)\nuseEffect(() =\u0026gt; { setIsLoading(true); fetch(`http://서버주소/proverbs?q=${filter}`) .then((resp) =\u0026gt; resp.json()) .then((result) =\u0026gt; { setProverbs(result); setIsLoading(false); }); }, [filter]); const [isLoading, setIsLoading] = useState(true); ... return { isLoading ? \u0026lt;LoadingIndicator /\u0026gt; : \u0026lt;div\u0026gt;로딩 완료 화면\u0026lt;/div\u0026gt; } 클라이언트가 서버에 요청을 덜 보내는 방법\nThrottle a series of fetch requests in JavaScript throttle과 debounce throttle은 재발동에 시간 제한을 검 debounce는 그룹의 (주로)마지막 값을 받음 HTTP caching\nSprint - StatesAirline Client (1) 항공권 목록 필터링 #/* main.js */ const search = ({ departure, destination }) =\u0026gt; { if ( condition.departure !== departure || condition.destination !== destination ) { // Search.js에서 search 함수 작동 setCondition({ departure, destination }); } }; useEffect(() =\u0026gt; { setIsLoading(true); // 조건을 받아서 그 데이터를 리스트에 넣음 getFlight(condition).then((data) =\u0026gt; { setFlightList(data); setIsLoading(false); }); }, [condition]); ... return ... \u0026lt;Search onSearch={search} /\u0026gt; ... // 로딩 페이지 {isLoading ? \u0026lt;LoadingIndicator /\u0026gt; : \u0026lt;FlightList list={flightList} /\u0026gt;} /* Search.js */ const handleSearchClick = () =\u0026gt; { const departure = \u0026#34;ICN\u0026#34;; const destination = textDestination === \u0026#34;\u0026#34; ? null : textDestination; // search 함수를 props로 받아서 인자를 넣어 실행 onSearch({ departure, destination }); }; ... return ... \u0026lt;button id=\u0026#34;search-btn\u0026#34; onClick={handleSearchClick}\u0026gt; 검색 \u0026lt;/button\u0026gt; Sprint - StatesAirline Client (2) AJAX 요청 #// 인수(filterBy)가 객체 export function getFlight(filterBy = {}) { let query = \u0026#34;\u0026#34;; if (filterBy.departure) query = query + `departure=${filterBy.departure}\u0026amp;`; if (filterBy.destination) { query = query + `destination=${filterBy.destination}`; } return fetch( `http://ec2-13-124-90-231.ap-northeast-2.compute.amazonaws.com:81/flight?${query}` ).then((response) =\u0026gt; response.json()); } Today\u0026rsquo;s takeaway # State 끌어올리기는 state나 setState를 props로 전달 useState로 사이드 이펙트를 처리 원래 하던 대로 했을 때 잘되지 않았는데, 이유는 좀 더 쉽게 할 수 있게 자동으로 자료들이 처리되게 미리 구성되어 있었기 때문이었다. 전체 구조를 파악하고 데이터의 흐름을 이해하고 나니 해결할 수 있었다. query string은 서버에서 설계한 데로 작동한다. ","date":"20 October 2021","permalink":"/posts/bootcamp/bc-9w-3/","section":"Posts","summary":"Today I learned #\rReact 데이터 흐름 # 데이터 흐름","title":"BC-9w-3 / [React] 데이터 흐름의 이해와 비동기 처리"},{"content":"Today I learned #Algorithm Test 09 나머지의 분배 #\r나머지의 분배 (A + B) % C === ((A % C) + (B % C)) % C (A _ B) % C === ((A _ C) _ (B _ C)) % C (A - B) % C === ((A % C) - (B % C) + C) % C Rest API # REST(Representational State Transfer) API는 웹에서 사용되는 데이터나 자원(Resource)을 HTTP URI로 표현하고, HTTP 프로토콜을 통해 요청과 응답을 정의하는 방식\nRest 성숙도 모델 (RMM) # 0단계: 단순히 HTTP 프로토콜을 사용\n/* 예약 가능 시간 확인 */ // Request POST /appointment HTTP/1.1 [해더 생략] { \u0026#34;date\u0026#34;: \u0026#34;2021-10-19\u0026#34;, \u0026#34;doctor\u0026#34;: \u0026#34;Yu\u0026#34; } // Responses HTTP/1.1 200 OK [헤더 생략] { \u0026#34;slots\u0026#34;: [ { \u0026#34;doctor\u0026#34;: \u0026#34;Yu\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;09:00\u0026#34;, \u0026#34;end\u0026#34;: \u0026#34;12:00\u0026#34;}, { \u0026#34;doctor\u0026#34;: \u0026#34;Yu\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;14:00\u0026#34;, \u0026#34;end\u0026#34;: \u0026#34;16:00\u0026#34;} ] } /* 특정 시간대 예약 */ // Request POST /appointment HTTP/1.1 [해더 생략] { \u0026#34;doctor\u0026#34;: \u0026#34;Yu\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;14:00\u0026#34;, \u0026#34;end\u0026#34;: \u0026#34;15:00\u0026#34;, \u0026#34;patient\u0026#34;: \u0026#34;chan\u0026#34; } // Responses HTTP/1.1 200 OK [헤더 생략] 1단계: 개별 리소스와의 통신을 준수\n모든 자원은 개별 리소스에 맞는 엔드포인트(Endpoint)를 사용해야 함\n*엔드포인트는 리소스에 집중해 명사 형태의 단어로 작성(동사x)\n/* 예약 가능 시간 확인 */ // Request POST /doctors/Yu HTTP/1.1 [해더 생략] { \u0026#34;date\u0026#34;: \u0026#34;2021-10-19\u0026#34;, \u0026#34;doctor\u0026#34;: \u0026#34;Yu\u0026#34; } // Responses HTTP/1.1 200 OK [헤더 생략] { \u0026#34;slots\u0026#34;: [ { \u0026#34;id\u0026#34;: 123, \u0026#34;doctor\u0026#34;: \u0026#34;Yu\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;09:00\u0026#34;, \u0026#34;end\u0026#34;: \u0026#34;12:00\u0026#34;}, { \u0026#34;id\u0026#34;: 124, \u0026#34;doctor\u0026#34;: \u0026#34;Yu\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;14:00\u0026#34;, \u0026#34;end\u0026#34;: \u0026#34;16:00\u0026#34;} ] } /* 특정 시간대 예약 */ // Request POST /slots/123 HTTP/1.1 [해더 생략] { \u0026#34;patient\u0026#34;: \u0026#34;chan\u0026#34; } // Responses HTTP/1.1 200 OK [헤더 생략] { \u0026#34;appointment\u0026#34;: { \u0026#34;slot\u0026#34;: { \u0026#34;id\u0026#34;:123, \u0026#34;doctor\u0026#34;: \u0026#34;Yu\u0026#34;, ...}, \u0026#34;patient\u0026#34;: \u0026#34;chan\u0026#34; } } 요청하고 받은 자원에 대한 정보를 응답으로 전달해야 함\n(리소스 사용에 대한 실패 여부를 포함한 응답)\n/* 예약 가능 시간 확인 */ // Request POST /doctors/Yu HTTP/1.1 [해더 생략] { \u0026#34;date\u0026#34;: \u0026#34;2021-10-19\u0026#34;, \u0026#34;doctor\u0026#34;: \u0026#34;Yu\u0026#34; } // Responses HTTP/1.1 200 OK [헤더 생략] { \u0026#34;slots\u0026#34;: [ { \u0026#34;id\u0026#34;: 123, \u0026#34;doctor\u0026#34;: \u0026#34;Yu\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;09:00\u0026#34;, \u0026#34;end\u0026#34;: \u0026#34;12:00\u0026#34;}, { \u0026#34;id\u0026#34;: 124, \u0026#34;doctor\u0026#34;: \u0026#34;Yu\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;14:00\u0026#34;, \u0026#34;end\u0026#34;: \u0026#34;16:00\u0026#34;} ] } /* 특정 시간대 예약 */ // Request POST /slots/123 HTTP/1.1 [해더 생략] { \u0026#34;patient\u0026#34;: \u0026#34;chan\u0026#34; } // Responses HTTP/1.1 200 OK [헤더 생략] { \u0026#34;appointmentFailure\u0026#34;: { \u0026#34;slot\u0026#34;: { \u0026#34;id\u0026#34;:123, \u0026#34;doctor\u0026#34;: \u0026#34;Yu\u0026#34;, ...}, \u0026#34;patient\u0026#34;: \u0026#34;chan\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;해당 시간은 이미 예약되어 있습니다.\u0026#34; } } 2단계: CRUD에 맞게 적절한 HTTP 메소드 사용(여기까지 해도 좋은 REST API)\n/* 예약 가능 시간 확인 */ // Request GET /doctors/Yu/slots?data=2021-10-19 HTTP/1.1 [해더 생략] // Responses HTTP/1.1 200 OK [헤더 생략] { \u0026#34;slots\u0026#34;: [ { \u0026#34;id\u0026#34;: 123, \u0026#34;doctor\u0026#34;: \u0026#34;Yu\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;09:00\u0026#34;, \u0026#34;end\u0026#34;: \u0026#34;12:00\u0026#34;}, { \u0026#34;id\u0026#34;: 124, \u0026#34;doctor\u0026#34;: \u0026#34;Yu\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;14:00\u0026#34;, \u0026#34;end\u0026#34;: \u0026#34;16:00\u0026#34;} ] } /* 특정 시간대 예약 */ // Request POST /slots/123 HTTP/1.1 [해더 생략] { \u0026#34;patient\u0026#34;: \u0026#34;chan\u0026#34; } // Responses HTTP/1.1 201 Created Location: slots/123/appointment [헤더 생략] { \u0026#34;appointment\u0026#34;: { \u0026#34;slot\u0026#34;: { \u0026#34;id\u0026#34;:123, \u0026#34;doctor\u0026#34;: \u0026#34;Yu\u0026#34;, ...}, \u0026#34;patient\u0026#34;: \u0026#34;chan\u0026#34;, } } GET: 서버의 데이터를 변화시키지 않는 요청 POST: 요청마다 새로운 리소스를 생성 PUT: 요청마다 같은 리소스를 반환(idempotent)\n*PUT은 교체, PATCH는 수정의 용도 3단계: HATEOAS(Hypertext As The Engine Of Application State)라는 약어로 표현되는 하이퍼미디어 컨트롤을 적용\n/* 예약 가능 시간 확인 */ // Request GET /doctors/Yu/slots?data=2021-10-19 HTTP/1.1 [해더 생략] // Responses HTTP/1.1 200 OK [헤더 생략] { \u0026#34;slots\u0026#34;: [ { \u0026#34;id\u0026#34;: 123, \u0026#34;doctor\u0026#34;: \u0026#34;Yu\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;09:00\u0026#34;, \u0026#34;end\u0026#34;: \u0026#34;12:00\u0026#34;}, { \u0026#34;id\u0026#34;: 124, \u0026#34;doctor\u0026#34;: \u0026#34;Yu\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;14:00\u0026#34;, \u0026#34;end\u0026#34;: \u0026#34;16:00\u0026#34;} ], \u0026#34;links\u0026#34; : { \u0026#34;appointment\u0026#34;: { \u0026#34;href\u0026#34;: \u0026#34;http://localhost:8080/slots/123\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;POST\u0026#34; } } } /* 특정 시간대 예약 */ // Request POST /slots/123 HTTP/1.1 [해더 생략] { \u0026#34;patient\u0026#34;: \u0026#34;chan\u0026#34; } // Responses HTTP/1.1 201 Created Location: slots/123/appointment [헤더 생략] { \u0026#34;appointment\u0026#34;: { \u0026#34;slot\u0026#34;: { \u0026#34;id\u0026#34;:123, \u0026#34;doctor\u0026#34;: \u0026#34;Yu\u0026#34;, ...}, \u0026#34;patient\u0026#34;: \u0026#34;chan\u0026#34;, }, \u0026#34;links\u0026#34; : { \u0026#34;self\u0026#34;: { \u0026#34;href\u0026#34;: \u0026#34;http://localhost:8080/slots/123\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34; }, \u0026#34;cancel\u0026#34;: { \u0026#34;href\u0026#34;: \u0026#34;http://localhost:8080/slots/123/cancel\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;DELETE\u0026#34; } } } Reference\n5가지의 기본적인 REST API 디자인 가이드 구글의 REST API 디자인 가이드 MS의 REST API 디자인 가이드 Open API와 API Key # Open API 정부에서 제공하는 공공데이터 포털 Open Weather Map 프리 플랜에서는 기본적으로 분당 60번, 달마다 1백 번 호출이 가능 데이터를 JSON 형태로 응답 API Key 서버의 문을 여는 열쇠 로그인된 이용자에게만 자원에 접근할 수 있는 권한을 API Key의 형태로 제공하면, 데이터를 요청할 때 API key를 같이 전달해야만 원하는 응답을 받을 수 있음 Checkpoint - REST API # GET /restaurants?coordinate=126.9178889,37.5561619\u0026amp;type=korean 언어별로 별도의 엔드 포인트를 작성하지 말고, Accept-Language 헤더를 요청에 함께 제공하는 것이 더 좋음 GET 요청의 경우 body가 존재하지 않기 때문에 이를 Query Parameter를 이용하여 구현해야 함 DELETE /articles/10, 엔드포인트에 리소스를 명시하는 편이 좋음 Postman #HTTP API 테스트 도구 # CLI curl wuzz GUI Postman Insomnia Postman 사용하기 # GET 요청하기 메시지 조회 Request GET http://3.36.72.17:3000/yuchan/messages 추가적인 파라미터 사용 가능 parameter 형식 설명 필수 여부 roomname 방 이름(문자열) 특정 room만 조회 필수 아님 Response 응답은 다음과 같은 JSON 형식 [ { id: 1, username: \u0026#34;정유찬\u0026#34;, text: \u0026#34;안녕하세요\u0026#34;, roomname: \u0026#34;로비\u0026#34;, date: \u0026#34;2021-04-02 12:00:00\u0026#34;, }, ]; 메시지에서 사용하는 속성 parameter 형식 설명 id 숫자 고유한 아이디 username 문자열 사용자 이름 text 문자열 본문 내용 roomname 문자열 방 이름 date 문자열 작성한 시간 POST 요청하기 POST 요청은 GET 요청과 다르게 본문(body)를 포함하는 경우가 많음 메시지 추가 Request POST http://3.36.72.17:3000/yuchan/messages 요청 본문에는 다음의 내용을 반드시 포함해야 함(JSON 형식) parameter 형식 설명 필수 여부 username 문자열 사용자 이름 필수 text 문자열 본문 내용 필수 roomname 문자열 방 이름 필수 Response 응답은 다음과 같은 JSON 형식 { \u0026#34;id\u0026#34;: 5 } Sprint - Message States 요청 # *https://openweathermap.org/\nToday\u0026rsquo;s takeaway # 어제 개념만 공부를 했을 때는 감이 잘 안 왔는데 오늘 실습을 하고 나니 감을 잡았다. 적절한 메소드를 사용하고, 개별 리소스에 맞는 엔드포인트를 사용(동사x, 명사o) 쿼리 파라미터를 사용한 조건부 조회 가능 ","date":"19 October 2021","permalink":"/posts/bootcamp/bc-9w-2/","section":"Posts","summary":"Today I learned #Algorithm Test 09 나머지의 분배 #\r나머지의 분배 (A + B) % C === ((A % C) + (B % C)) % C (A _ B) % C === ((A _ C) _ (B _ C)) % C (A - B) % C === ((A % C) - (B % C) + C) % C Rest API # REST(Representational State Transfer) API는 웹에서 사용되는 데이터나 자원(Resource)을 HTTP URI로 표현하고, HTTP 프로토콜을 통해 요청과 응답을 정의하는 방식","title":"BC-9w-2 / [HTTP/네트워크] REST API"},{"content":"Today I learned #\r클라이언트-서버 아키텍처(2티어 아키텍처) # Client 리소스를 사용하는 앱 Server 리소스가 존재하는 곳 HTTP 프로토콜(통신 규약) OSI 7 Layers 물리-데이터 링크-네트워크 계층-전송 계층-세션 계층-표현 계층-응용 계층 응용 계층(7) 프로토콜 이름 설명 HTTP 웹에서 HTML, JSON 등의 정보를 주고받는 프로토콜 HTTPS HTTP에서 보안이 강화된 프로토콜 FTP 파일 전송 프로토콜 SMTP 메일을 전송하기 위한 프로토콜 SSH CLI 환경의 원격 컴퓨터에 접속하기 위한 프로토콜 RDP Windows 계열의 원격 컴퓨터에 접속하기 위한 프로토콜 WebSocket 실시간 통신, Push 등을 지원하는 프로토콜 전송 계층(4) 프로토콜 이름 설명 TCP HTTP, FTP 통신의 등의 근간이 되는 인터넷 프로토콜 UDP (양방향의 TCP와는 다르게)단방향으로 작동하는 훨씬 더 단순하고 빠르지만, 신뢰성이 낮은 인터넷 프로토콜 API(Application Programming Interface) Interface 의사소통이 가능하도록 만들어진 접점 HTTP 요청 메소드 요청 적절한 메소드 추가(Create) POST 조회(Read) GET 갱신(Update) PUT or PATCH 삭제(Delete) DELETE 보이지 않는 곳의 브라우저 작동 원리 #URL과 URI # URL(Uniform Resource Locator) 네트워크 상에서 웹 페이지, 이미지, 동영상 등의 파일이 위치한 정보 scheme, hosts, url-path로 구분 URI(Uniform Resource Identifier) URL의 기본 요소에 더해 query, bookmark를 포함 부분 명칭 설명 file://, http://, https:// scheme 통신 프로토콜 127.0.0.1, www.google.com hosts 웹 페이지, 이미지, 동영상 등의 파일이 위치한 웹 서버, 도메인 또는 IP :80, :443, :3000 port 웹 서버에 접속하기 위한 통로 /search, /Users/username/Desktop url-path 웹 서버의 루트 디렉토리로부터 웹 페이지, 이미지, 동영상 등의 파일이 위치까지의 경로 q=JavaScript query 웹 서버에 전달하는 추가 질문 IP와 Port # IP address(Internet Protocol address) localhost, 127.0.0.1 현재 사용 중인 로컬 PC 0.0.0.0, 255.255.255.255 broadcast address, 로컬 네트워크에 접속된 모든 장치와 소통하는 주소 IPv4 4 bytes each 2^32(약 43억)개 IP 주소 표현 IPv6 6 bytes each 2^128개 IP 주소 표현 PORT 포트 번호는 0 ~ 65,535 까지 사용할 수 있음 그 중에서 0 ~ 1024번 까지의 포트 번호는 주요 통신을 위한 규약에 따라 이미 정해져 있음 :22 - SSH\n:80 - HTTP\n:443 - HTTPS 도메인과 DNS # 도메인 웹 브라우저를 통해 특정 사이트에 진입을 할 때, IP 주소를 대신하여 사용하는 주소 터미널에서 도메인 이름을 통해 IP 주소를 확인하는 명령어 nslookup DNS(Domain Name System) 호스트의 도메인 이름을 IP 주소로 변환하거나 반대의 경우를 수행할 수 있도록 개발된 데이터베이스 시스템 Chrome Network Tab # https://www.youtube.com/watch?v=e1gAyQuIFQo HTTP(HyperText Transfer Protocol) #HTTP Messages # 클라이언트와 서버 사이에서 데이터가 교환되는 방식 HTTP messages의 구조 start/status line 요청이나 응답의 상태 HTTP headers 요청을 지정하거나, 메시지에 포함된 본문을 설명하는 헤더의 집합 empty line 헤더와 본문을 구분하는 빈 줄 body 요청과 관련된 데이터나 응답과 관련된 데이터 또는 문서를 포함 요청과 응답의 유형에 따라 선택적으로 사용 HTTP Request # Start line HTTP method 수행할 작업(GET, PUT, POST 등)이나 방식(HEAD or OPTIONS)을 설명 요청 대상(일반적으로 URL이나 URI) 또는 프로토콜, 포트, 도메인의 절대 경로 origin 형식 ?와 쿼리 문자열이 붙는 절대 경로 POST, GET, HEAD, OPTIONS 등의 method와 함께 사용 POST / HTTP/1.1\nGET /background.png HTTP/1.0\nHEAD /test.html?query=alibaba HTTP/1.1\nOPTIONS /anypage.html HTTP/1.0 absolute 형식 완전한 URL 형식으로, 프록시에 연결하는 경우 대부분 GET method와 함께 사용 GET http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1 authority 형식 도메인 이름과 포트 번호로 이루어진 URL의 authority component HTTP 터널을 구축하는 경우, CONNECT와 함께 사용 CONNECT developer.mozilla.org:80 HTTP/1.1 asterisk 형식 OPTIONS 와 함께 별표(*) 하나로 서버 전체를 표현 OPTIONS * HTTP/1.1 HTTP 버전 Headers 헤더 이름(대소문자 구분이 없는 문자열), 콜론( : ), 값을 입력 General headers 메시지 전체에 적용되는 헤더로, body를 통해 전송되는 데이터와는 관련이 없는 헤더 Request headers fetch를 통해 가져올 리소스나 클라이언트 자체에 대한 자세한 정보를 포함하는 헤더 User-Agent, Accept-Type, Accept-Language과 같은 헤더는 요청을 보다 구체화 Referer처럼 컨텍스트를 제공하거나 If-None과 같이 조건에 따라 제약을 추가할 수 있음 Representation headers body에 담긴 리소스의 정보(컨텐츠 길이, MIME 타입 등)를 포함하는 헤더 Body(Optional) GET, HEAD, DELETE, OPTIONS처럼 서버에 리소스를 요청하는 경우에는 본문이 필요하지 않음 POST나 PUT과 같은 일부 요청에서 데이터를 업데이트하기 위해 사용 Single-resource bodies(단일-리소스 본문) 헤더 두 개(Content-Type과 Content-Length)로 정의된 단일 파일로 구성 Multiple-resource bodies(다중-리소스 본문) 여러 파트로 구성된 본문에서는 각 파트마다 다른 정보를 지님 보통 HTML form과 관련 HTTP Responses # Status line 현재 프로토콜의 버전(HTTP/1.1 등) 상태 코드 - 요청의 결과(200, 302, 404 등) 상태 텍스트 - 상태 코드에 대한 설명 HTTP/1.1 404 Not Found. Headers General headers Response headers 위치 또는 서버 자체에 대한 정보(이름, 버전 등)와 같이 응답에 대한 부가적인 정보를 갖는 헤더 Vary, Accept-Ranges와 같이 상태 줄에 넣기에는 공간이 부족했던 추가 정보를 제공 Representation headers Body(Optional) Single-resource bodies(단일-리소스 본문) 길이가 알려진 단일-리소스 본문은 두 개의 헤더(Content-Type, Content-Length)로 정의 길이를 모르는 단일 파일로 구성된 단일-리소스 본문은 Transfer-Encoding이 chunked 로 설정되어 있으며, 파일은 chunk로 나뉘어 인코딩 Multiple-resource bodies(다중-리소스 본문) 서로 다른 정보를 담고 있는 body Stateless(무상태성) # HTTP로 클라이언트와 서버가 통신을 주고 받는 과정에서, HTTP가 클라이언트나 서버의 상태를 확인하지 않음 따라서, 필요에 따라 다른 방법(쿠키-세션, API 등)을 통해 상태를 확인 HTTP의 큰 특징 Advanced Concepts # MDN: MIME Type 브라우저는 어떻게 동작하는가 보이는 곳의 브라우저 작동 원리 #SPA를 만드는 기술: AJAX # AJAX 란? Asynchronous JavaScript And XMLHttpRequest의 약자로, JavaScript, DOM, Fetch, XMLHttpRequest, HTML 등의 다양한 기술을 사용하는 웹 개발 기법 가장 큰 특징은 웹 페이지에 필요한 부분에 필요한 데이터만 비동기적으로 받아와 화면에 그려낼 수 있는 것 AJAX의 핵심 기술 JavaScript와 DOM, 그리고 Fetch Fetch를 사용하면, 페이지를 이동하지 않아도 서버로부터 필요한 데이터를 받아올 수 있음 Fetch는 XHR의 단점을 보완한 새로운 Web API이며, XML보다 가볍고 JavaScript와 호환되는 JSON을 사용 fetch(\u0026#39;http://52.78.213.9:3000/messages\u0026#39;) .then (function(response) { return response.json(); }) .then(function (json) { ... }); AJAX의 장점 서버에서 완성된 HTML을 보내주지 않아도 필요한 데이터를 비동기적으로 가져와 브라우저에서 화면의 일부만 업데이트 하여 렌더링 가능 XHR이 표준화 되면서부터 브라우저에 상관 없이 AJAX를 사용 유저 중심 어플리케이션 개발 AJAX를 사용하면 필요한 일부분만 렌더링하기 때문에 빠르고 더 많은 상호작용이 가능한 어플리케이션을 만들 수 있음 더 작은 대역폭(네트워크 통신 한 번에 보낼 수 있는 데이터의 크기). AJAX에서는 필요한 데이터를 텍스트 형태(JSON, XML 등) 보내면 되기 때문에 비교적 데이터의 크기가 작음 AJAX의 단점 Search Engine Optimization(SEO)에 불리함. AJAX 방식의 웹 어플리케이션의 HTML 파일은 뼈대만 있고 데이터는 없기 때문에 사이트의 정보를 긁어가기 어려움 AJAX에서는 이전 상태를 기억하지 않기 때문에 뒤로가기 등의 기능을 구현하기 위해서는 별도로 History API를 사용해야 함 *지메일이 핫메일을 이긴 진짜 이유 (Ajax가 가져온 유저 인터페이스의 혁신)\nSSR과 CSR # SSR은 서버에서 페이지를 렌더링하고, CSR은 브라우저(클라이언트)에서 페이지를 렌더링함. 브라우저는 사용자가 다른 경로를 요청할 때마다 페이지를 새로고침 하지 않고, 동적으로 라우팅을 관리 SSR(Server Side Rendering) 웹 페이지를 브라우저에서 렌더링하는 대신에, 서버에서 렌더링 브라우저가 서버의 URI로 GET 요청을 보내면, 서버는 정해진 웹 페이지 파일을 브라우저로 전송 그리고 서버의 웹 페이지가 브라우저에 도착하면 완전히 렌더링 브라우저가 다른 경로로 이동할 때마다 서버는 이 작업을 다시 수행 CSR(Client Side Rendering) 브라우저에서 웹 페이지를 렌더링 브라우저의 요청을 서버로 보내면, 웹 페이지의 골격이 될 단일 페이지를 브라우저로 전송 웹 페이지와 함께 전달된 JavaScript 파일은 브라우저에서 웹 페이지를 완전히 렌더링 된 페이지로 바꿈 브라우저가 다른 경로로 이동하면, 브라우저는 브라우저가 요청한 경로에 따라 페이지를 다시 렌더링 이때 보이는 웹 페이지의 파일은 맨 처음 서버로부터 전달받은 웹 페이지 파일과 동일한 파일 Use SSR SEO(Search Engine Optimization) 가 우선순위인 경우 웹 페이지의 첫 화면 렌더링이 빠르게 필요한 경우 웹 페이지가 사용자와 상호작용이 적은 경우 Use CSR SEO 가 우선순위가 아닌 경우 사이트에 풍부한 상호 작용이 있는 경우(빠른 라우팅) 웹 애플리케이션을 제작하는 경우(빠른 동적 렌더링) CORS(Cross-Origin Resource Sharing) # 브라우저의 사용자를 보호하는 브라우저의 자발적인 보안조치 Cross-origin requests is controlled by CORS Today\u0026rsquo;s takeaway # Client, Server, HTTP, API URL, URI IP, Port 도메인, DNS HTTP Messages AJAX SSR, CSR 용어들의 의미를 잘 기억하고, 흐름을 이해하자. HTTP의 가장 큰 특징은 무상태성(Stateless)이다. ","date":"18 October 2021","permalink":"/posts/bootcamp/bc-9w-1/","section":"Posts","summary":"Today I learned #\r클라이언트-서버 아키텍처(2티어 아키텍처) # Client 리소스를 사용하는 앱 Server 리소스가 존재하는 곳 HTTP 프로토콜(통신 규약) OSI 7 Layers 물리-데이터 링크-네트워크 계층-전송 계층-세션 계층-표현 계층-응용 계층 응용 계층(7) 프로토콜 이름 설명 HTTP 웹에서 HTML, JSON 등의 정보를 주고받는 프로토콜 HTTPS HTTP에서 보안이 강화된 프로토콜 FTP 파일 전송 프로토콜 SMTP 메일을 전송하기 위한 프로토콜 SSH CLI 환경의 원격 컴퓨터에 접속하기 위한 프로토콜 RDP Windows 계열의 원격 컴퓨터에 접속하기 위한 프로토콜 WebSocket 실시간 통신, Push 등을 지원하는 프로토콜 전송 계층(4) 프로토콜 이름 설명 TCP HTTP, FTP 통신의 등의 근간이 되는 인터넷 프로토콜 UDP (양방향의 TCP와는 다르게)단방향으로 작동하는 훨씬 더 단순하고 빠르지만, 신뢰성이 낮은 인터넷 프로토콜 API(Application Programming Interface) Interface 의사소통이 가능하도록 만들어진 접점 HTTP 요청 메소드 요청 적절한 메소드 추가(Create) POST 조회(Read) GET 갱신(Update) PUT or PATCH 삭제(Delete) DELETE 보이지 않는 곳의 브라우저 작동 원리 #URL과 URI # URL(Uniform Resource Locator) 네트워크 상에서 웹 페이지, 이미지, 동영상 등의 파일이 위치한 정보 scheme, hosts, url-path로 구분 URI(Uniform Resource Identifier) URL의 기본 요소에 더해 query, bookmark를 포함 부분 명칭 설명 file://, http://, https:// scheme 통신 프로토콜 127.","title":"BC-9w-1 / [HTTP/네트워크] 네트워크-기초"},{"content":" 자료구조를 마무리하고 비동기를 공부했다. Graph는 인접 리스트와 인접 행렬로 다룰 수 있다. Binary Search Tree 보통 중위 탐색으로 가운데 값 잡고, 재귀로 반씩 잘라서 더 잘라지지 않을 때까지 탐색 BFS 가까운 정점부터 탐색 주로 그래프가 굉장히 클 때 사용 Queue 사용 DFS 모든 노드를 완전히 탐색 주로 그래프의 규모가 작고, depth가 얕을 때 사용 재귀 사용 어떤 방법을 사용하면 좋을지 아직 감이 바로 오지 않는다. 내장 메소드들을 직접 함수로 구현해 봤다. 메소드에 대한 이해를 높이는 데 도움이 되었다. 자바스크립트는 non-blocking이라 blocking을 일으키는 작업은 Web API로 미뤄둔다. 이때, 대기시간에 따라 Callback Queue로 가는 순서가 달라져서 실행 위치를 통제하기 위해 Callback이나 Promise, async \u0026amp; await을 사용한다. Promise를 반환하는 함수에. then()과. catch() 사용 async로 Promise를 반환하는 함수로 만들고, 내부에서 await로 각 Promise를 반환하는 함수의 실행 위치를 보장한다. Promise를 반환하는 함수들을 Promise.all()로 배열(dataSet)로써 한 번에 다룰 수 있다. 한 번에 여러 리스트를 다룰 때는 Promise.all 사용 fetch로 url을 받아와서 response.json()으로 객체 데이터(JSON 형태)를 사용 갑자기 잡힌 출국 일정으로 정말 눈코 뜰 새 없이 바쁜 날을 보내고 있고, 또 보낼 예정이다. 학습 내용도 갑자기 어려워 져서 따라가기 조금 힘들다. 하지만 Redux를 시작하기 전까지 혼자서 Redux 예습을 마치기 위해 조금더 노력할 것이다. PS. Weekly Retrospect 중단 # 한 주 동안 공부한 내용을 복습하면서 정리하였는데 기본적으로 내용이 중복되고, 추가 내용을 따로 기록하기 때문에 다시 찾아볼 때 두 개의 게시물을 봐야 하는 단점이 있다. 앞으로는 주말에 복습하면서 새로운 내용을 배울 경우 해당 내용을 공부한 날의 게시물에 직접 추가할 것이다. 알고리즘 문제의 경우에도 마찬가지로 복습 시 새로운 내용은 해당 문제에 직접 추가 기록을 할 것이다. 배운 내용을 일자별로 기록하는 것이 Blog의 목적이고, 내용별로는 WIL에 정리하기 때문에 크게 필요성을 느끼지 못했다. ","date":"17 October 2021","permalink":"/posts/bootcamp/bc-8w-5/","section":"Posts","summary":"자료구조를 마무리하고 비동기를 공부했다.","title":"BC-8w-5 / 8주 차 정리"},{"content":"Today I learned #\rSprint - 비동기 예제 (3) 네트워크 요청 #01_PromiseChaining #function getNewsAndWeather() { const result = {}; return fetch(newsURL) .then((response) =\u0026gt; response.json()) .then((data) =\u0026gt; { result[\u0026#34;news\u0026#34;] = data; return fetch(weatherURL) .then((response) =\u0026gt; response.json()) .then((data) =\u0026gt; { result[\u0026#34;weather\u0026#34;] = data; return result; }); }); } 02_Promise.all #function getNewsAndWeatherAll() { return Promise.all([ fetch(newsURL).then((response) =\u0026gt; response.json()), fetch(weatherURL).then((response) =\u0026gt; response.json()), ]).then((datSet) =\u0026gt; { return { news: dataSet[0], weather: dataSet[1] }; }); } 03_async \u0026amp; await #async function getNewsAndWeatherAsync() { let news = await fetch(newsURL).then((response) =\u0026gt; response.json()); let weather = await fetch(weatherURL).then((response) =\u0026gt; response.json()); return { news: news, weather: weather }; } Today\u0026rsquo;s takeaway # fetch()로 url을 받아와서 response.json()으로 객체 데이터(JSON 형태)를 사용 fetch()는 Promise를 반환하는 함수이다. 어제는 적응되지 않아서 어려웠지만 어제 복습도 하고 오늘 한 번 더 실습을 하면서 사용법을 익혔다. 이제 데이터를 직접 적어 넣는 하드코딩뿐만 아니라, 서버에서 데이터를 받아오는 진짜 코딩도 할 수 있게 되었다. ","date":"15 October 2021","permalink":"/posts/bootcamp/bc-8w-4/","section":"Posts","summary":"Today I learned #\rSprint - 비동기 예제 (3) 네트워크 요청 #01_PromiseChaining #function getNewsAndWeather() { const result = {}; return fetch(newsURL) .","title":"BC-8w-4 / [JS/Node] 비동기-fetch API"},{"content":"","date":null,"permalink":"/tags/javascript/","section":"Tags","summary":"","title":"JavaScript"},{"content":"Today I learned #비동기 #비동기 호출 # Node.js(런타임) non-blocking, asynchronous, single-thread blocking vs non-blocking blocking은 전화 하던일을 멈추고 받아야함(blocking) 요청에 대한 결과가 동시에 일어남(synchronous) non-blocking은 문자 확인 후, 나중에 답잘 가능(non-blocking) 요청에 대한 결과가 동시에 일어나지 않음(asynchronous) 비동기 주요 사례 DOM 이벤트 핸들러 타이머 API 에니매이션 API fetch API AJAX (XHR) JS 작동 원리 # Heap에는 데이터 저장되고, 「Call Stack」에는 함수가 들어옴 블로킹을 일으키는 함수는 「Web API」로 이동해서 대기(보통 함수는 바로 실행 후 나감) 대기시간이 지나면 「Callback Queue」로 이동 「Event Loop」가 Call Stack이 비었을 때, Callback Queue의 함수를 Call Stack에 다시 넣어줌 함수 실행 후 나감 Callback #const printString = (string, cb) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(string); cb(); // callback 함수 실행 }, Math.floor(Math.random() * 1000)); }; // 실행 위치를 보장하기 위해 Callback 함수를 중첩해서 사용 // Callback Hell 발생, 이를 해결하기 위해 Promise 사용 const printAll = () =\u0026gt; { printString(\u0026#34;A\u0026#34;, () =\u0026gt; { printString(\u0026#34;B\u0026#34;, () =\u0026gt; { printString(\u0026#34;C\u0026#34;, () =\u0026gt; {}); }); }); }; printAll(); /* Error Handling */ const somethingGonnaHAppen = (cb) =\u0026gt; { waitingUntilSomethingHappens(); if (isSomethingGood) { cb(null, something); } if (isSomethingBad) { cb(something, null); } }; somethingGonnaHAppen((err, data) =\u0026gt; { if (err) { console.log(\u0026#34;Err\u0026#34;); return; } return data; }); Promise #/* Promise 사용법 */ new Promise((resolve, reject) =\u0026gt; { resolve(); // Promise 이행, with (data) reject(); // Promise 거부, with (err) }); .then() // Promise 이행 시 할 일, with (data) \u0026amp; then의 return 값 .catch() // Promise 거부 시 할 일, with (err) // Promise를 반환하는 함수 const printString = (string) =\u0026gt; { // Promise(로 감싼 함수)를 반환 return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(string); // Promise 이행, with (data) resolve(); }, Math.floor(Math.random() * 1000)); }); }; const printAll = () =\u0026gt; { printString(\u0026#34;A\u0026#34;) .then(() =\u0026gt; { return printString(\u0026#34;B\u0026#34;); }) .then(() =\u0026gt; { return printString(\u0026#34;C\u0026#34;); }); }; printAll(); const gotoDesk = () =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;study\u0026#34;); }, 1000); }); }; const eatLunch = () =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;eat\u0026#34;); }, 1000); }); }; const gotoBed = () =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;sleep\u0026#34;); }, 1000); }); }; /* .then() \u0026amp; .catch() */ gotoDesk() .then((data) =\u0026gt; { console.log(data); return eatLunch(); }) .then((data) =\u0026gt; { console.log(data); return gotoBed(); }) .then((data) =\u0026gt; { console.log(data); }); /* async \u0026amp; await */ const result = async () =\u0026gt; { const one = await gotoDesk(); console.log(one); const two = await eatLunch(); console.log(two); const three = await gotoBed(); console.log(three); }; result(); async를 추가하면 함수가 Promise를 반환 await async function 안에서만 사용 가능 반환된 결과를 변수에 할당 Node.js 모듈 사용법 #Node.js 모듈 사용법 # Node.js 내장 모듈 목록\n// 파일 시스템 모듈을 불러옵니다 const fs = require(\u0026#34;fs\u0026#34;); import fs from \u0026#34;fs\u0026#34;; // DNS 모듈을 불러옵니다 const dns = require(\u0026#34;dns\u0026#34;); import dns from \u0026#34;dns\u0026#34;; *require()은 선언 위치가 상관없고, import는 최상단에 위치해야 함\nfs.readFile(path[, options], callback) # 비동기적으로 파일 내용 전체를 읽음 Sprint - 비동기 예제 (2) 파일 읽기 #01_CallBack #const fs = require(\u0026#34;fs\u0026#34;); const getDataFromFile = (filePath, callback) =\u0026gt; { fs.readFile(filePath, \u0026#34;utf8\u0026#34;, (err, data) =\u0026gt; { if (err) { callback(err, null); } else { callback(null, data); } }); }; getDataFromFile(\u0026#34;README.md\u0026#34;, (err, data) =\u0026gt; console.log(data)); 02_Promise #const fs = require(\u0026#34;fs\u0026#34;); // Promise를 반환하는 함수 const getDataFromFilePromise = (filePath) =\u0026gt; { // Promise(로 감싼 함수)를 반환 return new Promise((resolve, reject) =\u0026gt; { fs.readFile(filePath, \u0026#34;utf8\u0026#34;, (err, data) =\u0026gt; { if (err) { reject(err); } else { resolve(data); } }); }); }; getDataFromFilePromise(\u0026#34;README.md\u0026#34;).then((data) =\u0026gt; console.log(data)); 03_PromiseChancing #const path = require(\u0026#34;path\u0026#34;); const { getDataFromFilePromise } = require(\u0026#34;./02_promiseConstructor\u0026#34;); // __dirname은 ./와 같은 일 const user1Path = path.join(__dirname, \u0026#34;files/user1.json\u0026#34;); const user2Path = path.join(__dirname, \u0026#34;files/user2.json\u0026#34;); const readAllUsersChaining = () =\u0026gt; { /* 1 */ return getDataFromFilePromise(user1Path).then((user1Data) =\u0026gt; { return ( getDataFromFilePromise(user2Path) // `[${JSON.parse(user1Data)}, ${JSON.parse(user2Data)}]` // 는 \u0026#34;[[object Object], [object Object]]\u0026#34; .then((user2Data) =\u0026gt; `[${user1Data}, ${user2Data}]`) .then((text) =\u0026gt; JSON.parse(text)) ); }); /* 2 */ return getDataFromFilePromise(user1Path) .then((user1Data) =\u0026gt; { const user1Object = JSON.parse(user1Data); return user1Object; }) .then((user1Object) =\u0026gt; { const resultArr = []; resultArr.push(user1Object); return getDataFromFilePromise(user2Path).then((user2Data) =\u0026gt; { const user2Object = JSON.parse(user2Data); resultArr.push(user2Object); return resultArr; }); }); }; readAllUsersChaining(); 04_Promise.all #const path = require(\u0026#34;path\u0026#34;); const { getDataFromFilePromise } = require(\u0026#34;./02_promiseConstructor\u0026#34;); const user1Path = path.join(__dirname, \u0026#34;files/user1.json\u0026#34;); const user2Path = path.join(__dirname, \u0026#34;files/user2.json\u0026#34;); const readAllUsers = () =\u0026gt; { let promise1 = getDataFromFilePromise(user1Path); let promise2 = getDataFromFilePromise(user2Path); return Promise.all([promise1, promise2]) .then((dataSet) =\u0026gt; `[${dataSet[0]}, ${dataSet[1]}]`) .then((text) =\u0026gt; JSON.parse(text)); }; readAllUsers(); 05_async \u0026amp; await #const path = require(\u0026#34;path\u0026#34;); const { getDataFromFilePromise } = require(\u0026#34;./02_promiseConstructor\u0026#34;); const user1Path = path.join(__dirname, \u0026#34;files/user1.json\u0026#34;); const user2Path = path.join(__dirname, \u0026#34;files/user2.json\u0026#34;); const readAllUsersAsyncAwait = async () =\u0026gt; { let promise1 = await getDataFromFilePromise(user1Path); let promise2 = await getDataFromFilePromise(user2Path); /* 1 */ const text = `[${promise1}, ${promise2}]`; return JSON.parse(text); /* 2 */ const result = []; const obj1 = JSON.parse(promise1); const obj2 = JSON.parse(promise2); result.push(obj1, obj2); return result; }; readAllUsersAsyncAwait(); Today\u0026rsquo;s takeaway # 하루 종일 풀어도 토이 프로젝트를 풀 수 없었다. Call Stack -\u0026gt; Web AIP -\u0026gt; Callback Queue -event loop-\u0026gt; Call Stack 비동기로 처리되는 블로킹 함수의 실행 위치를 보장하기 위해 Callback, Promise(.then() \u0026amp; .catch(), async \u0026amp; await) 사용 Promise가 fulfilled되면 resole()의 인수를 return, rejected되면 reject()의 인수를 반환 Promise 생성자로 Promise(로 감싼 함수)를 생성 Promise에 .then()과 .catch()를 연결해서 실행 위치 보장 Promise 다음의 .then()의 인수는 resolve()의 인수고, .then() 다음의 인수는 .then()의 return 값 async 키워드로 Promise를 반환하는 함수로 만들고, await 키워드로 각 Promise들의 실행 위치 보장 Promise를 반환하는 함수들을 Promise.all()로 배열(dataSet)로써 한 번에 다룰 수 있다. ","date":"14 October 2021","permalink":"/posts/bootcamp/bc-8w-3/","section":"Posts","summary":"Today I learned #비동기 #비동기 호출 # Node.","title":"BC-8w-3 / [JS/Node] 비동기, 모듈"},{"content":"Today I learned #\rSprint - Underbar #Bare minimum #_.slice = function (arr, start, end) { let _start = start || 0, _end = end; if (start \u0026lt; 0) _start = Math.max(0, arr.length + start); if (end \u0026lt; 0) _end = Math.max(0, arr.length + end); if (_end === undefined || _end \u0026gt; arr.length) _end = arr.length; let result = []; for (let i = _start; i \u0026lt; _end; i++) { result.push(arr[i]); } return result; _.each = function (collection, iteratee) { if (Array.isArray(collection)) { for (let i = 0; i \u0026lt; collection.length; i++) { iteratee(collection[i], i, collection); } } else if (typeof collection === \u0026#34;object\u0026#34;) { for (let key in collection) { iteratee(collection[key], key, collection); } } }; _.map = function (arr, iteratee) { let result = []; _.each(arr, function (item) { result.push(iteratee(item)); }); return result; }; _.reduce = function (arr, iteratee, initVal) { let acc = initVal; _.each(arr, function (item, idx, src) { if (initVal === undefined \u0026amp;\u0026amp; idx === 0) { acc = item; } else { acc = iteratee(acc, item, idx, src); } }); return acc; }; _.filter = function (arr, test) { let result = []; _.each(arr, function (item) { if (test(item)) { result.push(item); } }); return result; }; _.indexOf = function (arr, target) { let result = -1; _.each(arr, function (item, index) { if (item === target \u0026amp;\u0026amp; result === -1) { result = index; } }); return result; }; _.uniq = function (arr) { let result = []; _.each(arr, function (item) { if (_.indexOf(result, item) === -1) { result.push(item); } }); return result; }; Advanced #_.once = function (func) { let result; let alreadyCalled = false; // ...arg -\u0026gt; arg === [...] return function (...args) { if (!alreadyCalled) { alreadyCalled = true; result = func(...args); } return result; }; }; _.includes = function (arr, target) { let result = false; _.each(arr, function (item) { if (item === target) { result = true; } }); return result; }; _.every = function (arr, iteratee) { if (iteratee === undefined) { iteratee = _.identity; } for (let i = 0; i \u0026lt; arr.length; i++) { if (!iteratee(arr[i])) { return false; } } return true; }; _.defaults = function (base, ...rest) { _.each(rest, function (item) { _.each(item, function (val, key) { if (base[key] === undefined) { base[key] = val; } }); }); return base; }; _.intersection = function (base, ...rest) { let result = []; _.each(base, function (bItem) { const intersected = _.every(rest, function (arr) { return _.includes(arr, bItem); }); if (intersected) { result.push(bItem); } }); return result; }; Nightmare #_.memoize = function (func) { const cache = {}; return function (...args) { const problemName = JSON.stringify(args); if (!cache.hasOwnProperty(problemName)) { cache[problemName] = func(...args); } return cache[problemName]; }; }; Today\u0026rsquo;s takeaway # 내장 메소드들이 어떤 원리로 작동하는지 직접 함수로 만들어 봤다. 단순히 외워서 사용할 때보다 훨씬 높은 이해도를 가질 수 있었다. 특히 전개 구문(\u0026hellip;)에 대한 이해도가 많이 늘었다. ","date":"13 October 2021","permalink":"/posts/bootcamp/bc-8w-2/","section":"Posts","summary":"Today I learned #\rSprint - Underbar #Bare minimum #_.","title":"BC-8w-2 / [JS/Node] 중급"},{"content":"Today I learned #\rGraph / Tree / BST #Graph # 여러개의 점들이 서로 복잡하게 연결되어 있는 관계를 표현한 자료구조\n그래프에서는 하나의 점은 정점(vertex), 하나의 선은 간선(edge)\n그래프의 실사용 예제\n비가중치 그래프(추가 정보 x) 정점: 서울, 대전, 부산 간선: 서울—대전, 대전—부산, 부산—서울 let isConnected = { seoul: { busan: true, daejeon: true, }, daejeon: { seoul: true, busan: true, }, busan: { seoul: true, daejeon: true, }, }; console.log(isConnected.seoul.daejeon); // true console.log(isConnected.daejeon.busan); // true 가중치 그래프(추가 정보 o) 정점: 서울, 대전, 부산 간선: 서울—140km—대전, 대전—200km—부산, 부산—325km—서울 용어\n무방향그래프(undirected graph) \u0026lt;-\u0026gt; 단방향(directed) 그래프 진입차수(in-degree) / 진출차수(out-degree) 인접(adjacency) 두 정점간에 간선이 직접 이어져 있다면 이 두 정점은 인접한 정점 자기 루프(self loop) 정점에서 진출하는 간선이 곧바로 자기 자신에게 진입하는 경우 사이클(cycle) 한 정점에서 출발하여 다시 해당 정점으로 돌아갈 수 있다면 사이클이 있다고 표현 그래프의 표현 방식\n인접 행렬\n서로 다른 정점들이 인접한 상태인지를 표시한 행렬으로 2차원 배열의 형태로 표현 from \\ to A B C A 0 0 1 B 1 0 1 C 1 0 0 *가중치 그래프라면 1 대신 다른 값\nA의 진출차수는 1개 입니다: A —\u0026gt; C [0][2] === 1 B의 진출차수는 2개 입니다: B —\u0026gt; A, B —\u0026gt; C [1][0] === 1 [1][2] === 1 C의 진출차수는 1개입니다: C —\u0026gt; A [2][0] === 1 인접 행렬은 언제 사용할까? 두 정점 사이에 관계가 있는지, 없는지 확인하기에 용이 가장 빠른 경로(shortest path)를 찾고자 할 때 주로 사용 // directed graph (방향 그래프) // unweighted (비가중치) // adjacency matrix (인접 행렬) class GraphWithAdjacencyMatrix { constructor() { this.matrix = []; } addVertex() { const currentLength = this.matrix.length; // 이미있는 행에 열(0) 추가 for (let i = 0; i \u0026lt; currentLength; i++) { this.matrix[i].push(0); } // 새로운 행 추가 this.matrix.push(new Array(currentLength + 1).fill(0)); } contains(vertex) { if (this.matrix[vertex]) { return true; } return false; /* ref return !!this.matrix[vertex] */ } addEdge(from, to) { const currentLength = this.matrix.length; if (from === undefined || to === undefined) { console.log(\u0026#34;2개의 인자가 있어야 합니다.\u0026#34;); return; } // 간선을 추가할 수 없는 상황에서는 추가 x // 인덱스와 크기라서 + 1 if ( from + 1 \u0026gt; currentLength || to + 1 \u0026gt; currentLength || from \u0026lt; 0 || to \u0026lt; 0 ) { console.log(\u0026#34;범위가 매트릭스 밖에 있습니다.\u0026#34;); return; } this.matrix[from][to] = 1; } hasEdge(from, to) { return this.matrix[from][to] === 1; } removeEdge(from, to) { const currentLength = this.matrix.length; if (from === undefined || to === undefined) { console.log(\u0026#34;2개의 인자가 있어야 합니다.\u0026#34;); return; } // 간선을 제거할 수 없는 상황에서는 제거 x if ( from + 1 \u0026gt; currentLength || to + 1 \u0026gt; currentLength || from \u0026lt; 0 || to \u0026lt; 0 ) { console.log(\u0026#34;범위가 매트릭스 밖에 있습니다.\u0026#34;); return; } this.matrix[from][to] = 0; } } 인접 리스트\n각 정점이 어떤 정점과 인접한지를 리스트의 형태로 표현(보통은 순서 중요 x) 인접 리스트는 언제 사용할까? 메모리를 효율적으로 사용하고 싶을 때 사용 // undirected graph (무방향 그래프) // adjacency list (인접 리스트) class GraphWithAdjacencyList { constructor() { this.vertices = {}; } addVertex(vertex) { // 넘겨받은 인자(정점)은 키가 되며, 빈 배열을 값으로 할당 // 이미 존재하는 정점이라면, 덮어 씌워지지 않아야 함 this.vertices[vertex] = this.vertices[vertex] || []; } contains(vertex) { return !!this.vertices[vertex]; } addEdge(fromVertex, toVertex) { // - fromVertex의 인접 리스트에 toVertex를 추가 // - toVertex의 인접 리스트에 fromVertex를 추가 // 넘겨받은 2개의 정점 모두 존재하는 정점이어야 함 if (!this.contains(fromVertex) || !this.contains(toVertex)) { return; } if (!this.hasEdge(fromVertex, toVertex)) { this.vertices[fromVertex].push(toVertex); this.vertices[toVertex].push(fromVertex); } } hasEdge(fromVertex, toVertex) { if (!this.contains(fromVertex)) { return false; } return !!this.vertices[fromVertex].includes(toVertex); } removeEdge(fromVertex, toVertex) { // 인자로 넘겨받은 두 정점이 모두 존재한다면 // - fromVertex의 인접 리스트에 있는 toVertex를 삭제 // - toVertex의 인접 리스트에 있는 fromVertex를 삭제 if (!this.contains(fromVertex) || !this.contains(toVertex)) { return; } if (this.hasEdge(fromVertex, toVertex)) { const index = this.vertices[fromVertex].indexOf(toVertex); this.vertices[fromVertex].splice(index, 1); } if (this.hasEdge(toVertex, fromVertex)) { const index = this.vertices[toVertex].indexOf(fromVertex); this.vertices[toVertex].splice(index, 1); } } removeVertex(vertex) { // 인자로 넘겨받은 정점(A)이 존재한다면 // - 이 정점(A)을 삭제 // - 다른 모든 정점들의 리스트를 순회하며 넘겨받은 정점(A)과 이어져 있는 간선을 제거 if (this.contains(vertex)) { while (this.vertices[vertex].length \u0026gt; 0) { this.removeEdge(this.vertices[vertex][0], vertex); } delete this.vertices[vertex]; } } } Tree # 데이터가 바로 아래에 있는 하나 이상의 데이터에 단방향으로 연결된 계층적 자료구조 하나의 데이터 뒤에 여러 개의 데이터가 존재할 수 있는 비선형 구조 루트(Root) 라는 하나의 꼭짓점 데이터를 시작으로 여러 개의 데이터를 간선(edge)으로 연결 각 데이터를 노드(Node)라고 하며, 두 개의 노드가 상하계층으로 연결되면 부모/자식 관계를 가짐 자식이 없는 노드는 리프 노드(leaf Node) 루트로부터 하위 계층의 특정 노드까지의 깊이(depth)로 표현 같은 깊이를 가지고 있는 노드를 묶어서 레벨(level)로 표현 리프 노드를 기준으로 루트까지의 높이(height)를 표현 트리 구조를 갖춘 작은 트리는 서브 트리 class Tree { constructor(value) { // constructor로 만든 객체는 트리의 Node this.value = value; this.children = []; } insertNode(value) { // 서브 트리 삽입 const childNode = new Tree(value); this.children.push(childNode); } contains(value) { if (this.value === value) { return true; } // 값을 찾을 때까지 children 배열을 순회하며 childNode를 탐색 else if (this.children.length !== 0) { for (let item of this.children) { // 반복 내에서 바로 재귀하면 // 반복 요소에서 못찾으면 false를 리턴 해버림 if (item.contains(value)) { // 반복 요소에서 true면 true 리턴 return true; } } } // 전부 탐색했음에도 불구하고 찾지 못했다면 false를 반환 return false; } } Binary Search Tree # 이진트리(Binary tree) 이진 트리 설명 정 이진 트리(Full binary tree 각 노드가 0 개 혹은 2 개의 자식 노드를 가짐 완전 이진 트리(Complete binary tree) 마지막 레벨을 제외한 모든 노드가 가득 차 있어야 하고, 마지막 레벨의 노드는 전부 차 있지 않아도 되지만 왼쪽이 채워져야 함 포화 이진 트리(Perfect binary tree) 정 이진 트리이면서 완전 이진 트리인 경우. 모든 리프 노드의 레벨이 동일하고, 모든 레벨이 가득 채워져 있는 트리 이진 탐색 트리(Binary Search Tree) 모든 왼쪽 자식의 값이 루트나 부모보다 작고, 모든 오른쪽 자식의 값이 루트나 부모보다 큰 값을 가짐 균형 잡힌 트리가 아닐 때, 입력되는 값의 순서에 따라 한쪽으로 노드들이 몰리게 될 수 있음 균형이 잡히지 않은 트리는 탐색하는 데 시간이 더 걸리는 경우도 있기 때문에 해결해야함 class BinarySearchTree { constructor(value) { this.value = value; // 자식노드 초기값 this.left = null; this.right = null; } insert(value) { // 작으면서 if (value \u0026lt; this.value) { // 비었을 때, 서브 트리 삽입 if (this.left === null) { this.left = new BinarySearchTree(value) // 안비면 아래로 내려감(재귀) } else { this.left.insert(value) } } // 크면서 if (value \u0026gt; this.value) { // 비었을 때, 서브 트리 삽입 if (this.right === null) { this.right = new BinarySearchTree(value) // 안비면 아래로 내려감(재귀) } else { this.right.insert(value) } } //그것도 아니라면, 입력값이 트리에 들어 있는 경우 return; } contains(value) { if (this.value === value) { return true; } if (value \u0026lt; this.value) { /* ref return !!(this.left \u0026amp;\u0026amp; this.left.contains(value)); */ if (this.left === null) { return false } else { return this.left.contains(value) } } if (value \u0026gt; this.value) { /* ref return !!(this.right \u0026amp;\u0026amp; this.right.contains(value)); */ if (this.right === null) { return false } else { return this.right.contains(value) } } return false } // 전위 순회 preorder(callback) { callback(this.value); if (this.left) { this.left.preorder(callback) }; if (this.right) { this.right.preorder(callback) }; } // 중위 순회 inorder(callback) { if (this.left) { this.left.inorder(callback) }; callback(this.value); if (this.right) { this.right.inorder(callback) }; } // 후위 순회 postorder(callback) { if (this.left) { this.left.postorder(callback) }; if (this.right) { this.right.postorder(callback) }; callback(this.value); } } BFS / DFS # 그래프의 탐색 하나의 정점에서 시작하여 그래프의 모든 정점들을 한 번씩 방문(탐색) 하는 것이 목적 BFS(Breadth-First Search) 가까운 정점부터 탐색 더는 탐색할 정점이 없을 때, 그다음 떨어져 있는 정점을 순서대로 방문 주로 두 정점 사이의 최단 경로를 찾을 때 사용 주로 그래프가 굉장히 클 때 사용 DFS(Depth-First Search) 하나의 경로를 끝까지 탐색한 후, 도착이 아니라면 다음 경로로 넘어가 탐색 BFS보다 탐색 시간은 조금 오래 걸릴지라도 모든 노드를 완전히 탐색 주로 그래프의 규모가 작고, depth가 얕을 때 사용 Graph / Tree / BST 문제 #10 인접 행렬 생성 #function func(edges) { // 마지막 vertex의 index + 1 const matrixSize = Math.max(...edges.flat().filter((item) =\u0026gt; typeof item === \u0026#34;number\u0026#34;)) + 1; const matrix = []; // matrix를 0의 배열로 채우기 for (let i = 0; i \u0026lt; matrixSize; i++) { matrix.push(new Array(matrixSize).fill(0)); } // edge있으면 1로 바꿔주기 for (let edge of edges) { matrix[edge[0]][edge[1]] = 1; if (edge[2] === \u0026#34;undirected\u0026#34;) { matrix[edge[1]][edge[0]] = 1; } } return matrix; } 11 인접 행열 길찾기 #function func(matrix, from, to) { // visit한 vertex를 저장해서 최적화 const visitedVertex = [from]; const innerGetDirection = (matrix, from, to) =\u0026gt; { if (matrix[from][to] === 1) { return true; } for (let i = 0; i \u0026lt; matrix[from].length; i++) { // 길이 있고(1), 반문한 정점이 아닐 때, if (matrix[from][i] === 1 \u0026amp;\u0026amp; !visitedVertex.includes(i)) { // 방문 표시 visitedVertex.push(i); // 바로 함수 선언하면 중간에 false가 반환되어버림 if (innerGetDirection(matrix, i, to)) { return true; } } } return false; }; return innerGetDirection(matrix, from, to); } 12 [BFS / DFS] 연결된 정점 그룹!! #function func(edges) { const matrixSize = Math.max(...edges.flat()) + 1; const adjList = {}; for (let i = 0; i \u0026lt; matrixSize; i++) { adjList[i] = []; } for (edge of edges) { adjList[edge[0]].push(edge[1]); adjList[edge[1]].push(edge[0]); } /* 여기까지 인접 리스트 작성 */ const visitedVertex = {}; let count = 0; // 해당 vertex의 모든 인접 vertex를 방문하는 함수 const bfs = (adjList, vertex) =\u0026gt; { // 해당 vertex 방문(초기값) visitedVertex[vertex] = true; // 반복문 전에 큐를 선언하면서 vertex 넣음(초기값) const queue = [vertex]; // 큐가 빌 때까지 while (queue.length \u0026gt; 0) { // curVertex는 큐의 첫 번째 요소에서 빼냄 const curVertex = queue.shift(); // curVertex의 인접 vertex의 개수만큼 반복 for (let i = 0; i \u0026lt; adjList[curVertex].length; i++) { // curVertex의 인접 vertex에 방문한 적이 없을 때, if (!visitedVertex[adjList[curVertex][i]]) { // 큐에 curVertex의 인접 vertex 저장 queue.push(adjList[curVertex][i]); // 방문 정보에에 curVertex의 인접 vertex 저장 visitedVertex[adjList[curVertex][i]] = true; } } } }; // 해당 vertex의 모든 인접 vertex를 방문하는 함수 const dfs = (adjList, vertex) =\u0026gt; { // 해당 vertex 방문(초기값) visitedVertex[vertex] = true; // 해당 vertex의 인접 vertex의 개수만큼 반복 for (let i = 0; i \u0026lt; adjList[vertex].length; i++) { // vertex의 인접 vertex에 방문한 적이 없을 때, if (!visitedVertex[adjList[vertex][i]]) { // 인접 vertex를 방문하는 재귀 반복 dfs(adjList, adjList[vertex][i]); } } }; for (let i = 0; i \u0026lt; matrixSize; i++) { // 해당 vertex를 방문한 적이 없을 때, if (!visitedVertex[i]) { // 해당 vertex의 모든 인접 vertex를 방문하는 함수 dfs(adjList, i); count++; } } return count; } 13 [DFS] 바코드 #function func(len) { const isValid = (str) =\u0026gt; { // 순서데로 추가하면 앞만 검사 // 1 1 // 1|2 2|1 // 1|21 1|21 // 1|2|11 -\u0026gt; true 1|1|21 -\u0026gt; false // 따라서 뒤집어주면 새로 추가되는 숫자를 검사 const reversedStr = str.split(\u0026#34;\u0026#34;).reverse().join(\u0026#34;\u0026#34;); for (let i = 1; i \u0026lt;= str.length / 2; i++) { if (reversedStr.slice(0, i) === reversedStr.slice(i, i * 2)) { return false; } } return true; }; const code = \u0026#34;123\u0026#34;; const makeBarcode = (str) =\u0026gt; { // len과 str의 길이가 같을 때 재귀 반복 종료 if (str.length === len) return str; for (let i = 0; i \u0026lt; 3; i++) { // 작은 수 순서데로 검사 if (isValid(str + code[i])) { // 재귀 반복(유효성 검사를 통과하는 code를 더해서 str에 넣어줌) const validCode = makeBarcode(str + code[i]); // 바로 리턴하면 validCode 없을 때, // 재귀가 아니라 undefined가 바로 리턴됨 if (validCode) { // 변수를 쓰는 이유는 재연산을 안하기 위해!! return validCode; } } } }; return makeBarcode(\u0026#34;\u0026#34;); } Today\u0026rsquo;s takeaway # 같은 값을 두 번 이상 사용할 때 변수 사용(최적화, 유지 보수 용이, 재사용성) 추가 정보를 따로 저장해서 조건으로 사용 BFS는 queue 사용, DFS는 재귀 사용 그래프 인접 리스트 객체/배열 안의 배열 인접 행렬 2차원 배열 vertex를 삭제할 때는 안쓰는게 좋다. 이때까지와는 비교가 안되게 어려웠다. 철저한 복습이 필요하다. 자료구조를 눈으로 보고 익힐 수 있는 시각자료 Data Structure Visualizations Visualgo ","date":"12 October 2021","permalink":"/posts/bootcamp/bc-8w-1/","section":"Posts","summary":"Today I learned #\rGraph / Tree / BST #Graph # 여러개의 점들이 서로 복잡하게 연결되어 있는 관계를 표현한 자료구조","title":"BC-8w-1 / [자료구조/알고리즘] Graph, Tree, BST"},{"content":"7주 차 정리 # 이번 주의 핵심은 데이터를 다루는 방법이다. 객체 지향 프로그래밍 객체 안에 데이터(속성)와 기능(메소드)를 넣어서 한곳에서 처리하는 방식이다. 재사용성을 극대화하여 유지 보수에 도움이 된다. 재귀 자신 스스로를 호출(재귀 반복) 하는 return 값을 지닌다. 종료 조건을 만족할 때, 다른 return 값을 지녀 재귀를 종료한다. 반복 조건이 있을 때는 반복 종료 조건과 반복 조건을 만족하지 못할 때 반환할 return 값을 지닌다. 문제를 잘게 쪼개서 생각해야 한다. 자료구조-Stack, Queue Stack은 쌓이는 거고, Queue는 줄 서는 거다. 제일 쉽게는 배열에 쌓인다고 생각하면 된다. 클래스를 이용해서 보편적으로 만들 수 있다. ","date":"10 October 2021","permalink":"/posts/bootcamp/bc-7w-5/","section":"Posts","summary":"7주 차 정리 # 이번 주의 핵심은 데이터를 다루는 방법이다.","title":"BC-7w-5 / 7주 차 정리"},{"content":"Today I learned #\rStack / Queue #Stack # LIFO(Last In First Out) 혹은 FILO(First In Last Out) 브라우저의 뒤로 가기, 앞으로 가기 기능을 구현할 때 자료구조 Stack 활용 새로운 페이지로 접속할 때, 현재 페이지를 Prev Stack에 보관 뒤로 가기 버튼을 눌러 이전 페이지로 돌아갈 때에는, 현재 페이지를 Next Stack에 보관하고 Prev Stack에 가장 나중에 보관된 페이지를 현재 페이지로 가져옴 앞으로 가기 버튼을 눌러 앞서 방문한 페이지로 이동을 원할 때에는, Next Stack의 가장 마지막으로 보관된 페이지를 가져옴 마지막으로 현재 페이지를 Prev Stack에 보관 class Stack { constructor() { this.storage = {}; this.top = 0; // 스택의 가장 상단을 가리키는 포인터 변수를 초기화 } size() { return this.top; } // 스택에 데이터를 추가 할 수 있어야 함 push(element) { this.storage[this.top] = element; this.top += 1; } // 가장 나중에 추가된 데이터가 가장 먼저 추출되어야 함 pop() { // 빈 스택에 pop 연산을 적용해도 에러가 발생하지 않아야 함 if (this.top \u0026lt;= 0) { return; } const result = this.storage[this.top - 1]; delete this.storage[this.top - 1]; this.top -= 1; return result; } } Queue # FIFO(First In First Out) 혹은 LILO(Last In Last Out) 컴퓨터와 연결된 프린터에서 여러 문서를 순서대로 인쇄할 때 자료구조 Queue 활용 우리가 문서를 작성하고 출력 버튼을 누르면 해당 문서는 인쇄 작업 (임시 기억 장치의) Queue에 들어갑니다. 프린터는 인쇄 작업 Queue에 들어온 문서를 순서대로 인쇄합니다. 버퍼(buffer) 컴퓨터 장치들 사이에서 데이터를 주고 받을 때, 각 장치 사이에 존재하는 속도의 차이나 시간 차이를 극복하기 위해 임시 기억 장치의 자료구조로 Queue를 사용 일반적으로 프린터는 속도가 느림 CPU는 프린터와 비교하여, 데이터를 처리하는 속도가 빠름 CPU는 빠른 속도로 인쇄에 필요한 데이터를 만든 다음, 인쇄 작업 Queue에 저장하고 다른 작업을 수행 프린터는 인쇄 작업 Queue에서 데이터를 받아 일정한 속도로 인쇄 class Queue { constructor() { this.storage = {}; this.front = 0; this.rear = 0; } size() { return this.rear - this.front; } // 큐에 데이터를 추가 할 수 있어야 함 enqueue(element) { this.storage[this.rear] = element; this.rear += 1; } // 가장 먼저 추가된 데이터가 가장 먼저 추출되어야 함 dequeue() { // 빈 큐에 dequeue 연산을 적용해도 에러가 발생하지 않아야 함 if (this.rear - this.front \u0026lt;= 0) { return; } const result = this.storage[this.front]; delete this.storage[this.front]; this.front += 1; return result; } } Stack / Queue 문제 #03 앞으로 가기, 뒤로 가기 #function func(actions, start) { const prevPage = []; const nextPage = []; let curPage = start; for (const action of actions) { if (typeof action === \u0026#34;string\u0026#34;) { prevPage.push(curPage); curPage = action; nextPage.splice(0); } else if (action === -1 \u0026amp;\u0026amp; prevPage.length \u0026gt; 0) { nextPage.push(curPage); curPage = prevPage.pop(); } else if (action === 1 \u0026amp;\u0026amp; nextPage.length \u0026gt; 0) { prevPage.push(curPage); curPage = nextPage.pop(); } } return [prevPage, curPage, nextPage]; } 04 동시 추출 #function func(boxes) { let result = []; // 반복 조건 while (boxes.length \u0026gt; 0) { // 더 큰 수가 뒤에 있으면 그 수의 인덱스 정보 저장 let nextPivotIndex = boxes.findIndex((item) =\u0026gt; boxes[0] \u0026lt; item); // 더 큰 수가 뒤에 없으면 한번에 나감 if (nextPivotIndex === -1) { result.push(boxes.length); break; } // 한번에 나가는 개수를 result에 저장하면서 인덱스 전까지 삭제 result.push(boxes.splice(0, nextPivotIndex).length); } // 최댓값 리턴 return Math.max(...result); } 05 버퍼 #function queuePrinter(bufferSize, capacities, documents) { // 버퍼 공간 0으로 채움!!! const listOfWork = new Array(bufferSize).fill(0); let sec = 0; // 반복 전에 처음 요소 넣어줌(밖에서 선언해야 값이 저장되기 때문) let curDocument = documents.shift(); listOfWork.shift(); listOfWork.push(curDocument); sec++; let listOfWorkSize = curDocument; while (listOfWorkSize \u0026gt; 0) { /* 0으로 이미 차있는 공간에 제일 앞의 0을 지우고 제일 뒤에 조건에 맞으면 숫자 넣고, 안 맞으면 0을 넣어서 길이 유지 */ // 버퍼 공간 제일 앞의 수를 제거하면서 사이즈도 줄여줌 listOfWorkSize -= listOfWork.shift(); // 현제 문서는 문서 리스트의 제일 앞 curDocument = documents.shift(); if (listOfWorkSize + curDocument \u0026lt;= capacities) { listOfWork.push(curDocument); listOfWorkSize += curDocument; } else { listOfWork.push(0); documents.unshift(curDocument); } sec++; } return sec; } Today\u0026rsquo;s takeaway # Stack과 Queue는 나오는 순서가 다르다. 주로 클래스로 객체를 배열처럼 사용한다. 위치 변수를 객체의 key로 value를 넣고, 위치 변수의 값을 변화시킨다. 길이가 정해진 경우, 0이나 false로 배열을 채워넣고 다른 수나 true로 변화시키면서 정보를 다룬다. ","date":"8 October 2021","permalink":"/posts/bootcamp/bc-7w-4/","section":"Posts","summary":"Today I learned #\rStack / Queue #Stack # LIFO(Last In First Out) 혹은 FILO(First In Last Out) 브라우저의 뒤로 가기, 앞으로 가기 기능을 구현할 때 자료구조 Stack 활용 새로운 페이지로 접속할 때, 현재 페이지를 Prev Stack에 보관 뒤로 가기 버튼을 눌러 이전 페이지로 돌아갈 때에는, 현재 페이지를 Next Stack에 보관하고 Prev Stack에 가장 나중에 보관된 페이지를 현재 페이지로 가져옴 앞으로 가기 버튼을 눌러 앞서 방문한 페이지로 이동을 원할 때에는, Next Stack의 가장 마지막으로 보관된 페이지를 가져옴 마지막으로 현재 페이지를 Prev Stack에 보관 class Stack { constructor() { this.","title":"BC-7w-4 / [자료구조/알고리즘] Stack, Queue"},{"content":"Today I learned #\rBig-O notation # O(1) (Constant) 입력 데이터의 크기에 상관없이 언제나 일정한 시간이 걸리는 알고리즘을 나타낸다. 데이터가 얼마나 증가하든 성능에 영향을 거의 미치지 않는다. O(log₂ n) (Logarithmic) 입력 데이터의 크기가 커질 수록 처리 시간이 로그(log: 지수 함수의 역함수) 만큼 짧아지는 알고리즘이다. 예를 들어 데이터가 10배가 되면, 처리 시간은 2배가 된다. 이진 탐색이 대표적이며, 재귀가 순기능으로 이루어지는 경우도 해당된다. O(n) (Linear) 입력 데이터의 크기에 비례해 처리 시간이 증가하는 알고리즘이다. 예를 들어 데이터가 10배가 되면, 처리 시간도 10배가 된다. 선형 탐색 알고리즘이 대표적이다. O(n log₂ n) (Linear-Logarithmic) 데이터가 많아질수록 처리시간이 로그(log) 배 만큼 더 늘어나는 알고리즘이다. 예를 들어 데이터가 10배가 되면, 처리 시간은 약 20배가 된다. 정렬 알고리즘 Merge sort, Quick sort의 평균 시간 복잡도이다. O(n²) (quadratic) 데이터가 많아질수록 처리시간이 급수적으로 늘어나는 알고리즘이다. 예를 들어 데이터가 10배가 되면, 처리 시간은 최대 100배가 된다. 이중 루프(n² matrix)가 대표적이다. 단, m이 n보다 작을 때는 반드시 O(nm)로 표시하는것이 바람직하다. O(2ⁿ) (Exponential) 데이터량이 많아질수록 처리시간이 기하급수적으로 늘어나는 알고리즘이다. 대표적으로 피보나치 수열이 있으며, 재귀가 역기능을 할 경우도 해당된다. Sprint - StringifyJSON # API 설명 JSON.stringify(obj) obj -\u0026gt; json문자열, 직렬화(serialize) JSON.parse(json문자열) json문자열 -\u0026gt; obj, 역직렬화(deserialize) JSON문자열은 \u0026quot;key\u0026quot;:\u0026quot;value\u0026quot;로 쌍따옴표만 사용 가능하고 공백 불가 function stringifyJSON(obj) { if (typeof obj === \u0026#34;number\u0026#34; || typeof obj === \u0026#34;boolean\u0026#34; || obj === null) { return String(obj); } if (typeof obj === \u0026#34;string\u0026#34;) { return `\u0026#34;${obj}\u0026#34;`; } if (Array.isArray(obj)) { // 새로운 배열에 넣어야함(그냥 리턴 시 요소가 리턴) const newArr = []; for (const item of obj) { newArr.push(stringifyJSON(item)); } // `{newArr}` or String(newArr)는 \u0026#34;items\u0026#34;로 나옴 // \u0026#34;[...]\u0026#34; return `[${newArr}]`; } if (typeof obj === \u0026#34;object\u0026#34;) { // `${{a: 1}}` -\u0026gt; [object object] // 문자열 안에 먼저 넣고 {}로 묶어줌 let innerStr = \u0026#34;\u0026#34;; for (const key in obj) { if (obj[key] === undefined || typeof obj[key] === \u0026#34;function\u0026#34;) { return \u0026#34;{}\u0026#34;; } innerStr = innerStr + `${stringifyJSON(key)}:${stringifyJSON(obj[key])},`; } // 마지막 쉼표 제거 // `{${\u0026#34;\u0026#39;key\u0026#39;:\u0026#39;value\u0026#39;,...,\u0026#34;}}` -\u0026gt; \u0026#34;{\u0026#34;key\u0026#34;:\u0026#34;value\u0026#34;,...}\u0026#34; return `{${innerStr.slice(0, -1)}}`; } } /* 개선 사항 */ for (const key in obj) { if (obj[key] !== undefined \u0026amp;\u0026amp; typeof obj[key] !== \u0026#34;function\u0026#34;) { innerStr = innerStr + `${stringifyJSON(key)}:${stringifyJSON(obj[key])},`; } } Tree UI #const root = document.getElementById(\u0026#34;root\u0026#34;); function createTreeView(menu, currentNode) { for (const item of menu) { if (item.type === \u0026#34;group\u0026#34;) { const liEl = document.createElement(\u0026#34;li\u0026#34;); currentNode.append(liEl); const inputEl = document.createElement(\u0026#34;input\u0026#34;); inputEl.type = \u0026#34;checkbox\u0026#34;; inputEl.checked = \u0026#34;false\u0026#34;; const spanEl = document.createElement(\u0026#34;span\u0026#34;); spanEl.textContent = item.name; const ulEl = document.createElement(\u0026#34;ul\u0026#34;); liEl.append(inputEl, spanEl, ulEl); createTreeView(item.children, ulEl); } else if (item.type === \u0026#34;item\u0026#34;) { const liEl = document.createElement(\u0026#34;li\u0026#34;); liEl.textContent = item.name; currentNode.append(liEl); } } } /* 개선 사항 1. 공통 요소 밖으로 빼기 2. Element를 생성하는 함수를 만들어서 반복을 줄이기 */ const createEl = (tag, parentEl, key, value) =\u0026gt; { const el = document.createElement(tag); parentEl.append(el); /* 여기서 setAttribute가 아닌 리터럴 할당을 해서 에러가 났었음 el.key를 해도 el에 key라는 attribute가 없어서 setAttribute를 써야함 */ key ? el.setAttribute(key, value) : null; return el; }; for (const item of menu) { const liEl = createEl(\u0026#34;li\u0026#34;, currentNode); if (item.type === \u0026#34;group\u0026#34;) { createEl(\u0026#34;input\u0026#34;, liEl, \u0026#34;type\u0026#34;, \u0026#34;checkbox\u0026#34;); const spanEl = createEl(\u0026#34;span\u0026#34;, liEl); spanEl.textContent = item.name; const ulEl = createEl(\u0026#34;ul\u0026#34;, liEl); createTreeView(item.children, ulEl); } else if (item.type === \u0026#34;item\u0026#34;) { liEl.textContent = item.name; } } Today\u0026rsquo;s takeaway # 분해해서 생각하기가 많은 도움이 되었다. 페어의 코드를 보며 많이 배웠다. 반복되는 기능을 함수로 빼서 재사용이 가능하게 만들고, 삼항연산자로 직관적이고 짧게 조건문을 적었다. 재귀는 트리구조에서 많이 유용하다. ","date":"7 October 2021","permalink":"/posts/bootcamp/bc-7w-3/","section":"Posts","summary":"Today I learned #\rBig-O notation # O(1) (Constant) 입력 데이터의 크기에 상관없이 언제나 일정한 시간이 걸리는 알고리즘을 나타낸다.","title":"BC-7w-3 / [자료구조/알고리즘] 재귀(2)"},{"content":"1. 포커스 및 화면 관리(ctrl) # 단축키 설명 ctrl+F2 상태 막대 포커스 이동 ctrl+F3 Dock 포커스 이동 ctrl+F4 활성 창 포커스 이동 *ctrl+F5 상태 메뉴 포커스 이동 ctrl+↑ 미션 컨트롤 ctrl+↓ 해당 앱 창 ctrl+⇆ 스페이스 이동 2. 스크린샷(cmd+shift) # 단축키 설명 cmd+shift+(ctrl)+3 전체 스크린샷 저장(복사) cmd+shift+(ctrl)+4 부분 스크린샷 저장(복사)spacebar로 현재 창 선택 cmd+shift+5 스크린샷 옵션 3. 검색(cmd+space) # 단축키 설명 cmd+space 스팟라이트 검색 cmd+opt+space 폴더 검색 *cmd+opt+shift+spacebar 사전 검색 4. 폴더 및 앱(cmd) # 단축키 설명 spacebar 파인더 에서 미리보기 cmd+shift+. 파인더에서 숨긴 파일 보기 cmd+opt+L 다운로드 폴더 열기 cmd+shift+C/H/D 파인더에서 컴퓨터/홈/데스크탑 폴더 열기 cmd+shift+N 파인더에서 새 폴더 생성 / 웹에서 새 시크릿창 열기 cmd+backspace 파인더에서 선택한 항목 휴지통으로 이동 cmd+D 파인더에서 선택한 파일 복제 / 웹에서 북마크 등록 cmd+E 파인더에서 선택한 디스크 또는 볼륨 추출 cmd+⇅ 파인더에서 상위/하위 폴더 / 웹에서 Home/End cmd+[/] 이전/다음 cmd+shift+[/] 이전/다음 탭 이동 cmd+shift+T 웹에서 마지막으로 닫은 탭 다시 열기 cmd+1~9 웹에서 해당 탭 이동 cmd+T 새 탭 열기, Safari는 cmd+N cmd+N 새 창 열기, Safari는 cmd+opt+N cmd+M+(opt) 현재 창(현재 앱) 숨기기 cmd+W+(opt) 탭 (모두) 닫기 cmd+Q 현재 앱 종료 cmd+R 웹에서 새로고침 cmd+shift+B 웹에서 북마크 보기 *cmd+ctrl+F 전체화면 5. 기타 # 단축키 설명 cmd+opt+esc 강제 종료 창 열기 cmd+, 설정 cmd+opt+ctrl+⇆ 데스크탑 이동 *An Asterisk is a custom setting\n","date":"7 October 2021","permalink":"/posts/etc/mac-shortcuts/","section":"Posts","summary":"1. 포커스 및 화면 관리(ctrl) # 단축키 설명 ctrl+F2 상태 막대 포커스 이동 ctrl+F3 Dock 포커스 이동 ctrl+F4 활성 창 포커스 이동 *ctrl+F5 상태 메뉴 포커스 이동 ctrl+↑ 미션 컨트롤 ctrl+↓ 해당 앱 창 ctrl+⇆ 스페이스 이동 2.","title":"Mac Shortcuts"},{"content":"1. Cursor # 단축키 설명 opt+shift+I Focus의 각 줄 마지막 멀티 커서 opt+click 멀티 커서 opt+⇆ 단어 커서 cmd+⇆/⇅ 커서 처음/끝으로(한 줄/페이지) cmd+U 커서 되돌리기 cmd+enter 다음 줄 이동 cmd+shift+\\ 괄호 끝으로 이동 2. Focus # 단축키 설명 cmd+D 같은 단어 하나씩 포커스 cmd+shift+L 같은 단어 한번에 포커스 cmd+L 한 줄 포커스 (opt/cmd+)shift+방향 키 (Cursor) 포커스 3. Open # 단축키 설명 (opt+)F12 정의 열기 ctrl+` 터미널 열기 cmd+shift+C 새 창에서 터미널 열기 ctrl+J 아래쪽 열기 ctrl+tap 탭 파일 열기 *cmd+shift+= Open Active File in New Window cmd+P 파일 열기 cmd+shift+P 명령장 열기 cmd+, 세팅 열기 cmd+B 왼쪽 열기 cmd+shift+E 탐색 열기 cmd+shift+F 전체 검색 열기 ctrl+shift+G 깃 열기 cmd+shift+D 디버그 열기 cmd+shift+X 확장 열기 4. Debug # 단축키 설명 F5 디버그 시작 F9 break point 설정 F10 줄 단위로 실행(step over) F11 줄 단위로 실행(step into) shift+F11 F11 함수에서 빠져나오기 5. Etc # 단축키 설명 F2 리네이밍 cmd+shift+R 리팩토링 opt+⇅ 한 줄 이동 opt+shift+⇅ 한 줄 복사 cmd+F 찾기 *cmd+opt+H 찾아 바꾸기 cmd+Z 작업 되돌리기 cmd+shift+Z 작업 다시 하기 cmd+/ 주석 cmd+ctrl+⇆ 터미널 크기 조정 *cmd+opt+V Open Preview to the Side ctrl+\\ 창 분할 cmd+1~9 분할 창 선택 ctrl+G 원하는 줄로 이동 F8 오류 찾기 *An asterisk is a custom setting\n","date":"7 October 2021","permalink":"/posts/etc/vsc-shortcuts/","section":"Posts","summary":"1. Cursor # 단축키 설명 opt+shift+I Focus의 각 줄 마지막 멀티 커서 opt+click 멀티 커서 opt+⇆ 단어 커서 cmd+⇆/⇅ 커서 처음/끝으로(한 줄/페이지) cmd+U 커서 되돌리기 cmd+enter 다음 줄 이동 cmd+shift+\\ 괄호 끝으로 이동 2.","title":"VSC Shortcuts"},{"content":"Today I learned #Algorithm Test 01 팩토리얼 인덱스 찾기 #\r팩토리얼은 수가 조금만 늘어도 기하급수적으로 증가. 따라서, 인덱스만을 찾는 방법을 고안 배열(N 개)의 첫 번째(i = 0) 수가 x 일 때, (N - 1)! * x의 인덱스(x - 1)가 x로 시작하는 가장 작은 배열의 인덱스 배열의 두 번째 수가 y 일 때, 앞에서 계산한 수에 \u0026hellip; 하려고 하니까 첫 번째 수에 따라서 다른 수가 남아서 처리가 힘듬 그래서 isUsed = [false, false, \u0026hellip;]로 숫자를 구분 배열의 i 인덱스가 x 일 때, (N - 1 - i)!에 x보다 작은 수 중에 false인 수의 개수만큼 곱해주면 해당 인덱스를 찾을 수 있음(남은 수 중에서 제일 작은 수 일 때는 0, 그다음 일 때는 1을 곱해주는 것) 이렇게 구한 i 인덱스를 마지막 한개가 남기 전까지 더해주면 K의 인덱스 재귀 함수 #재귀의 이해 # 재귀 동일한 구조의 더 작은 문제를 해결함으로써 주어진 문제를 해결하는 방법 재귀 호출 실행 과정 중 자기 자신을 호출 재귀 사용법 기존의 문제에서 출발하여 더 작은 경우를 생각 같은 방식으로, 문제가 더는 작아지지 않을 때까지 더 작은 경우를 생각 문제가 간단해져서 바로 풀 수 있게 되는 순간부터 앞서 생성한 문제를 차근차근 해결 재귀는 언제 사용할까? # 주어진 문제를 비슷한 구조의 더 작은 문제로 나눌 수 있는 경우 중첩된 반복문이 많거나 반복문의 중첩 횟수(number of loops)를 예측하기 어려운 경우 재귀적 사고 연습하기 # 재귀 함수의 입력값과 출력값 정의하기 arrSum: [number] =\u0026gt; number 문제를 쪼개고 경우의 수를 나누기 입력값의 순서와 크기로 구분 arrSum([1, 2, 3, 4]), arrSum([2, 3, 4]), arrSum([3, 4]) arrSum: [number] =\u0026gt; number\narrSum([])\narrSum([e1, e2, \u0026hellip; , en]) 단순한 문제 해결하기 재귀의 기초(base case) 재귀의 탈출 조건(재귀 호출이 멈추는 조건)을 구성 arrSum: [number] =\u0026gt; number\narrSum([]) = 0\narrSum([e1, e2, \u0026hellip; , en]) 복잡한 문제 해결하기 head와 tail로 구분 arrSum: [number] =\u0026gt; number\narrSum([]) = 0\narrSum([e1, e2, \u0026hellip; , en]) = e1 + arrSum([e2, \u0026hellip;, en]) 코드 구현하기 function arrSum(arr) { if (arr의 길이가 0인 경우) { return 0; } return head + arrSum(tail); } factorial로 알아보는 재귀 #function fac(n) { if (n \u0026lt;= 1) { return n; } return n * fac(n - 1); } 재귀함수 문제 #02 홀수 여부 #function func(num) { if (num \u0026lt; 0) { num *= -1; } // 재귀 반복 종료 조건 if (num === 0) { return false; } else if (num === 1) { return true; } // 재귀 반복(규칙) // 2씩 뺀 수를 넘겨서 확인 return func(num - 2); } 04 피보나치 #function func(num) { // if (num === 0) return 0 // if (num === 1) return 1 if (num \u0026lt;= 1) { return num; } // 두 자릿수 전과 한 자릿수 전의 피보다 치수를 더함 return func(num - 2) + func(num - 1); } 05 배열의 요소 합 #function func(arr) { // 배열이 빌 때까지 if (arr.length === 0) { return 0; } // 0 인덱스(head)를 남기면서, 배열 맨앞 제거 return arr[0] + func(arr.slice(1)); } 07 배열의 요소 개수 #function func(arr) { // 배열이 빌 때까지 if (arr.isEmpty()) { return 0; } // count(1을 남김)하면서, 배열 맨앞 제거 return 1 + func(arr.splice(1)); } 08 배열의 요소 제거 #// 숫자를 다 쓰거나 빈 배열이 빌 때까지 // 마지막에 배열 리턴 function func(num, arr) { if (num === 0 || arr.length === 0) { return arr; } // 숫자 하나를 지우면서, 배열 맨앞 제거 return func(num - 1, arr.slice(1)); } 09 배열의 요소 남김 #// 숫자를 다 쓰거나 빈 배열이 빌 때까지 function func(num, arr) { if (num === 0 || arr.length === 0) { return []; } // arr[0](head)을 배열 안에 남기고, // 숫자 하나를 지우면서, 배열 맨앞 제거 return [arr[0], ...func(num - 1, arr.slice(1))]; } 10 모든 요소의 논리곱(and) #function func(arr) { // false가 나오거나 길이가 1이면 리턴 if (arr[0] === false) { return false; } if (arr.length \u0026lt;= 1) { return true; } // 배열 맨앞 제거 return func(arr.slice(1)); /* ref // arr[0](head)을 남기면서, 배열 맨앞 제거 // 배열이 비면 true 반환 해서 논리곱으로 비교 if (arr.length === 0) { return true; } return arr[0] \u0026amp;\u0026amp; and(arr.slice(1)); */ } 12 배열 뒤집기 #function func(arr) { if (arr.length === 0) { return arr; } return [arr[arr.length - 1], ...func(arr.slice(0, arr.length - 1))]; /* ref return [...func(arr.slice(1)), arr[0]]; */ } 13 이차원 객체 탐색 #function func(matryoshka, size) { // 반복 종료 조건 if (matryoshka.size === size) { return true; // 반복 조건 } else if (matryoshka.matryoshka \u0026amp;\u0026amp; matryoshka.size \u0026gt; size) { // 반복 내용(재귀) return func(matryoshka.matryoshka, size); } // base case return false; } 14 이차원 배열 탐색 #function func(giftBox, wish) { for (gift of giftBox) { if (gift === wish) { return true; } // 배열안에 배열 if (Array.isArray(gift)) { // 에 wish가 있어서 true 일 때만 true 반환 아니면 pass if (func(gift, wish)) { return true; } } } // base case return false; } /* 이중 배열 일 때 if로 안 걸러주면, 배열 안에 배열에 wish가 없을 때, false 반환하고 함수 종료되버림 */ 15 다차원 배열 =\u0026gt; 1차원 배열 #function func(arr) { const result = []; for (item of arr) { if (Array.isArray(item)) { // 배열일 때, 재귀로 내부 배열의 result를 push result.push(...func(item)); // 배열이 아닐 때, 요소를 그데로 push } else { result.push(item); } } return result; } Today\u0026rsquo;s takeaway # 반복은 반복되는 규칙을 찾는 것이 중요하다. 재귀 반복 종료 조건, 반복 내용(재귀)으로 구분 반복 조건이 있을 때는 base case도 설정 무엇을 남길 때는 헤드 사용 _Algorithm Test도 재귀함 수도 많이 어려웠다. 하지만 원리를 파악하고 차근차근 알고리즘을 생각하다 보니 해결할 수 있었다. 문제를 분리해서 생각하자! 한 번에 전체 해결법을 생각하는 것보다 하나씩 해결법을 생각하는 게 더 쉽다. ","date":"6 October 2021","permalink":"/posts/bootcamp/bc-7w-2/","section":"Posts","summary":"Today I learned #Algorithm Test 01 팩토리얼 인덱스 찾기 #\r팩토리얼은 수가 조금만 늘어도 기하급수적으로 증가.","title":"BC-7w-2 / [자료구조/알고리즘] 재귀(1)"},{"content":"Today I learned #클래스를 이용한 모듈화 #클로저 모듈 패턴 #function makeCounter() { return { value: 0, increase: function () { this.value++; // 메소드 호출을 할 경우, this는 makeCounter 함수가 리턴하는 익명의 객체 }, decrease: function () { this.value--; }, getValue: function () { return this.value; }, }; } let counter1 = makeCounter(); counter1.increase(); counter1.getValue(); // 1 let counter2 = makeCounter(); counter2.decrease(); counter2.decrease(); counter2.getValue(); // -2 클래스와 인스턴스 #//// 클래스(original form) class Car { // 인스턴스가 초기화될 때 실행하는 생성자 함수 constructor(brand, name, color) { // 속성 this.brand = brand; this.name = name; this.color = color; } // 메소드 refuel() {} drive() {} } // 원형 객체(original form) // 공통적인 정보는 여기 작성하는 것이 효율적 Car.prototype.printName = function () { console.log(this.name); }; //// 인스턴스(instance object) let mini = new Car(\u0026#34;bmw\u0026#34;, \u0026#34;mini\u0026#34;, \u0026#34;black\u0026#34;); let beetles = new Car(\u0026#34;volkswagen\u0026#34;, \u0026#34;beetles\u0026#34;, \u0026#34;yellow\u0026#34;); mini.brand; // \u0026#39;bmw\u0026#39; mini.refuel(); beetles.color; // \u0026#34;yellow\u0026#34; beatles.drive(); // 배열은 Array의 인스턴스를 만드는 것과 동일 let arr = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]; arr.length; // 3 arr.push(\u0026#34;d\u0026#34;); let arr = new Array(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); arr.length; // 3 arr.push(\u0026#34;d\u0026#34;); Prototype #객체 지향 프로그래밍 # 객체 지향 프로그래밍(OOP, Object-oriented programming)은, 데이터(속성)와 기능(메소드)을 한곳에 묶어서 처리 캡슐화(Encapsulation) 데이터와 기능을 하나의 단위에 묶음 은닉 구현은 숨기고 동작은 노출시킴 엄격한 클래스는 setter와 getter를 사용 추상화(Abstraction) 노출되는 부분을 단순하게 만듦 필요하지 않은 것을 노출시키지 않고, 단순한 이름으로 정의 인터페이스 메소드와 속성만 정의한 것 상속(Inheritance) 상위 클래스의 속성을 상속받고, 하위 클래스에 속성 추가 가능 JS에서는 extends 와 super 키워드를 이용해서 상속을 구현 다형성(Polymorphism) 똑같은 메소드라도, 다른 방식으로 구현 가능 동일한 메소드에 대해 if/else if와 같은 조건문 대신 객체의 특성에 맞게 달리 작성 프로토타입과 프로토타입 체인 # prototype 프로토타입 체인을 통해 상속하고자 하는 속성과 메소드를 담아두는 버킷으로 주로 사용되는 객체 prototype chain 해당 클래스 혹은 인스턴스부터 상위 클래스까지 순서대로 속성과 메소드를 참조 Sprint-Beesbeesbees # extends와 super를 이용한 클래스 상속 실습 Today\u0026rsquo;s takeaway # 컴퓨터의 사고방식은 절차적이지만, 사람의 사고방식은 객체 지향적이다. 재사용성은 유지, 보수에 큰 도움이 된다. section2 첫날이라서 그런지 매우 쉽게 구성되어 있었다. ","date":"5 October 2021","permalink":"/posts/bootcamp/bc-7w-1/","section":"Posts","summary":"Today I learned #클래스를 이용한 모듈화 #클로저 모듈 패턴 #function makeCounter() { return { value: 0, increase: function () { this.","title":"BC-7w-1 / [JS/Node] 객체지향 프로그래밍"},{"content":"6주 차 정리 # 10월 1일에 코로나 2차 백신을 맞았다. 아직 감기몸살이 있어서 그런지 1차와는 다르게 백신 부작용이 있었다. HA를 하기 전에는 매우 쉬울 거라고 예상하였으나 생각보다 어려웠다. 리액트는 이벤트 핸들러와 이벤트 확산 방지를 몰라서 시간이 오래 걸렸다. 이를 통해 검색을 적극적으로 도움 되게 사용하는 법을 배웠다. JavaScript 부분은 기존의 알고리즘 테스트와 같아서 쉽게 풀었다. HA를 통해 앞으로 어떻게 공부해야 하는지를 배우게 되었다. 어떤 기능을 지녔는지와 왜 사용하는지를 알아야 한다. Section1 회고 # 기본적인 HTML과 CSS부터 JS와 React까지 어떻게 웹 화면을 구성할 수 있는지에 관하여 배웠다. 기능적인 부분 이외에 어떤 Semantic Tag를 사용할지 나, 클래스명과 함수명, 폰트 사이즈 등을 정하는 게 아직 시간이 오래 걸렸다. 학습을 따라가는 것은 어렵지 않았지만 추가 공부를 병행하니 시간이 많이 부족했다. 거기에 영어 공부까지 하려고 한 것은 욕심이었다. 추가로 공부하는 Fastcampus 프런트 앤드 강의를 끝내고 나면 영어 공부할 시간이 날 것이다. 건강관리가 중요하다는 것을 절실히 깨달았다. 원래 잘 아프지 않아서 신경을 안 쓰다 독한 감기에 걸렸고, 감기가 나의 퍼포먼스에 영향을 많이 줬다. 앞으로는 영양제도 챙겨 먹고 꾸준히 운동도 하면서 건강에 신경을 써야겠다. Section2는 낯선 백엔드를 배워서 기대가 된다. React처럼 처음에는 낯설어서 적응이 잘되지 않고 어렵게 느껴지겠지만, 차근차근 학습 과정을 잘 따라가고 추가로 더 학습을 하다 보면 점점 적응이 되고 이해가 쉽게 될 것이다. React는 아직도 너무 어렵다. 코드 스테이츠 과정 내의 React는 이제 완전히 이해하였으나, 혼자서 공식 사이트를 들어가서 추가 내용들을 공부하니 너무 어려웠다. 한 개념을 이해하는 데만 거의 반나절 이상을 사용했다. 코드 스테이츠가 준비해 준 학습 자료들을 통해 배워나가는 게 얼마나 쉬운지 절실히 깨달았다. 혼자서 공부하려고 하니 방대한 양중에 어디부터 봐야 할지 어떻게 배운 내용을 확인할지부터가 난관이었다. 그래도 잘 정리된 블로그나 유튜브를 참조하여 면 조금씩 진행 중이다. ","date":"3 October 2021","permalink":"/posts/bootcamp/bc-6w-4/","section":"Posts","summary":"6주 차 정리 # 10월 1일에 코로나 2차 백신을 맞았다.","title":"BC-6w / 6주 차 정리, Section1 회고"},{"content":"Today I learned # HA-JavaScript Today\u0026rsquo;s takeaway # section1 HA로 알고리즘 테스트(JavaScript)를 진행했다. 문제는 전부 이전에 풀어본 양식이어서 어렵지 않았다. 리액트 부분을 아직 완전히 정리하지 못해서 추가로 정리했다. Tomorrow I\u0026rsquo;ll learn # 내일부터 다음 주 화요일 section2 시작 전까지 스스로 복습하는 기간이다. 리액트를 배운 부분까지 완벽히 정리하고, WIL 자바스크립트 부분도 다시 한번 정리할 것이다. ","date":"29 September 2021","permalink":"/posts/bootcamp/bc-6w-3/","section":"Posts","summary":"Today I learned # HA-JavaScript Today\u0026rsquo;s takeaway # section1 HA로 알고리즘 테스트(JavaScript)를 진행했다.","title":"BC-6w-3 / HA-JavaScript"},{"content":"Today I learned #Section Review #DOM #\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;DOM Review\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;city-list\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const places = [ { id: 1, city: \u0026#34;Busan\u0026#34;, country: \u0026#34;Korea\u0026#34;, address: \u0026#34;Yangdal\u0026#34; }, { id: 2, city: \u0026#34;Dubai\u0026#34;, country: \u0026#34;AE\u0026#34;, address: \u0026#34;Bastakia\u0026#34; }, { id: 3, city: \u0026#34;Manila\u0026#34;, country: \u0026#34;Philippine\u0026#34;, address: \u0026#34;Tagaytay\u0026#34; }, ]; for (let i = 0; i \u0026lt; places.length; i++) { let cityListEl = document.querySelector(\u0026#34;.city-list\u0026#34;); let listEl = document.createElement(\u0026#34;li\u0026#34;); cityListEl.appendChild(listEl); let countryEl = document.createElement(\u0026#34;span\u0026#34;); listEl.appendChild(countryEl); let div = document.createElement(\u0026#34;div\u0026#34;); listEl.appendChild(divEl); let cityEl = document.createElement(\u0026#34;span\u0026#34;); divEl.appendChild(cityEl); let brEl = document.createElement(\u0026#34;br\u0026#34;); divEl.appendChild(brEl); let addressEl = document.createElement(\u0026#34;span\u0026#34;); divEl.appendChild(addressEl); country.classList.add(\u0026#34;country\u0026#34;); cityEl.classList.add(\u0026#34;city\u0026#34;); addressEl.classList.add(\u0026#34;address\u0026#34;); countryEl.textContent = `${places[i].country}`; cityEl.textContent = `City : ${places[i].city}`; addressEl.textContent = `Address : ${places[i].address}`; } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; HA-React #Bare Minimum #\reventHandler={(e) =\u0026gt; (\u0026hellip;, e) =\u0026gt; {}} eventHandler 안에는 함수 자체가 와야 함(함수 실행 x) 아무런 인자를 담지 않으면 event 객체만 전달 Advanced #\r주로 배열안에 객체 형태로 정보 저장 const handleSubmit = (input, e) =\u0026gt; {\nconst todo = {\ntext: input,\nid: nanoid(),\ncomplete: false,\n};\nsetInput(\u0026quot;\u0026quot;);\nonSubmit([\u0026hellip;todos, todo]);\ne.preventDefault();\n}; 객체에 정보 저장 후 구조 분해 할당으로 배열에 추가 e.preventDefault(); 고유 동작을 중단 e.stopPropagation() 상위 엘리먼트로의 이벤트 전파를 중단 제거 setTodos(todos.filter((item) =\u0026gt; item.id !== id)) 선택 setTodos(\ntodos.map((todo) =\u0026gt; {\nif (todo.id === id) {\ntodo.complete = !todo.complete;\n}\nreturn todo;\n})\n); 조건부 할당 let todoClass = todo.complete ? \u0026ldquo;todo-row complete\u0026rdquo; : \u0026ldquo;todo-row\u0026rdquo;; Today\u0026rsquo;s takeaway # section1 HA로 React 과제를 진행했다. 통과 여부를 결정하는 Bare Minimum은 eventHandler 안에는 함수 자체가 와야 하고 함수의 실행이 오면 안 된다는 사실을 놓쳐서 시간이 오래 걸렸다. 추가로 더 공부하고 싶은 사람만 하는 Advanced는 a 태그나 input 태그 등의 고유 동작을 막는 e.preventDefault()를 몰라서 시간이 오래 걸렸다. 지금까지는 공부를 하는 입장이라 막힐 때마다 검색을 하기보다는 혼자 오래 고민했다. 하지만 과제를 풀다 보니 기능적으로 모르는 부분은 혼자서는 절대 알 수 없는 것이었다. 검색 결과에는 문제 풀이만을 위한 나의 지엽적인 방법보다 훨씬 간단하고 범용적인 방법들이 많았다. 앞으로 공부 방향을 수정하여 수도 코드는 혼자 스스로 만들 돼(for 스스로 생각하는 힘) 기능적인 부분은 검색의 힘을 많이 빌릴 것이다.(for 더 나은 기능들) Tomorrow I\u0026rsquo;ll learn # 내일은 Hiring Assessments(JavaScript)를 진행한다. 제한 시간이 내일 하루 종일로 여유롭게 주어 저서 전혀 걱정되지 않는다. 내일 HA를 마친 뒤 리액트를 마저 정리할 것이다. ","date":"28 September 2021","permalink":"/posts/bootcamp/bc-6w-2/","section":"Posts","summary":"Today I learned #Section Review #DOM #\u0026lt;!","title":"BC-6w-2 / HA-React"},{"content":"Today I learned #+ React with FastCampus(7) Advanced #Optimizing Performance # 필요할 때만 랜더 한다.\nReconciliation\n랜더 전후의 일치 여부를 판단하는 규칙 서로 다른 타입의 두 엘리먼트는 서로 다른 트리를 만들어낸다. 개발자가 key prop 을 통해, 여러 렌더링 사이에서 어떤 자식 엘리먼트가 변경되지 않아야 할지 표시해 줄 수 있다. DOM 엘리먼트의 타입이 다른 경우\nclass Foo extends React.Component { componentDidMount() { console.log(\u0026#34;Foo componentDidMount\u0026#34;); } componentWillUnmount() { console.log(\u0026#34;Foo componentWillUnmount\u0026#34;); } render() { return \u0026lt;p\u0026gt;Foo\u0026lt;/p\u0026gt;; } } class App extends React.Component { state = { count: 0, }; componentDidMount() { setInterval(() =\u0026gt; { this.setState({ count: this.state.count + 1, }); }, 1000); } render() { if (this.state.count % 2 === 0) { return ( \u0026lt;div\u0026gt; \u0026lt;Foo /\u0026gt; \u0026lt;/div\u0026gt; ); } return ( \u0026lt;span\u0026gt; \u0026lt;Foo /\u0026gt; \u0026lt;/span\u0026gt; ); } } 계속 unmount 했다, mount 했다 반복 Foo componentDidMount\nFoo componentWillUnmount\nFoo componentDidMount Foo componentWillUnmount\nFoo componentDidMount Foo componentWillUnmount\nFoo componentDidMount\n\u0026hellip; DOM 엘리먼트의 타입이 같은 경우\nclass App extends React.Component { state = { count: 0, }; componentDidMount() { setInterval(() =\u0026gt; { this.setState({ count: this.state.count + 1, }); }, 1000); } render() { if (this.state.count % 2 === 0) { return \u0026lt;div className=\u0026#34;before\u0026#34; title=\u0026#34;stuff\u0026#34; /\u0026gt;; } return \u0026lt;div className=\u0026#34;after\u0026#34; title=\u0026#34;stuff\u0026#34; /\u0026gt;; } } class App extends React.Component { state = { count: 0, }; componentDidMount() { setInterval(() =\u0026gt; { this.setState({ count: this.state.count + 1, }); }, 1000); } render() { if (this.state.count % 2 === 0) { return \u0026lt;div style={{ color: \u0026#34;red\u0026#34;, fontWeight: \u0026#34;bold\u0026#34; }} /\u0026gt;; } return \u0026lt;div style={{ color: \u0026#34;green\u0026#34;, fontWeight: \u0026#34;bold\u0026#34; }} /\u0026gt;; } } 달라진 attribute 값만 변함 같은 타입의 컴포넌트 엘리먼트\nclass Foo extends React.Component { state = {}; componentDidMount() { console.log(\u0026#34;Foo componentDidMount\u0026#34;); } componentWillUnmount() { console.log(\u0026#34;Foo componentWillUnmount\u0026#34;); } static getDerivedStateFromProps(nextProps, prevState) { console.log(\u0026#34;Foo getDerivedStateFromProps\u0026#34;, nextProps, prevState); return {}; } render() { console.log(\u0026#34;Foo render\u0026#34;); return \u0026lt;p\u0026gt;Foo\u0026lt;/p\u0026gt;; } } class App extends React.Component { state = { count: 0, }; componentDidMount() { setInterval(() =\u0026gt; { this.setState({ count: this.state.count + 1, }); }, 1000); } render() { if (this.state.count % 2 === 0) { return \u0026lt;Foo name=\u0026#34;Mark\u0026#34; /\u0026gt;; } return \u0026lt;Foo name=\u0026#34;Anna\u0026#34; /\u0026gt;; } } 컴포넌트에서 props가 바뀐 라이프사이클 훅이 실현되고, 맞춰서 랜더 실행 mount, unmount가 아니라 컴포넌트가 업데이트됨 Foo getDerivedStateFromProps {name: \u0026ldquo;Mark\u0026rdquo;} {}\nFoo render\nFoo componentDidMount\nFoo getDerivedStateFromProps {name: \u0026ldquo;Anna\u0026rdquo;} {}\nFoo render\nFoo getDerivedStateFromProps {name: \u0026ldquo;Mark\u0026rdquo;} {}\nFoo render Foo getDerivedStateFromProps {name: \u0026ldquo;Anna\u0026rdquo;} {}\nFoo render\n\u0026hellip; 자식에 대한 재귀적 처리\nclass Foo extends React.Component { state = {}; componentDidMount() { console.log(\u0026#34;Foo componentDidMount\u0026#34;, this.props.children); } componentWillUnmount() { console.log(\u0026#34;Foo componentWillUnmount\u0026#34;); } static getDerivedStateFromProps(nextProps, prevState) { console.log(\u0026#34;Foo getDerivedStateFromProps\u0026#34;, nextProps, prevState); return {}; } render() { console.log(\u0026#34;Foo render\u0026#34;, this.props.children); return \u0026lt;p\u0026gt;{this.props.children}\u0026lt;/p\u0026gt;; } } class App extends React.Component { state = { count: 0, }; componentDidMount() { setInterval(() =\u0026gt; { this.setState({ count: this.state.count + 1, }); }, 3000); } render() { if (this.state.count % 2 === 0) { return ( \u0026lt;ul\u0026gt; \u0026lt;Foo\u0026gt;first\u0026lt;/Foo\u0026gt; \u0026lt;Foo\u0026gt;second\u0026lt;/Foo\u0026gt; \u0026lt;/ul\u0026gt; ); } return ( \u0026lt;ul\u0026gt; \u0026lt;Foo\u0026gt;first\u0026lt;/Foo\u0026gt; \u0026lt;Foo\u0026gt;second\u0026lt;/Foo\u0026gt; \u0026lt;Foo\u0026gt;third\u0026lt;/Foo\u0026gt; \u0026lt;/ul\u0026gt; ); } } Foo getDerivedStateFormProps {children: \u0026ldquo;first\u0026rdquo;} {}\nFoo render first\nFoo getDerivedStateFormProps {children: \u0026ldquo;second\u0026rdquo;} {}\nFoo render second\nFoo componentDidMount first\nFoo componentDidMount second\nFoo getDerivedStateFormProps {children: \u0026ldquo;first\u0026rdquo;} {}\nFoo render first\nFoo getDerivedStateFormProps {children: \u0026ldquo;second\u0026rdquo;} {}\nFoo render second\nFoo getDerivedStateFormProps {children: \u0026ldquo;third\u0026rdquo;} {}\nFoo render third\nFoo componentDidMount third\nFoo getDerivedStateFormProps {children: \u0026ldquo;first\u0026rdquo;} {}\nFoo render first\nFoo getDerivedStateFormProps {children: \u0026ldquo;second\u0026rdquo;} {}\nFoo render second\nFoo componentWillUnmount\nFoo getDerivedStateFormProps {children: \u0026ldquo;first\u0026rdquo;} {}\nFoo render first\nFoo getDerivedStateFormProps {children: \u0026ldquo;second\u0026rdquo;} {}\nFoo render second\nFoo getDerivedStateFormProps {children: \u0026ldquo;third\u0026rdquo;} {}\nFoo render third\nFoo componentDidMount third\nFoo getDerivedStateFormProps {children: \u0026ldquo;first\u0026rdquo;} {}\nFoo render first\nFoo getDerivedStateFormProps {children: \u0026ldquo;second\u0026rdquo;} {}\nFoo render second\nFoo componentWillUnmount\n\u0026hellip; class App extends React.Component { state = { count: 0, }; componentDidMount() { setInterval(() =\u0026gt; { this.setState({ count: this.state.count + 1, }); }, 3000); } render() { if (this.state.count % 2 === 0) { return ( \u0026lt;ul\u0026gt; \u0026lt;Foo\u0026gt;second\u0026lt;/Foo\u0026gt; \u0026lt;Foo\u0026gt;third\u0026lt;/Foo\u0026gt; \u0026lt;/ul\u0026gt; ); } return ( \u0026lt;ul\u0026gt; \u0026lt;Foo\u0026gt;first\u0026lt;/Foo\u0026gt; \u0026lt;Foo\u0026gt;second\u0026lt;/Foo\u0026gt; \u0026lt;Foo\u0026gt;third\u0026lt;/Foo\u0026gt; \u0026lt;/ul\u0026gt; ); } } Foo getDerivedStateFormProps {children: \u0026ldquo;second\u0026rdquo;} {}\nFoo render second\nFoo getDerivedStateFormProps {children: \u0026ldquo;third\u0026rdquo;} {}\nFoo render third\nFoo componentDidMount second\nFoo componentDidMount third\nFoo getDerivedStateFormProps {children: \u0026ldquo;first\u0026rdquo;} {}\nFoo render first\nFoo getDerivedStateFormProps {children: \u0026ldquo;second\u0026rdquo;} {}\nFoo render second\nFoo getDerivedStateFormProps {children: \u0026ldquo;third\u0026rdquo;} {}\nFoo render third\nFoo componentDidMount third\nFoo getDerivedStateFormProps {children: \u0026ldquo;second\u0026rdquo;} {}\nFoo render second\nFoo getDerivedStateFormProps {children: \u0026ldquo;third\u0026rdquo;} {}\nFoo render third\nFoo componentWillUnmount\nFoo getDerivedStateFormProps {children: \u0026ldquo;first\u0026rdquo;} {}\nFoo render first\nFoo getDerivedStateFormProps {children: \u0026ldquo;second\u0026rdquo;} {}\nFoo render second\nFoo getDerivedStateFormProps {children: \u0026ldquo;third\u0026rdquo;} {}\nFoo render third\nFoo componentDidMount third\nFoo getDerivedStateFormProps {children: \u0026ldquo;second\u0026rdquo;} {}\nFoo render second\nFoo getDerivedStateFormProps {children: \u0026ldquo;third\u0026rdquo;} {}\nFoo render third\nFoo componentWillUnmount\n\u0026hellip; class App extends React.Component { state = { count: 0, }; componentDidMount() { setInterval(() =\u0026gt; { this.setState({ count: this.state.count + 1, }); }, 3000); } render() { if (this.state.count % 2 === 0) { return ( \u0026lt;ul\u0026gt; \u0026lt;Foo key=\u0026#34;2\u0026#34;\u0026gt;second\u0026lt;/Foo\u0026gt; \u0026lt;Foo key=\u0026#34;3\u0026#34;\u0026gt;third\u0026lt;/Foo\u0026gt; \u0026lt;/ul\u0026gt; ); } return ( \u0026lt;ul\u0026gt; \u0026lt;Foo key=\u0026#34;1\u0026#34;\u0026gt;first\u0026lt;/Foo\u0026gt; \u0026lt;Foo key=\u0026#34;2\u0026#34;\u0026gt;second\u0026lt;/Foo\u0026gt; \u0026lt;Foo key=\u0026#34;3\u0026#34;\u0026gt;third\u0026lt;/Foo\u0026gt; \u0026lt;/ul\u0026gt; ); } } Foo getDerivedStateFormProps {children: \u0026ldquo;second\u0026rdquo;} {} Foo render second\nFoo getDerivedStateFormProps {children: \u0026ldquo;third\u0026rdquo;} {}\nFoo render third\nFoo componentDidMount second\nFoo componentDidMount first\nFoo getDerivedStateFormProps {children: \u0026ldquo;first\u0026rdquo;} {}\nFoo render first\nFoo getDerivedStateFormProps {children: \u0026ldquo;second\u0026rdquo;} {}\nFoo render second\nFoo getDerivedStateFormProps {children: \u0026ldquo;third\u0026rdquo;} {}\nFoo render third\nFoo componentDidMount first\nFoo getDerivedStateFormProps {children: \u0026ldquo;second\u0026rdquo;} {}\nFoo render second\nFoo getDerivedStateFormProps {children: \u0026ldquo;third\u0026rdquo;} {}\nFoo render third\nFoo componentWillUnmount\nFoo getDerivedStateFormProps {children: \u0026ldquo;first\u0026rdquo;} {}\nFoo render first\nFoo getDerivedStateFormProps {children: \u0026ldquo;second\u0026rdquo;} {}\nFoo render second\nFoo getDerivedStateFormProps {children: \u0026ldquo;third\u0026rdquo;} {}\nFoo render third\nFoo componentDidMount first\nFoo getDerivedStateFormProps {children: \u0026ldquo;second\u0026rdquo;} {}\nFoo render second\nFoo getDerivedStateFormProps {children: \u0026ldquo;third\u0026rdquo;} {}\nFoo render third\nFoo componentWillUnmount \u0026hellip;\nkey는 해당 컴포넌트의 랜더 사이의 값을 유지하기 위한 식별자 *Component Lifecycle setState와 함께 일어나는 일\n아무런 대책을 세우지 않았을 때\nclass Person extends React.Component { render() { console.log(\u0026#34;Person render\u0026#34;); const { name, age } = this.props; return ( \u0026lt;ul\u0026gt; {name} / {age} \u0026lt;/ul\u0026gt; ); } } class App extends React.Component { state = { text: \u0026#34;\u0026#34;, persons: [ { id: 1, name: \u0026#34;Mark\u0026#34;, age: 37 }, { id: 2, name: \u0026#34;Anna\u0026#34;, age: 26 }, ], }; render() { console.log(\u0026#34;App render\u0026#34;); const { text, persons } = this.state; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={text} onChange={this._change} /\u0026gt; \u0026lt;button onClick={this._click}\u0026gt;click\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; {persons.map((p) =\u0026gt; ( \u0026lt;Person {...p} key={p.id} /\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } _change = (e) =\u0026gt; { this.setState({ ...this.state, text: e.target.value, }); }; _click = () =\u0026gt; { console.log(this.state.text); }; } App render\nPerson render\nPerson render\n// 키 입력 시, 모든 과정이 반복 shouldComponentUpdate\nclass Person extends React.Component { shouldComponentUpdate(previousProps) { for (const key in this.props) { if (previousProps[key] !== this.props[key]) { return true; } } return false; } render() { console.log(\u0026#34;Person render\u0026#34;); const { name, age } = this.props; return ( \u0026lt;ul\u0026gt; {name} / {age} \u0026lt;/ul\u0026gt; ); } } class App extends React.Component { state = { text: \u0026#34;\u0026#34;, persons: [ { id: 1, name: \u0026#34;Mark\u0026#34;, age: 37 }, { id: 2, name: \u0026#34;Anna\u0026#34;, age: 26 }, ], }; render() { console.log(\u0026#34;App render\u0026#34;); const { text, persons } = this.state; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={text} onChange={this._change} /\u0026gt; \u0026lt;button onClick={this._click}\u0026gt;click\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; {persons.map((p) =\u0026gt; ( \u0026lt;Person {...p} key={p.id} /\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } _change = (e) =\u0026gt; { this.setState({ ...this.state, text: e.target.value, }); }; _click = () =\u0026gt; { console.log(this.state.text); }; } App render\nPerson render\nPerson render\n// 키 입력 시, App render만 반복 PureComponent\nclass Person extends React.PureComponent { render() { console.log(\u0026#34;Person render\u0026#34;); const { name, age } = this.props; return ( \u0026lt;ul\u0026gt; {name} / {age} \u0026lt;/ul\u0026gt; ); } } ... App render\nPerson render\nPerson render\n// 키 입력 시, App render만 반복 주의 사항({() =\u0026gt; {}})\n... class App extends React.Component { state = { text: \u0026#34;\u0026#34;, persons: [ { id: 1, name: \u0026#34;Mark\u0026#34;, age: 37 }, { id: 2, name: \u0026#34;Anna\u0026#34;, age: 26 }, ], }; render() { console.log(\u0026#34;App render\u0026#34;); const { text, persons } = this.state; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={text} onChange={this._change} /\u0026gt; \u0026lt;button onClick={this._click}\u0026gt;click\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; {persons.map((p) =\u0026gt; ( \u0026lt;Person {...p} key={p.id} onClick={() =\u0026gt; {}} /\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } _change = (e) =\u0026gt; { this.setState({ ...this.state, text: e.target.value, }); }; _click = () =\u0026gt; { console.log(this.state.text); }; } App render\nPerson render\nPerson render\n// 키 입력 시, 모든 과정이 반복\n// onClick 함수가 props에 매번 새로 만들어서 들어감 ... class App extends React.Component { state = { text: \u0026#34;\u0026#34;, persons: [ { id: 1, name: \u0026#34;Mark\u0026#34;, age: 37 }, { id: 2, name: \u0026#34;Anna\u0026#34;, age: 26 }, ], }; render() { console.log(\u0026#34;App render\u0026#34;); const { text, persons } = this.state; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={text} onChange={this._change} /\u0026gt; \u0026lt;button onClick={this._click}\u0026gt;click\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; {persons.map((p) =\u0026gt; ( \u0026lt;Person {...p} key={p.id} onClick={this.toPersonClick} /\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } _change = (e) =\u0026gt; { this.setState({ ...this.state, text: e.target.value, }); }; _click = () =\u0026gt; { console.log(this.state.text); }; toPersonClick = () =\u0026gt; {}; } App render\nPerson render\nPerson render\n// 키 입력 시, App render만 반복 Function Component\nconst Person = React.memo((props) =\u0026gt; { console.log(\u0026#34;Person render\u0026#34;); const { name, age } = props; return ( \u0026lt;ul\u0026gt; {name} / {age} \u0026lt;/ul\u0026gt; ); }); function App() { const [state, setState] = React.useState({ text: \u0026#34;\u0026#34;, persons: [ { id: 1, name: \u0026#34;Mark\u0026#34;, age: 37 }, { id: 2, name: \u0026#34;Anna\u0026#34;, age: 26 }, ], }); const toPersonClick = React.useCallback(() =\u0026gt; {}, []); const { text, persons } = state; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={text} onChange={change} /\u0026gt; \u0026lt;button onClick={click}\u0026gt;click\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; {persons.map((p) =\u0026gt; ( \u0026lt;Person {...p} key={p.id} onClick={toPersonClick} /\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); function change(e) { setState({ ...state, text: e.target.value, }); } function click() { console.log(state.text); } } App render\nPerson render\nPerson render\n// 다시 랜더가 일어나지 않음\n// React.memo는 PureComponent처럼 사용\n// React.useCallback은 함수의 반복을 막아줌 React.createPortal #\u0026lt;!-- public/index.html --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; ... \u0026lt;title\u0026gt;React App\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;noscript\u0026gt;You need to enable JavaScript to run this app.\u0026lt;/noscript\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;modal\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; /* src/index.css */ body { ...; } #modal { position: absolute; top: 0; left: 0; } // src/components/Modal.jsx import ReactDOM from \u0026#34;react-dom\u0026#34;; const Modal = ({ children }) =\u0026gt; ReactDOM.createPortal(children, document.querySelector(\u0026#34;#modal\u0026#34;)); export default Modal; // src/App.js import { useState } from \u0026#34;react\u0026#34;; import Modal from \u0026#34;./components/Modal\u0026#34;; function App() { const [visible, setVisible] = useState(false); const open = () =\u0026gt; { setVisible(true); }; const close = () =\u0026gt; { setVisible(false); }; return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={open}\u0026gt;open\u0026lt;/button\u0026gt; {visible \u0026amp;\u0026amp; ( \u0026lt;Modal\u0026gt; \u0026lt;div style={{ width: \u0026#34;100vw\u0026#34;, height: \u0026#34;100vh\u0026#34;, background: \u0026#34;rgba(0,0,0,.5)\u0026#34;, }} onClick={close} \u0026gt; Hello \u0026lt;/div\u0026gt; \u0026lt;/Modal\u0026gt; )} \u0026lt;/div\u0026gt; ); } export default App; React.forwardRef # DOM 에 refs 전달하기 // MyInput.jsx import React from \u0026#34;react\u0026#34;; export default React.forwardRef(function MyInput(props, ref) { return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;My input\u0026lt;/p\u0026gt; \u0026lt;input ref={ref} /\u0026gt; \u0026lt;/div\u0026gt; ); }); // App.js import { useRef } from \u0026#34;react\u0026#34;; import MyInput from \u0026#34;./MyInput\u0026#34;; function App() { const myInputRef = useRef(); const click = () =\u0026gt; { console.log(myInputRef.current.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;MyInput ref={myInputRef} /\u0026gt; \u0026lt;button onClick={click}\u0026gt;send\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; Today\u0026rsquo;s takeaway # 오전에는 페어에게 React Twittler Advanced 코드를 설명하는 시간을 가졌다. 이제 코드를 설명하는 능력도 많이 향상되었다. 오후에는 Fastcampus 강의를 들고, HA를 대비하여 지금까지 배웠던 React를 WIL에 총정리했다. 리액트를 배우면서 리액트뿐만 아니라 최적화나 중복 데이터의 관리 등 기본적인 프로그래밍 방식들도 배울 수 있었다. Tomorrow I\u0026rsquo;ll learn # 내일 오전에는 solo review를 진행하고, 오후에는 Hiring Assessments(React)를 진행한다. 사전에 보았던 예시로는 기본적인 라우팅 문제여서 크게 긴장되지는 않는다. ","date":"27 September 2021","permalink":"/posts/bootcamp/bc-6w-1/","section":"Posts","summary":"Today I learned #+ React with FastCampus(7) Advanced #Optimizing Performance # 필요할 때만 랜더 한다.","title":"BC-6w-1 / {FC} React(7)"},{"content":"5주 차 정리(추석 연휴) # 19일은 외가, 20일은 산소, 21일은 친가를 방문했다. 21일 친가를 다녀온 뒤 블로그 이전을 시작했다. 기존의 티스토리 블로그에서 코드 블록이 자동으로 풀려있고, 맞춤법 검사 페이지에서 넘어갈 수 없고, 작성 도중 갑자기 글의 시작 부분에 삽입이 되는 문제와 리스트를 작성했을 때 간격이 재멋데로인 점 때문에 깃허브 블로그로 이전을 결심했다. 깃허브 블로그를 만드는 여러 방법 중 가장 인기가 많은 Jekyll을 사용하기로 했다. 하지만 M1 환경에서는 여러 에러가 있었다. 검색을 통해 하나씩 해결하면서 설치를 완료하였고, 테스트 결과도 성공적이었다. 그래서 이제 내가 원하는 형태로 커스터마이징을 하는데 도중에 다시 에러가 발생했다. 해결법을 찾다가 실패하고 전부 지운 뒤 다시 다운을 받았다. 하지만 이제는 기본 설정을 전혀 건드리지 않은 상태에서도 로컬 서버 구축과 첫 포스트 외의 포스트 게시가 되지 않는 문제가 있었다. jekyll과 ruby까지 재설치하고 22일, 결국 대안으로 hugo를 선택했다. jekyll은 처음부터 여러 에러가 발생하여 하나씩 고치면서 설치를 진행한데 반해, hugo는 M1 환경에서도 아무 에러가 나지 않으며 포스팅 속도가 더 빠르다는 장점도 있어서 매우 마음에 들었다. hugo를 통한 블로그 구축은 매우 쉽고 빠르게 진행되었으며, 커스터마이징도 내가 원하는 데로 할 수 있었다. 23일과 24일은 기존 티스토리 블로그의 포스팅을 깃허브 블로그로 옮기는 작업을 했다. 동시에 작성 양식을 다듬으면서 복습도 진행했다. 24일 오후부터는 패스트 캠퍼스 리액트 강의를 듣기 시작했다. 22일 저녁부터 감기 기운이 있었다. 저녁에도 반팔 반바지로 외출한 게 원인인 것 같다. 다행히 기침과 열은 없었다. 목 통증, 가래, 두통, 근육통이 있었다. 최대한 따뜻한 물을 자주 마시며 휴식과 공부를 병행했다. 조금 괜찮아져서 25일 저녁 가족과 외식을 다녀왔는데 26일 아침에 더 심해져 있었다. 몸이 아프니까 뇌의 처리능력도 떨어진 것 같다. 강의에 집중이 잘되지 않았다. 그래도 평소에 조금씩 운동을 해서 그런지 체력적으로는 버틸 수 있었다. 추석이 되기 전에 패스트 캠퍼스의 React 강의는 적어도 다 보는 것이 목표였다. 하지만 블로그 이전과 감기 이슈로 강의가 조금 남아서 아쉽다. 그래도 이전한 블로그는 매우 만족스럽고, 이전 도중에 자연스럽게 총 복습도 진행할 수 있었던 점은 좋았다. + React with FastCampus(6) Testing # JavaScript Unit Test with JEST\nnpm i jest -D\n\u0026ldquo;test\u0026rdquo;: \u0026ldquo;jest\u0026rdquo;\nnpx jest \u0026ndash;watchAll\nit(\u0026ldquo;test명\u0026rdquo;, () =\u0026gt; {})\nexpect().toBe() describe(\u0026quot;\u0026quot;, () =\u0026gt; {})\n함수 안에 여러개의 it를 넣어서 그룹화 가능 Ex.\ndescribe(\u0026#34;expect test\u0026#34;, () =\u0026gt; { it(\u0026#34;1 + 2 = 3\u0026#34;, () =\u0026gt; { expect(1 + 2).toBe(3); }); it(\u0026#34;{age: 39} to equal {age: 39}\u0026#34;, () =\u0026gt; { expect({ age: 39 }).toEqual({ age: 39 }); }); // fail it(\u0026#34;{age: 39} to equal {age: 39}\u0026#34;, () =\u0026gt; { expect({ age: 39 }).toEqual({ age: 39 }); }); // pass it(\u0026#34;.toHaveLength\u0026#34;, () =\u0026gt; { expect(\u0026#34;hello\u0026#34;).toHaveLength(5); }); it(\u0026#34;.toHaveProperty\u0026#34;, () =\u0026gt; { expect({ name: \u0026#34;Yuchan\u0026#34; }).toHaveProperty(\u0026#34;name\u0026#34;, \u0026#34;Yuchan\u0026#34;); }); it(\u0026#34;.toBeDefined\u0026#34;, () =\u0026gt; { expect({ name: \u0026#34;Yuchan\u0026#34; }.name).toBeDefined(); }); it(\u0026#34;.toBeFalsy\u0026#34;, () =\u0026gt; { expect().toBeFalsy(); }); it(\u0026#34;.toBeGreaterThan\u0026#34;, () =\u0026gt; { expect(10).toBeGreaterThan(9); }); it(\u0026#34;.toBeGreaterThanOrEqual\u0026#34;, () =\u0026gt; { expect(10).toBeGreaterThanOrEqual(10); }); it(\u0026#34;.toBeInstanceOf\u0026#34;, () =\u0026gt; { class Foo {} expect(new Foo()).toBeInstanceOf(Foo); }); }); .not.to\u0026hellip;도 가능 비동기 테스트\nasync test with done callback\ndescribe(\u0026#34;use async test\u0026#34;, () =\u0026gt; { it(\u0026#34;setTimeout with done\u0026#34;, (done) =\u0026gt; { setTimeout(() =\u0026gt; { expect(37).toBe(36); done(); }, 1000); }); }); async test with promise\ndescribe(\u0026#34;use async test\u0026#34;, () =\u0026gt; { it(\u0026#34;promise then\u0026#34;, () =\u0026gt; { function p() { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(37); }, 1000); }); } return p().then((data) =\u0026gt; expect(data).toBe(37)); }); it(\u0026#34;promise catch\u0026#34;, () =\u0026gt; { function p() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { reject(new Error(\u0026#34;error\u0026#34;)); }, 1000); }); } return p().catch((e) =\u0026gt; expect(e).toBeInstanceOf(Error)); }); }); describe(\u0026#34;use async test\u0026#34;, () =\u0026gt; { it(\u0026#34;promise .resolves\u0026#34;, () =\u0026gt; { function p() { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(37); }, 1000); }); } return expect(p()).resolves.toBe(37); }); it(\u0026#34;promise .rejects\u0026#34;, () =\u0026gt; { function p() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { reject(new Error(\u0026#34;error\u0026#34;)); }, 1000); }); } return expect(p()).rejects.toBeInstanceOf(Error); }); }); async test with async-await(Best way)\ndescribe(\u0026#34;use async test\u0026#34;, () =\u0026gt; { it(\u0026#34;async-await\u0026#34;, async () =\u0026gt; { function p() { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(37); }, 1000); }); } const data = await p(); return expect(data).toBe(37); }); }); describe(\u0026#34;use async test\u0026#34;, () =\u0026gt; { it(\u0026#34;async-await, catch\u0026#34;, async () =\u0026gt; { function p() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { reject(new Error(\u0026#34;error\u0026#34;)); }, 1000); }); } try { await p(); } catch (error) { expect(error).toBeInstanceOf(Error); } }); }); React Component Test\n__tests__ 폴더 안의 .js 파일 .test.js 로 끝나는 파일 .spec.js 로 끝나는 파일 testing-libraryreact 활용하기\n// Button.test.js import { render, fireEvent, act } from \u0026#34;@testing-library/react\u0026#34;; import Button from \u0026#34;./Button\u0026#34;; describe(\u0026#34;Button 컴포넌트 (@testing-library/react)\u0026#34;, () =\u0026gt; { it(\u0026#34;컴포넌트가 정상적으로 생성된다.\u0026#34;, () =\u0026gt; { const button = render(\u0026lt;Button /\u0026gt;); expect(button).not.toBeNull(); }); it(\u0026#39;\u0026#34;button\u0026#34; 이라고 쓰여있는 엘리먼트는 HTMLButtonElement 이다.\u0026#39;, () =\u0026gt; { const { getByText } = render(\u0026lt;Button /\u0026gt;); const buttonElement = getByText(\u0026#34;button\u0026#34;); expect(buttonElement).toBeInstanceOf(HTMLButtonElement); }); it(\u0026#39;버튼을 클릭하면, p 태그 안에 \u0026#34;버튼이 방금 눌렸다.\u0026#34; 라고 쓰여진다.\u0026#39;, () =\u0026gt; { const { getByText } = render(\u0026lt;Button /\u0026gt;); const buttonElement = getByText(\u0026#34;button\u0026#34;); fireEvent.click(buttonElement); const p = getByText(\u0026#34;버튼이 방금 눌렸다.\u0026#34;); expect(p).not.toBeNull(); expect(p).toBeInstanceOf(HTMLParagraphElement); }); it(`버튼을 클릭하기 전에는, p 태그 안에 \u0026#34;버튼이 눌리지 않았다.\u0026#34; 라고 쓰여진다.`, () =\u0026gt; { const { getByText } = render(\u0026lt;Button /\u0026gt;); const p = getByText(\u0026#34;버튼이 눌리지 않았다.\u0026#34;); expect(p).not.toBeNull(); expect(p).toBeInstanceOf(HTMLParagraphElement); }); it(`버튼을 클릭하고 5초 뒤에는, p 태그 안에 \u0026#34;버튼이 눌리지 않았다.\u0026#34; 라고 쓰여진다.`, async () =\u0026gt; { jest.useFakeTimers(); const { getByText } = render(\u0026lt;Button /\u0026gt;); const buttonElement = getByText(\u0026#34;button\u0026#34;); fireEvent.click(buttonElement); // Arrange Act Assert act(() =\u0026gt; { jest.advanceTimersByTime(5000); }); const p = getByText(\u0026#34;버튼이 눌리지 않았다.\u0026#34;); expect(p).not.toBeNull(); expect(p).toBeInstanceOf(HTMLParagraphElement); }); it(`버튼을 클릭하면, 5초 동안 버튼이 비활성화 된다.`, () =\u0026gt; { jest.useFakeTimers(); const { getByText } = render(\u0026lt;Button /\u0026gt;); const buttonElement = getByText(\u0026#34;button\u0026#34;); fireEvent.click(buttonElement); expect(buttonElement).toBeDisabled(); act(() =\u0026gt; { jest.advanceTimersByTime(5000); }); expect(buttonElement).not.toBeDisabled(); }); }); // jsx import { useEffect, useRef, useState } from \u0026#34;react\u0026#34;; const BUTTON_TEXT = { NORMAL: \u0026#34;버튼이 눌리지 않았다.\u0026#34;, CLICKED: \u0026#34;버튼이 방금 눌렸다.\u0026#34;, }; const Button = () =\u0026gt; { const [message, setMessage] = useState(BUTTON_TEXT.NORMAL); const timer = useRef(); function click() { setMessage(BUTTON_TEXT.CLICKED); timer.current = setTimeout(() =\u0026gt; { setMessage(BUTTON_TEXT.NORMAL); }, 5000); } useEffect(() =\u0026gt; { return () =\u0026gt; { if (timer.current) { clearTimeout(timer.current); } }; }, []); return ( \u0026lt;\u0026gt; \u0026lt;button onClick={click} disabled={message === BUTTON_TEXT.CLICKED}\u0026gt; button \u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;{message}\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ); }; export default Button; jest-dom user-event ","date":"26 September 2021","permalink":"/posts/bootcamp/bc-5w-3/","section":"Posts","summary":"5주 차 정리(추석 연휴) # 19일은 외가, 20일은 산소, 21일은 친가를 방문했다.","title":"BC-5w-추석(3) / 5주 차 정리 + {FC} React(6)"},{"content":"React with FastCampus(5) 실전 활용 #HOC(Higher-Order Component) # HOC = function(컴포넌트) { return 새로운 컴포넌트 } Ex. withRouter() \u0026lt;\u0026mdash; React with FastCampus(3) 사용 시 주의 사항 랜더 메소드 안에 쓰지 말라 인자로 들어가는 컴포넌트를 변경하지 말라 인자로 들어가는 컴포넌트의 Static Methods는 자동으로 복사되지 않음 따로 적어주거나, hoist-non-react-statics 라이브러리 사용 Refs는 바로 통과되지 않음 React.forwardRef로 통과시켜야 함 Controlled Component \u0026amp; Uncontrolled Component # Controlled\n엘리먼트의 상태를 엘리먼트를 가지고 있는 컴포넌트가 관리 Ex. 이메일 형식과 맞지 않으면 빨간색이다가 맞으면 초록색으로 변함 import React from \u0026#34;react\u0026#34;; class ControlledComponent extends React.Component { state = { value: \u0026#34;\u0026#34;, }; render() { const { value } = this.state; return ( \u0026lt;div\u0026gt; \u0026lt;input value={value} onChange={this.change} /\u0026gt; \u0026lt;button onClick={this.click}\u0026gt;전송\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } change = (event) =\u0026gt; { this.setState({ value: event.target.value }); }; click = (event) =\u0026gt; { console.log(this.state.value); }; } export default ControlledComponent; Uncontrolled\n엘리먼트의 상태를 관리하지 않고, 엘리먼트의 참조만 컴포넌트가 소유\nEx. 마우스를 올리면 포커스 되게 함(실제 엘리먼트에 포커스)\nimport React from \u0026#34;react\u0026#34;; class UncontrolledComponent extends React.Component { inputRef = React.createRef(); render() { console.log(\u0026#34;initial render\u0026#34;, this.inputRef); return ( \u0026lt;div\u0026gt; \u0026lt;input ref={this.inputRef} /\u0026gt; \u0026lt;button onClick={this.click}\u0026gt;전송\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } componentDidMount() { console.log(\u0026#34;componentDidMount\u0026#34;, this.inputRef); } click = (event) =\u0026gt; { // input 엘리먼트의 value를 꺼내서 전송 console.log(this.inputRef.current.value); }; } export default UncontrolledComponent; Hooks \u0026amp; Context #Basic Hooks # useState\n// class component import React from \u0026#34;react\u0026#34;; export default class Example1 extends React.Component { state = { count: 0 }; render() { const { count } = this.state; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;You clicked {count} times\u0026lt;/p\u0026gt; \u0026lt;button onClick={this.click}\u0026gt;click\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } click = () =\u0026gt; { this.setState({ count: this.state.count + 1 }); }; } // function component import React from \u0026#34;react\u0026#34;; export default function Example2() { const [state, setState] = React.useState({ count: 0 }); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;You clicked {state.count} times\u0026lt;/p\u0026gt; \u0026lt;button onClick={click}\u0026gt;click\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); function click() { setState((state) =\u0026gt; ({ count: state.count + 1 })); } } useEffect #// class component import React from \u0026#34;react\u0026#34;; export default class Example3 extends React.Component { state = { count: 0 }; render() { const { count } = this.state; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;You clicked {count} times\u0026lt;/p\u0026gt; \u0026lt;button onClick={this.click}\u0026gt;click\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } componentDidMount() { console.log(\u0026#34;componentDidMount\u0026#34;, this.state.count); } componentDidUpdate() { console.log(\u0026#34;componentDidUpdate\u0026#34;, this.state.count); } click = () =\u0026gt; { this.setState({ count: this.state.count + 1 }); }; } // function component import React from \u0026#34;react\u0026#34;; export default function Example4() { const [state, setState] = React.useState({ count: 0 }); React.useEffect(() =\u0026gt; { console.log(\u0026#34;componentDidMount\u0026#34;); return () =\u0026gt; { // cleanup // componentWillUmount // 닫혀있어서 마지막에만 작동 }; }, []); React.useEffect(() =\u0026gt; { console.log( \u0026#34;componentDidMount \u0026amp; componentDidUpdate by state.count\u0026#34;, state.count ); return () =\u0026gt; { // cleanup // 이전 값으로 미리 실행하고 넘어감 console.log(\u0026#34;cleanup by state.count\u0026#34;, state.count); }; }, [state.count]); // 두 번째 인자는 처음을 제외하고 해당 목록이 변했을 때 useEffect 실행 return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;You clicked {state.count} times\u0026lt;/p\u0026gt; \u0026lt;button onClick={click}\u0026gt;click\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); function click() { setState((state) =\u0026gt; ({ count: state.count + 1 })); } } 추가 공부! 클린업과 디펜던시 in useEffect Custom Hooks(useSomething) #// Hooks import { useState, useEffect } from \u0026#34;react\u0026#34;; export default function useWindowWidth() { const [width, setWidth] = useState(window.innerWidth); useEffect(() =\u0026gt; { const resize = () =\u0026gt; { setWidth(window.innerWidth); }; window.addEventListener(\u0026#34;resize\u0026#34;, resize); return () =\u0026gt; { window.removeEventListener(\u0026#34;resize\u0026#34;, resize); }; }, []); // 최초일 때만 처리됨 return width; } // HOC import React from \u0026#34;react\u0026#34;; export default function withHasMounted(Component) { class NewComponent extends React.Component { state = { hasMounted: false, }; render() { const { hasMounted } = this.state; return \u0026lt;Component {...this.props} hasMounted={hasMounted} /\u0026gt;; } componentDidMount() { this.setState({ hasMounted: true }); } } // fot Debugging NewComponent.displayName = `withHasMounted(${Component.name})`; return NewComponent; } // Hooks import { useState } from \u0026#34;react\u0026#34;; import { useEffect } from \u0026#34;react/cjs/react.development\u0026#34;; export default function useHasMounted() { const [hasMounted, setHasMounted] = useState(false); useEffect(() =\u0026gt; { setHasMounted(true); }); return hasMounted; } // App.js import useWindowWidth from \u0026#34;./hooks/useWindowWidth\u0026#34;; import withHasMounted from \u0026#34;./hoc/withHasMounted\u0026#34;; import useHasMounted from \u0026#34;./hooks/useHasMounted\u0026#34;; function App({ hasMounted }) { const width = useWindowWidth(); const hasMountedFromHooks = useHasMounted(); console.log(hasMounted, hasMountedFromHooks); return \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt;{width}\u0026lt;/div\u0026gt;; } export default withHasMounted(App); useReducer # 다수의 하윗값을 포함하는 복잡한 정적 로직을 만드는 경우 다음 state가 이전 state에 의존적인 경우 Redux를 배운뒤 쉽게 사용 가능 import { useReducer } from \u0026#34;react\u0026#34;; // reducer -\u0026gt; state를 변경하는 로직이 담겨있는 함수 const reducer = (prevState, action) =\u0026gt; { if (action.type === \u0026#34;PLUS\u0026#34;) { return { count: prevState.count + 1, }; } return prevState; }; // dispatch -\u0026gt; action 객체를 넣어서 실행 // action -\u0026gt; 객체이고 필수 프로퍼티로 type을 가짐 export default function Example6() { const [state, dispatch] = useReducer(reducer, { count: 0 }); const click = () =\u0026gt; { dispatch({ type: \u0026#34;PLUS\u0026#34; }); }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;You clicked {state.count} times\u0026lt;/p\u0026gt; \u0026lt;button onClick={click}\u0026gt;click\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } useMemo, useCallback #import { useState, useMemo, useCallback } from \u0026#34;react\u0026#34;; function sum(persons) { console.log(\u0026#34;sum...\u0026#34;); return persons.map((item) =\u0026gt; item.age).reduce((acc, cur) =\u0026gt; acc + cur); } export default function Example7() { const [value, setValue] = useState(\u0026#34;\u0026#34;); const persons = useState([ { name: \u0026#34;Yuchan\u0026#34;, age: 27 }, { name: \u0026#34;Chesley\u0026#34;, age: 25 }, ]); // count는 persons에 의존적으로 변해야함 // for 최적화 const count = useMemo(() =\u0026gt; { return sum(persons); }, [persons]); // 최초에만 생성 // 디펜던시 리스트 // for 컴포넌트 최적화(뒤에서 다룸) const click = useCallback(() =\u0026gt; { console.log(value); }, []); const change = (event) =\u0026gt; { setValue(event.target.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;input value={value} onChange={change} /\u0026gt; \u0026lt;p\u0026gt;{count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={click}\u0026gt;click\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } useRef, createRef #import { useState, useRef, createRef } from \u0026#34;react\u0026#34;; const [value, setValue] = useState(\u0026#34;\u0026#34;); const input1Ref = createRef(); // 랜더마다 새로 넣어줌 const input2Ref = useRef(); // 랜더 사이에 유지 but 최초에는 undefined console.log(input1Ref.current, input2Ref.current); // -\u0026gt; null - undefined // -\u0026gt; null - input const change = (e) =\u0026gt; { setValue(e.target.value); }; return ( \u0026lt;div\u0026gt; // controlled component \u0026lt;input value={value} onChange={change} /\u0026gt; // uncontrolled component \u0026lt;input ref={input1Ref} /\u0026gt; \u0026lt;input ref={input2Ref} /\u0026gt; \u0026lt;/div\u0026gt; ); } 추가 공부! 다른 유요한 훅 라이브러리들 알아보기 Router Hooks # useHistory\nimport { useHistory } from \u0026#34;react-router-dom\u0026#34;; export default function LoginButton() { const history = useHistory(); function login() { history.push(\u0026#34;/\u0026#34;); } return \u0026lt;button conClick={login}\u0026gt;로그인\u0026lt;button\u0026gt; } useParams\nexport default function Profile() { const params = useParams(); const id = params.id; return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;프로필 페이지\u0026lt;/h2\u0026gt; {id \u0026amp;\u0026amp; \u0026lt;p\u0026gt;id는 {id}입니다.\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } Router Communication\n하위 컴포넌트 변경하기\nimport { useState } from \u0026#34;react\u0026#34;; export default function A() { const [value, setValue] = useState(\u0026#34;아직 안바뀜\u0026#34;); const click = () =\u0026gt; { setValue(\u0026#34;E의 값을 변경\u0026#34;); }; return ( \u0026lt;div\u0026gt; \u0026lt;B value={value} /\u0026gt; \u0026lt;button onClick={click}\u0026gt;E 변경\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } function B({ value }) { return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;여긴 B\u0026lt;/p\u0026gt; \u0026lt;C value={value} /\u0026gt; \u0026lt;/div\u0026gt; ); } function C({ value }) { return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;여긴 C\u0026lt;/p\u0026gt; \u0026lt;D value={value} /\u0026gt; \u0026lt;/div\u0026gt; ); } function D({ value }) { return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;여긴 D\u0026lt;/p\u0026gt; \u0026lt;E value={value} /\u0026gt; \u0026lt;/div\u0026gt; ); } function E({ value }) { return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;여긴 E\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;{value}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } 상위 컴포넌트 변경하기\nimport { useState } from \u0026#34;react\u0026#34;; export default function A() { const [value, setValue] = useState(\u0026#34;아직 안바뀜\u0026#34;); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{value}\u0026lt;/p\u0026gt; \u0026lt;B setValue={setValue} /\u0026gt; \u0026lt;/div\u0026gt; ); } function B({ setValue }) { return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;여긴 B\u0026lt;/p\u0026gt; \u0026lt;C setValue={setValue} /\u0026gt; \u0026lt;/div\u0026gt; ); } function C({ setValue }) { return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;여긴 C\u0026lt;/p\u0026gt; \u0026lt;D setValue={setValue} /\u0026gt; \u0026lt;/div\u0026gt; ); } function D({ setValue }) { return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;여긴 D\u0026lt;/p\u0026gt; \u0026lt;E setValue={setValue} /\u0026gt; \u0026lt;/div\u0026gt; ); } function E({ setValue }) { const click = () =\u0026gt; { setValue(\u0026#34;A의 값을 변경\u0026#34;); }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;여긴 E\u0026lt;/p\u0026gt; \u0026lt;button onClick={click}\u0026gt;A 변경\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } Context API # 하위 컴포넌트 전체에 데이터를 공유\n데이터 set(가장 상위 컴포넌트, provider)\n// contexts/PersonContext.js import { createContext } from \u0026#34;react\u0026#34;; const PersonContext = createContext(); export default PersonContext; // index.js import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import \u0026#34;./index.css\u0026#34;; import App from \u0026#34;./App\u0026#34;; import reportWebVitals from \u0026#34;./reportWebVitals\u0026#34;; import PersonContext from \u0026#34;./contexts/PersonContext\u0026#34;; const persons = [ { id: 0, name: \u0026#34;yuchan\u0026#34;, age: 27 }, { id: 1, name: \u0026#34;chesley\u0026#34;, age: 25 }, ]; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;PersonContext.Provider value={persons}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/PersonContext.Provider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;) ); // If you want to start measuring performance in your app, pass a function // to log results (for example: reportWebVitals(console.log)) // or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals reportWebVitals(); 데이터 get(1) - 컨슈머\nimport PersonContext from \u0026#34;../contexts/PersonContext\u0026#34;; export default function Consumer() { return ( \u0026lt;PersonContext.Consumer\u0026gt; {(persons) =\u0026gt; ( \u0026lt;ul\u0026gt; {persons.map((persons) =\u0026gt; ( \u0026lt;li\u0026gt;{persons.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; )} \u0026lt;/PersonContext.Consumer\u0026gt; ); } 데이터 get(2) - useContext\nimport { useContext } from \u0026#34;react\u0026#34;; import PersonContext from \u0026#34;../contexts/PersonContext\u0026#34;; export default function UseContext() { const persons = useContext(PersonContext); return ( \u0026lt;ul\u0026gt; {persons.map((persons) =\u0026gt; ( \u0026lt;li\u0026gt;{persons.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; ); } ","date":"25 September 2021","permalink":"/posts/bootcamp/bc-5w-2/","section":"Posts","summary":"React with FastCampus(5) 실전 활용 #HOC(Higher-Order Component) # HOC = function(컴포넌트) { return 새로운 컴포넌트 } Ex.","title":"BC-5w-추석(2) / {FC} React(5)"},{"content":"React with FastCampus(4) Style #Style Loaders # loader in webpack CSS, SASS # 스타일이 전역적으로 순서만 다르게 들어가서,\n클래스명이 오염되지 않게 주의해야 함 import \u0026lsquo;./App.css\u0026rsquo;, 대표적으로 BEM 작명법 import \u0026lsquo;./App.sass\u0026rsquo; 상위 요소의 스코프 안에 하위 요소의 스타일 넣음 CSS에서 좀 더 문법적인 요소 가미 CSS module, SASS module # 스코프 오염을 막기 위해 사용\nimport styles from \u0026ldquo;./App.module.css\u0026rdquo;\n{\nApp: \u0026ldquo;App_App__16ZpL\u0026rdquo;,\nApp-logo: \u0026ldquo;App_App-logo__25k4o\u0026rdquo;,\nApp-logo-spin: \u0026ldquo;App_App-logo-spin__1e7sv\u0026rdquo;,\nApp-header: \u0026ldquo;App_App-header__xLkWl\u0026rdquo;,\nApp-link: \u0026ldquo;App_App-link__3FsH9\u0026rdquo;\n} 오염되지 않게 실제 클래스명은 value로 저장 className={styles.App} classNames 라이브러리\nnpm i classNames\nclassNames(\u0026ldquo;class1\u0026rdquo;, \u0026ldquo;class2\u0026rdquo;, \u0026hellip;)\nclassNames({ class1: true }, { class2: false }, \u0026hellip;)\nfalsy 한 값은 적용 X import styles from \u0026#34;./App.module.css\u0026#34;; import classNames from \u0026#34;classnames/bind\u0026#34;; const cx = classNames.bind(styles); console.log(cx.App); // -\u0026gt; \u0026#34;App_App__16ZpL\u0026#34; class App extends React.Component { state = { loading: false, }; render() { const { loading } = this.state return ( \u0026lt;button onClick={this.startLoading} className={cx(\u0026#34;button\u0026#34;, { loading: loading })} {...this.props} /\u0026gt; ); } const startLoading = () = { ... } } Styled Components # npm i styled-components\n스코프 오염을 막기 위해 사용\n템플릿 스트링\n문자열 안에 쓰는 거라 오류 감지 안됨 //StyledButton.jsx import styled, { css } from \u0026#34;styled-components\u0026#34;; const StyledButton = styled.button` background: transparent; border: 2px solid palevioletred; color: palevioletred; ${(props) =\u0026gt; props.primary \u0026amp;\u0026amp; css` background: palevioletred; color: white; `} `; export default StyledButton` `; // StyledA.js import styled from \u0026#34;styled-components\u0026#34;; const StyledA = styled.a.attrs((props) =\u0026gt; ({ target: \u0026#34;_BLANK\u0026#34;, }))` color: ${(props) =\u0026gt; props.color}; `; export default StyledA; //App.js import StyledButton from \u0026#34;./components/StyledButton\u0026#34;; import styled, { createGlobalStyle } from \u0026#34;styled-components\u0026#34;; const PrimaryStyledButton = styled(StyledButton)` background: palevioletred; color: white; `; const UppercaseButton = (props) =\u0026gt; ( \u0026lt;button {...props} children={props.children.toUpperCase()} /\u0026gt; ); const MyButton = (props) =\u0026gt; ( \u0026lt;button {...props} children={`MyButton ${props.children}`} /\u0026gt; ); const StyledMyButton = styled(MyButton)` background: transparent; border: 2px solid ${(props) =\u0026gt; props.color || \u0026#34;palevioletred\u0026#34;}; color: palevioletred; :hover { border: 2px solid red; } ::before { content: \u0026#34;@\u0026#34;; } `; const GlobalStyle = createGlobalStyle` button { border-radius: 10px; } `; function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;GlobalStyle /\u0026gt; \u0026lt;StyledButton\u0026gt;버튼\u0026lt;/StyledButton\u0026gt; \u0026lt;StyledButton primary\u0026gt;버튼\u0026lt;/StyledButton\u0026gt; \u0026lt;PrimaryStyledButton\u0026gt;버튼\u0026lt;/PrimaryStyledButton\u0026gt; \u0026lt;StyledButton as=\u0026#34;a\u0026#34; href=\u0026#34;/\u0026#34;\u0026gt; 버튼 \u0026lt;/StyledButton\u0026gt; \u0026lt;StyledButton as={UppercaseButton}\u0026gt;button\u0026lt;/StyledButton\u0026gt; \u0026lt;StyledMyButton\u0026gt;button\u0026lt;/StyledMyButton\u0026gt; \u0026lt;StyledMyButton color=\u0026#34;green\u0026#34;\u0026gt;button\u0026lt;/StyledMyButton\u0026gt; \u0026lt;StyledA href=\u0026#34;https://google.com\u0026#34;\u0026gt;태그\u0026lt;/StyledA\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; output\nReact Shadow # npm i react-shadow\n원래 HTML에 영향을 주지 않는 별도의 HTML\n스코프 오염을 막기 위해 사용\n전역 스타일이 불가능함\nimport root from \u0026#34;react-shadow\u0026#34;; const styles = ` .App { text-align: center; } .App-header { background-color: #282c34; min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: calc(10px + 2vmin); color: white; } .App-link { color: #61dafb; } `; function App() { return ( \u0026lt;root.div\u0026gt; \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;header className=\u0026#34;App-header\u0026#34;\u0026gt; \u0026lt;a className=\u0026#34;App-link\u0026#34; href=\u0026#34;https://reactjs.org\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener noreferrer\u0026#34; \u0026gt; Learn React \u0026lt;/a\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt;{styles}\u0026lt;/style\u0026gt; \u0026lt;/root.div\u0026gt; ); } export default App; Ant Design # npm i antd\nimport \u0026ldquo;antd/dist/antd.css 전역 스타일 추가 in index.js import { \u0026hellip; } from \u0026lsquo;antd\u0026rsquo;\nimport \u0026lsquo;antd/es/\u0026hellip;/style/css 컴포넌트 스타일 추가 npm install \u0026ndash;save @ant-design/icons\nimport { \u0026hellip; } from \u0026ldquo;@ant-design/icons\u0026rdquo;;\n\u0026lt;\u0026hellip; /\u0026gt; import { Row, Col } from \u0026ldquo;antd\u0026rdquo;;\n\u0026lt;Col span={24 중에 차지할 비중 정수}\u0026gt;\nimport { Row, Col } from \u0026#34;antd\u0026#34;; const colStyle = () =\u0026gt; ({ height: 50, backgroundColor: \u0026#34;red\u0026#34;, opacity: Math.round(Math.random() \\* 10) / 10, }); function App() { return ( \u0026lt;div classNAme=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Row\u0026gt; \u0026lt;Col span={24} style={colStyle()} /\u0026gt; \u0026lt;/Row\u0026gt; \u0026lt;Row\u0026gt; \u0026lt;Col span={12} style={colStyle()} /\u0026gt; \u0026lt;Col span={12} style={colStyle()} /\u0026gt; \u0026lt;/Row\u0026gt; \u0026lt;Row\u0026gt; \u0026lt;Col span={6} style={colStyle()} /\u0026gt; \u0026lt;Col span={6} style={colStyle()} /\u0026gt; \u0026lt;Col span={6} style={colStyle()} /\u0026gt; \u0026lt;Col span={6} style={colStyle()} /\u0026gt; \u0026lt;/Row\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; output \u0026lt;Row gutter={16 + 8n 의 정수}\u0026gt;\n\u0026lt;Col offset={24 중 건너띄고 싶은 정수}\u0026gt;\nimport { Row, Col } from \u0026#34;antd\u0026#34;; const MyCol = ({ span, offset }) =\u0026gt; ( \u0026lt;Col span={span} offset={offset}\u0026gt; \u0026lt;div style={{ height: 50, backgroundColor: \u0026#34;red\u0026#34;, opacity: 0.7, }} /\u0026gt; \u0026lt;/Col\u0026gt; ); function App() { return ( \u0026lt;div classNAme=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Row gutter={16}\u0026gt; \u0026lt;MyCol span={12} offset={12} /\u0026gt; \u0026lt;/Row\u0026gt; \u0026lt;Row gutter={16}\u0026gt; \u0026lt;MyCol span={8} /\u0026gt; \u0026lt;MyCol span={8} offset={8} /\u0026gt; \u0026lt;/Row\u0026gt; \u0026lt;Row gutter={16}\u0026gt; \u0026lt;MyCol span={6} /\u0026gt; \u0026lt;MyCol span={6} /\u0026gt; \u0026lt;MyCol span={6} /\u0026gt; \u0026lt;MyCol span={6} /\u0026gt; \u0026lt;/Row\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; output only gutter output \u0026lt;Row justify=\u0026ldquo;좌우정렬\u0026rdquo; align=\u0026ldquo;위아래정렬\u0026rdquo;\u0026gt;\n","date":"24 September 2021","permalink":"/posts/bootcamp/bc-5w-1/","section":"Posts","summary":"React with FastCampus(4) Style #Style Loaders # loader in webpack CSS, SASS # 스타일이 전역적으로 순서만 다르게 들어가서,","title":"BC-5w-추석(1) / {FC} React(4)"},{"content":"4주 차 정리 # 월요일에는 DOM의 이벤트에 대해 배우고, 혼자서 TypeScript를 학습했다. 작성 중 실시간으로 에러에 대한 정보를 알려주니 너무 좋았다. JavaScript는 컴파일 전까지 혹은 컴파일 후에도 에러 상황이 생기기 전까지는 에러에 대해서 알 수가 없어서 뒤늦게 에러를 발견하는 상황이 자주 생겼었다. 화요일에는 고차 함수를 배웠는데 어떤 상황에 어떤 배열 메소드를 사용해야 하는지를 익힐 수 있었다. 대표적으로 map()은 새로운 배열을, filter()는 기존 배열의 일부를, reduce()는 하나의 결괏값을 얻기 위해 사용한다. 수요일부터는 리액트를 배웠다. 처음에는 낯설어 적응하는 데 시간이 걸렸으나 적응하고 나니 신세계였다. 직관적이고 좀 더 간편하게 기능을 구현할 수 있었다. 전체적인 구조도 학습하면서 익히고 나니 데이터의 흐름이 한눈에 들어왔다. 고차 함수 때도 느꼈지만 각 기능들을 왜 사용하는지 목적을 아는 게 매우 중요했다. state는 사용자의 입력에 따라 변하는 데이터를 다루기 위해, props는 상위 컴포넌트의 데이터를 하위 컴포넌트로 전달하기 위해 사용한다. 기능을 이해하는 것 이상으로 사용 이유를 아는 것이 중요했다. + React with FastCampus(3) #React Component # JSX\n바벨은 우리가 작성한 JSX코드를 순수하게 실행 가능한 자바스크립트로 바꿔줌 가독성이 좋고, 컴파일 과정에서 문법적 오류를 인지하기 쉬워서 사용 컴포넌트 내부 문법 최상위 요소는 하나여야 함. 그래서 openTag와 closedTag 필수 최상위 요소를 리턴하는 경우, ()로 감싸야함 자식들을 바로 랜더링 하고 싶으면, \u0026lt;\u0026gt;자식들\u0026lt;/\u0026gt; 사용 \u0026lt;- Fragment {표현식} if문은 사용할 수 없어서, 삼항 연산자나 \u0026amp;\u0026amp; 사용 class 대신 className 자식 요소가 있으면 꼭 닫아야 하고 없으면 열면서 닫아야 함 Ex. \u0026lt;p\u0026gt;자식들\u0026lt;/p\u0026gt;, \u0026lt;p /\u0026gt; props와 state\nprops컴포넌트 외부에서 컴포넌트에 주는 데이터\nstate는 컴포넌트 내부에서 변경할 수 있는 데이터\n둘 다 변경이 일어나면, 랜더를 다시 할 수 있음\nRender 함수는 props와 state를 바탕으로 컴포넌트를 그림\n// props props === { message: \u0026#34;Hello\u0026#34;, name: \u0026#34;Yuchan\u0026#34; } const Component = (props) =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{props.message}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ) } Component.defaultProps = { message=\u0026#34;No message\u0026#34; name=\u0026#34;:(\u0026#34; } const ParentComponent = () =\u0026gt; ( \u0026lt;FunctionComponent message=\u0026#34;Hello\u0026#34; name=\u0026#34;Yuchan\u0026#34; /\u0026gt; )​ state는 훅을 걸어야지 함수 컴포넌트에서 사용 가능. 직접 바꾸면 안 되고 set함수의 인자로 변경될 값을 넣어야 함\nEvent Handling\ncamelCase로 사용\nEx. onClick, onMouseEnter 이벤트={함수} 형태\n실제 DOM 요소에만 사용 가능\nconst Component = () =\u0026gt; { \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; { console.log(\u0026#34;clicked\u0026#34;); }} \u0026gt; 클릭 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;; }; Component Lifecycle\n리액트 컴포넌트는 여러 지점에서 메소드를 오버 라이딩할 수 있게 해 줌\nDeclarative(선언적)\n// 1. 컴포넌트 생성 및 마운트 // (1) constructor // (2) getDerivedStateFromProps // (3) render // (3) componentDidMount // 2. 컴포넌트 props, state 변경 // (0) props에 state가 의존할 때 사용(with setState) static getDerivedStateFromProps(nextProps, preState) { return nextState } // (1) componentDidMount() {} // (2) shouldComponentUpdate(nextProps, nextState) { return true 랜더 진행 | false 랜더 안함 // default는 true } // (3) render() // (4) getSnapshotBeforeUpdate(prevProps, prevState) { return snapShot } // (5) componentDidUpdate(prevProps, prevState, snapShot) {} // 3. 정리할 내용 정리 // componentWillUnmount() { // Ex. clearInterval(this.interval) // } // getSnapshotBeforeUpdate(prevProps, prevState) { return 저장되는 스냅 샷 } let i = 0 const list = document.querySelector(\u0026#34;#liust\u0026#34;) class App extends React.Component { state = { list: [] } render() { return ( \u0026lt;div id=\u0026#34;list\u0026#34; style={{ height: 100, overflow: \u0026#34;auto\u0026#34; }}\u0026gt; {this.state.list.map(i =\u0026gt; { return \u0026lt;div\u0026gt;{i} })} \u0026lt;/div\u0026gt; ) } componentDidMount() { setInterval(() =\u0026gt; { this.setState(state =\u0026gt; ({ list: [...state.list, i++] })) }) } getSnapshotBeforeUpdate(prevProps, prevState) { if (prevState.list.length === this.state.list.length) return null return list.scrollHeight - list.scrollTop } componentDidUpdate(prevProps, prevState, snapShot) { if (snapshot === null) return list.scrollTop = list.sctollHeight - snapShot } } // componentDidCatch() {} class App extends React.component { state = { hasError: false }; render() { if (this.state.hasError) { return \u0026lt;div\u0026gt;에러 발생\u0026lt;/div\u0026gt;; } return \u0026lt;WebService /\u0026gt;; } componentDidCatch(error, info) { this.setState({ hasError: true }); } } // Error Boundaries(library)를 최상위 부보로 만들어야함​ Create React App # Create React App npx create-react-app 폴더명 npm run start npm run build npx serve -s build npm run test npm run eject eslint \u0026amp; prettier \u0026ldquo;eslintConfig\u0026rdquo;: {\n\u0026ldquo;extends\u0026rdquo;: [\n\u0026ldquo;react-app\u0026rdquo;,\n\u0026ldquo;react-app/jest\u0026rdquo;,\n// \u0026ldquo;prettier\u0026rdquo; // 충돌을 피하기 위해, prettier 확장 안 쓸 때\n]\n}, husky npm i husky -D npx husky install \u0026ldquo;script\u0026rdquo;: {\n\u0026ldquo;prepare\u0026rdquo;: \u0026ldquo;husky install\u0026rdquo; // 패키지 재설치 시 install 해주려고\n}, npx husky add .husky/pre-commit \u0026ldquo;npx lint-staged\u0026rdquo; lint-staged(Run linters on git staged files) npm i lint-staged -D \u0026ldquo;lint-staged\u0026rdquo;: {\n\u0026ldquo;**/*.js\u0026rdquo;: [\n\u0026ldquo;eslint \u0026ndash;fix\u0026rdquo;,\n\u0026ldquo;git add\u0026rdquo;\n]\n},\n// prettier안쓰면 개발 의존성으로 설치하고, \u0026ldquo;prettier \u0026ndash;write\u0026rdquo; 추가 React Router # Single Page Application\nReact Wep App을 다운 받고, 주소에 따른 컴포넌트를 라우터로 보여줌\nnpm i react-router-dom\nRouting\n특정 경로에서 보여줄 각각의 컴포넌트 제작 \u0026lt;BrowserRouter\u0026gt;\u0026lt;App /\u0026gt;\u0026lt;/BrowserRouter\u0026gt; \u0026lt;Switch\u0026gt;\u0026lt;Route exact path=\u0026quot;/\u0026hellip;\u0026quot; component={\u0026hellip;} /\u0026gt;\u0026lt;/Switch\u0026gt;\n*Switch는 순서 데로라 exact 꼭 필요하지는 않음\n*더 넓은 범위를 더 아래에 두고 루트 경로(/)는 exact사용 후 Not Found 컴포넌트 젤 아래에\n*경로 없이 Not Found 컴포넌트 제일 아래에 두면 됨 \u0026lt;Link to=\u0026quot;/\u0026hellip;\u0026quot;\u0026gt;\u0026lt;/Link\u0026gt;\n\u0026lt;NavLink\nexact to=\u0026quot;/\u0026hellip;\u0026quot;\nactiveClass=\u0026ldquo;active\u0026rdquo;\nactiveStyle={ color: \u0026ldquo;red\u0026rdquo; }\nisActive={(match, location) =\u0026gt; {\nreturn match !== null \u0026amp;\u0026amp; location.search === \u0026quot;\u0026quot;\n}}\n\u0026gt;\u0026lt;/NavLink\u0026gt; Dynamic Routing\n\u0026lt;Route exact path=\u0026#34;/profile/:userId\u0026#34; component={Profile} /\u0026gt; \u0026lt;Route exact path=\u0026#34;/about\u0026#34; component={About} /\u0026gt; export default function Profile(props) { const userId = props.match.params.userId return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Profile 페이지입니다.\u0026lt;/h2\u0026gt; {userId \u0026amp;\u0026amp; \u0026lt;p\u0026gt;userId는 {userId}입니다.\u0026lt;/P\u0026gt;} \u0026lt;/div\u0026gt; ) } // (npm i query-string) import queryString from \u0026#34;query-string\u0026#34; export default function About(props) { const searchPar ams = props.location.search const query = queryString.parse(searchParams) return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;About 페이지입니다.\u0026lt;/h2\u0026gt; {query.name \u0026amp;\u0026amp; \u0026lt;p\u0026gt;name은 {query.name}입니다.\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ) // /about?name=Yuchan HOC(Higher-Order Component)\n몇 단계 위의 props에 접근 import { withRouter } from \u0026#34;react-router-dom\u0026#34;; export default withRouter(function LoginButton(props) { function login() { // 추가 공부: history 객체 안의 속성 보기 props.history.push(\u0026#34;/\u0026#34;); } return \u0026lt;button onClick={login}\u0026gt;로그인\u0026lt;/button\u0026gt;; }); Redirect\nimport { Route, Redirect } from \u0026#34;react-router-dom\u0026#34;; const isLogin = true \u0026lt;Route path=\u0026#34;/login\u0026#34; render={() =\u0026gt; isLogin ? \u0026lt;Redirect to=\u0026#34;/\u0026#34; /\u0026gt; : \u0026lt;Login /\u0026gt;} /\u0026gt; ","date":"18 September 2021","permalink":"/posts/bootcamp/bc-4w-6/","section":"Posts","summary":"4주 차 정리 # 월요일에는 DOM의 이벤트에 대해 배우고, 혼자서 TypeScript를 학습했다.","title":"BC-4w-6 / 4주 차 정리 + {FC} React(3)"},{"content":"Today I learned #React props \u0026amp; state # props\n외부에서 전달받은 값 객체 형태 읽기 전용 function Parent() { return ( \u0026lt;div className=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;I\u0026#39;m the parent\u0026lt;/h1\u0026gt; \u0026lt;Child text={\u0026#34;I\u0026#39;m the eldest child\u0026#34;} /\u0026gt; // props 입력 \u0026lt;Child text={\u0026#34;I\u0026#39;m the youngest child\u0026#34;} /\u0026gt; \u0026lt;/div\u0026gt; ) } function Child(props) { // props 전달 return ( \u0026lt;div className=\u0026#34;child\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{props.text}\u0026lt;p\u0026gt; // props 랜더링 \u0026lt;/div\u0026gt; ) } state\n내부에서 변화하는 값 Ex. On/Off -\u0026gt; { isOn: true|false } Counter -\u0026gt; { count: n } // useState 불러옴 import React, { useState } from \u0026#34;react\u0026#34;; function CheckboxExample() { // const [state 저장 변수, state 갱신 함수] = useState(상태 초기 값) // state 변수는 React 함수가 끝나도 남아있음 const [isChecked, setIsChecked] = useState(false); // same with // const stateHookArray = useState(false) // const isChecked = stateHookArray[0] // const setIsChecked = stateHookArray[1] } const handleChecked = (event) =\u0026gt; { setIsChecked(event.target.checked); }; return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; checked={isChecked} onChange={handleChecked} /\u0026gt; \u0026lt;span\u0026gt;{isChecked ? \u0026#34;Checked!!\u0026#34; : \u0026#34;Unchecked\u0026#34;}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ); // state는 상태 변경 함수 호출로 변경해야 함(강제로 변경을 시도하면 안됨) 이벤트 처리\nReact에서 이벤트는 소문자 대신 카멜 케이스(camelCase)를 사용 JSX를 사용하여 문자열이 아닌 함수로 이벤트 처리 함수(Event handler)를 전달 function NameForm() { const [name, setName] = useState(\u0026#34;\u0026#34;); const handleChange = (event) =\u0026gt; { setName(event.target.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={name} onChange={handleChange}\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;button onClick={alert(name)}\u0026gt;Button\u0026lt;/button\u0026gt; \u0026lt;h1\u0026gt;{name}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } function App() { const [showPopup, setShowPopup] = useState(false); // !로 boolean on/off const togglePopup = (event) =\u0026gt; { setShowPopup(!showPopup); }; return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Fix me to open Pop Up\u0026lt;/h1\u0026gt; \u0026lt;button onClick={togglePopup} className=\u0026#34;open\u0026#34;\u0026gt; Open me \u0026lt;/button\u0026gt; {showPopup ? ( \u0026lt;div className=\u0026#34;popup\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;popup_inner\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Success!\u0026lt;/h2\u0026gt; \u0026lt;button className=\u0026#34;close\u0026#34; onClick={togglePopup}\u0026gt; Close me \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) : null} \u0026lt;/div\u0026gt; ); } Controlled Component\nReact가 state를 통제할 수 있는 컴포넌트 export default function App() { const [username, setUsername] = useState(\u0026#34;\u0026#34;); const [msg, setMsg] = useState(\u0026#34;\u0026#34;); return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;div\u0026gt;{username}\u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={username} onChange={(event) =\u0026gt; setUsername(event.target.value)} placeholder=\u0026#34;여기는 인풋입니다.\u0026#34; className=\u0026#34;tweetForm__input--username\u0026#34; \u0026gt;\u0026lt;/input\u0026gt; \u0026lt;div\u0026gt;{msg}\u0026lt;/div\u0026gt; \u0026lt;textarea placeholder=\u0026#34;여기는 텍스트 영역입니다.\u0026#34; className=\u0026#34;tweetForm__input--message\u0026#34; onChange={(event) =\u0026gt; setMsg(event.target.value)} value={msg} \u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;/div\u0026gt; ); } React 데이터 흐름\n컴포넌트를 만들고, 조립해서 페이지를 만듦(상향식) 컴포넌트는 단일 책임 원칙(하나의 컴포넌트는 하나의 일만 담당) 데이터는 위에서 아래로 흐름(props)(하향식) -\u0026gt; 단방향 데이터 흐름(one-way data flow) 상태(state)는 최소화하는 것이 좋음 부모로부터 props를 통해 전달됨 시간이 지나도 변하지 않음 컴포넌트 안의 다른 state나 props를 가지고 계산 가능함 하나의 상태를 기반으로 두 컴포넌트가 영향을 받는다면 이때는 공통 소유 컴포넌트를 찾아 그곳에 상태를 위치해야 함 React Twittler State \u0026amp; Props # 데이터는 하향식 전달, props는 상위의 데이터를 하위에 전달할 때 사용\nstate는 시용자의 입력에 따라 변하는 값을 처리할 때, 이벤트 함수와 함께 useState로 훅을 걸어서 사용\nReact.Fragment\nReact는 하나의 컴포넌트 만을 리턴할 수 있기 때문에 오픈, 클로즈 태그가 반드시 필요. 이때, React.Fragment로 감싸주면 쓸데없는 태그가 안 생긴다. 또한 map()을 사용할 때, key 값을 여기에 넣어줄 수 있다. \u0026lt;\u0026gt;\u0026lt;/\u0026gt;로 단축 사용도 가능하다. My Page\n과제를 끝내고 나서 다시 둘러보니 MyPage 부분이 마음에 들지 않았다. MyPage는 내가 작성한 글만 보여주는 것인데, 미리 정보가 입력되어있는 dummyData에서 정보를 끌어왔다. 그래서 내가 Tweet 부분에서 새로 만든 state가 반영되지 않았다. 하향식 단방향 데이터 흐름을 지닌 React에서는 데이터를 형제 요소에게 보내는 것이 힘들었다. 잠시 생각해보니 반대로 부모 요소가 데이터를 가지고 있으면 해결될 문제였다. 그래서 부모 요소인 App에서 Hook(useState)을 걸어, 그 state와 setState를 하위 요소로 props로 보내서 사용했다.\n// App.js const [tweets, setTweets] = useState(dummyTweets); const [username, setUsername] = useState(\u0026#34;parkhacker\u0026#34;); const [msg, setMsg] = useState(\u0026#34;\u0026#34;); // Tweets.js const handleButtonClick = () =\u0026gt; { const tweet = { id: props.tweets.length + 1, username: props.username, picture: \u0026#34;https://randomuser.me/api/portraits/men/98.jpg\u0026#34;, content: props.msg, createdAt: Date(), updatedAt: Date(), }; props.setTweets([tweet, ...props.tweets]); }; const handleChangeUser = (event) =\u0026gt; { props.setUsername(event.target.value); }; const handleChangeMsg = (event) =\u0026gt; { props.setMsg(event.target.value); }; // MyPage.js const filteredTweets = props.tweets.filter( (item) =\u0026gt; item.username === props.username ); 추가로 MyPage의 필터를 사용자가 입력한 props.username으로 하였는데 이때, username만 바꾸고 tweet을 보내지 않은 다음에 마이페이지를 누르면 에러가 났다(아직 입력되어있는 username은 정보를 전혀 가지고 있지 않아서). 그래서 초기값을 삼항 연산자를 이용해 정해줬다.\nconst profile = filteredTweets.length !== 0 ? filteredTweets[0].picture : \u0026#39;https://randomuser.me/api/portraits/men/98.jpg\u0026#39;​ Advanced\n필터 구현하기\nconst [filter, setFilter] = useState(\u0026#34;none\u0026#34;) const handleChangeFilter = (event) =\u0026gt; { setFilter(event.target.value) } // selector에 중복되는 유저 이름이 모두 보여서, lodash의 uniqBy로 중복 요소 제거 const filterArr = _.uniqBy(props.tweets, \u0026#34;username\u0026#34;) ... \u0026lt;div className=\u0026#34;tweet__selectUser\u0026#34;\u0026gt; \u0026lt;select onChange={handleChangeFilter}\u0026gt; \u0026lt;option value=\u0026#34;none\u0026#34;\u0026gt;-- click to filter tweets by username --\u0026lt;/option\u0026gt; {filterArr.map(item =\u0026gt; ( \u0026lt;option value={item.username}\u0026gt;{item.username}\u0026lt;/option\u0026gt; ))} \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;ul className=\u0026#34;tweets\u0026#34;\u0026gt; {props.tweets.filter(item =\u0026gt; filter === \u0026#34;none\u0026#34; ? item === item : item.username === filter ).map(item =\u0026gt; ( \u0026lt;Tweet tweet={item} key={item.id} /\u0026gt; ) )} \u0026lt;/ul\u0026gt; 트윗 삭제\n// Tweet.js const handleButtonRemove = (event) =\u0026gt; { console.log(props.tweets) props.setTweets(props.tweets.filter(item =\u0026gt; item.id !== Number(event.target.dataset.id) )) // 삭제 후 트윗을 작성했을 때, id가 중복되는 문제 // bcs, 새 트윗을 작성할 때 트윗의 length + 1을 해서 // 삭제할 때, id를 재설정해서 해결 for (let i = 0; i \u0026lt; props.tweets.length; i++) { props.tweets[i].id = i } } ... \u0026lt;i // id와 event의 target을 매칭 문제는 data attribute로 해결 data-id={props.tweet.id} onClick={handleButtonRemove} className=\u0026#34;far fa-trash-alt\u0026#34; \u0026gt;\u0026lt;/i\u0026gt;​ Today\u0026rsquo;s takeaway # 전체적인 구조와 흐름을 아는 것이 많은 도움이 되었다. 문제가 생겼을 때 흐름을 통해 해결법을 쉽게 찾을 수 있었다. props는 상위 컴포넌트에서 하위 컴포넌트로 데이터를 넘겨주고, state는 컴포넌트 내에서 사용자의 입력에 따라 데이터를 변경할 수 있다. 상위 컴포넌트에서 hook(useState)을 사용하고 props를 사용하여 하위 컴포넌트에서 state를 이벤트를 이용해서 사용하면, 상향식 데이터 흐름처럼 보이게 사용할 수 있다. Weekend I\u0026rsquo;ll learn # 이때까지 공부했던 내용들을 총 복습하며 문제도 다시 다 풀어보고, 블로그와 WIL도 정비할 것이다. 패스트 캠퍼스 프런트 앤드 강의를 가능한데까지 볼것이다. 최소한 React와 관련된 부분은 다 볼것이다. ","date":"17 September 2021","permalink":"/posts/bootcamp/bc-4w-5/","section":"Posts","summary":"Today I learned #React props \u0026amp; state # props","title":"BC-4w-5 / [React] props, state"},{"content":"Today I learned #SPA # 전통적인 웹사이트는 페이지 전체를 로딩 SPA는 Menu와 Footer와 같이 페이지 전환 전후에 중복되는 부분은 새로 불러오지 않음 SPA는 무거운 JS 파일을 기다리는 시간으로 인해 첫 화면의 로딩 시간이 길어짐 SPA는 검색 엔진 최적화(SEO)가 좋지 않음(구글 등이 HTML을 기반으로 자료 수집) React Router # npm i react-router-dom 라우팅(Routing) 경로(주소)에 따라 다른 뷰를 보여줌 \u0026lt;BrowserRouter\u0026gt; \u0026lt;App /\u0026gt;을 감쌈 \u0026lt;Switch\u0026gt; Route를 감쌈 \u0026lt;Route\u0026gt; exact 속성은 정확한 주소 매칭 path 속성에 경로 \u0026lt;Link\u0026gt; to 속성에 path의 경로 Ex.\nimport { BrowserRouter } from \u0026ldquo;react-router-dom\u0026rdquo;\nimport { Switch, Route, Link } from \u0026ldquo;react-router-dom\u0026rdquo; React Twittler SPA # index.js\nimport React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import { BrowserRouter } from \u0026#34;react-router-dom\u0026#34;; // React Router import App from \u0026#34;./App\u0026#34;; ReactDOM.render( // 라우터 역할 \u0026lt;BrowserRouter\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/BrowserRouter\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;) ); App.js\nimport React from \u0026#34;react\u0026#34;; import \u0026#34;./App.css\u0026#34;; import { Switch, Route } from \u0026#34;react-router-dom\u0026#34;; // React Router import Navbar from \u0026#34;./Navbar\u0026#34;; import Tweets from \u0026#34;./Pages/Tweets\u0026#34;; import MyPage from \u0026#34;./Pages/MyPage\u0026#34;; import About from \u0026#34;./Pages/About\u0026#34;; const App = () =\u0026gt; { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;main\u0026gt; \u0026lt;Navbar /\u0026gt; \u0026lt;section className=\u0026#34;features\u0026#34;\u0026gt; // Route를 묶는 Switch \u0026lt;Switch\u0026gt; {\u0026#34; \u0026#34;} // 주소별 경로는 Route \u0026lt;Route exact path=\u0026#34;/\u0026#34;\u0026gt; {\u0026#34; \u0026#34;} \u0026lt;Tweets /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;Route exact path=\u0026#34;/about\u0026#34;\u0026gt; \u0026lt;About /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;Route exact path=\u0026#34;/mypage\u0026#34;\u0026gt; \u0026lt;MyPage /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;/Switch\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;/div\u0026gt; ); }; export default App; Navbar.js\nimport React from \u0026#34;react\u0026#34;; import { Link, NavLink } from \u0026#34;react-router-dom\u0026#34;; const Navbar = () =\u0026gt; { return ( \u0026lt;section className=\u0026#34;Navbar\u0026#34;\u0026gt; {\u0026#34; \u0026#34;} // Link는 그냥 연결, NavLink는 특별한 기능 가능 \u0026lt;Link to=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;i className=\u0026#34;far fa-comment-dots\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/Link\u0026gt; \u0026lt;NavLink exact to=\u0026#34;/about\u0026#34; activeClassName=\u0026#34;selectedPage selectedPage--about\u0026#34; \u0026gt; \u0026lt;i className=\u0026#34;far fa-question-circle\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/NavLink\u0026gt; \u0026lt;NavLink exact to=\u0026#34;/mypage\u0026#34; activeClassName=\u0026#34;selectedPage selectedPage--mypage\u0026#34; \u0026gt; \u0026lt;i className=\u0026#34;far fa-user\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/NavLink\u0026gt; \u0026lt;i onClick={() =\u0026gt; history.back()} className=\u0026#34;far fa-arrow-left\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; // history \u0026lt;/section\u0026gt; ); }; export default Navbar; Advanced\nHistory API NavLink + React with FastCampus(2) # class 컴포넌트\nclass ClassComponent extends React.Component { render() { return \u0026lt;div\u0026gt;Hello\u0026lt;/div\u0026gt;; } } function 컴포넌트\n// (1) function FunctionComponent() { return \u0026lt;div\u0026gt;Hello\u0026lt;/div\u0026gt;; } // (2) const FunctionComponent = () =\u0026gt; \u0026lt;div\u0026gt;Hello\u0026lt;/div\u0026gt;; React.createElement\nReact.CreateElement( type, // 태그 이름 문자열 | 리액트 컴포넌트 | React.Fragment [props], // 리액트 컴포넌트에 넣어주는 데이터 객체 [...children] // 자식으로 넣어주는 요소들 ) // 1. 태그 이름 문자열 type ReactDOM.render( React.createElement(\u0026#39;h1\u0026#39;, null, `type이 \u0026#34;태그 이름 문자열\u0026#34; 입니다.`), document.querySelector(\u0026#39;#root\u0026#39;) ) // 2. 리액트 컴포넌트 type const Component = () =\u0026gt; ( React.createElement( \u0026#39;p\u0026#39;, null, `type이 \u0026#34;리액트 컴포넌트\u0026#34; 입니다.` ) ) ReactDOM.render( React.createElement(Component, null, null), document.querySelector(\u0026#39;#root\u0026#39;) ) // 3. React.Fragment type // 태그가 없이 그냥 children에 요소 넣어줌 ReactDOM.render( React.createElement( React.Fragment, null, `type이 \u0026#34;React Fragment\u0026#34; 입니다.`), document.querySelector(\u0026#39;#root\u0026#39;) ) // 4. 복잡한 리액트 엘리먼트 모임 ReactDOM.render( React.createElement( \u0026#39;div\u0026#39;, null, React.createElement(...)), // 여기에 계속 넣어줘야함 document.querySelector(\u0026#39;#root\u0026#39;) ) Today\u0026rsquo;s takeaway # 오늘은 리액트의 라우터에 대해 배웠다. 어제는 리액트가 낯설어서 매우 힘들었는데 하루 봤다고 오늘은 많이 친해졌다. 지난주에 Vanilla JS만 배우고 혼자서 웹페이지를 만들려다 실패한 적이 있다. 해결법을 찾아서 검색했을 때, 대부분이 리액트로 해결하였고, 나는 리액트를 배우는 날을 기다렸다. 오늘 라우터를 배우고 나니 그때 실패하였던 웹페이지를 만들 수 있게 되었다. 오늘 리액트를 배우면서 느낀 점은 매우 잘 만들어진 라이브러리라는 것이다. 기능과 구조를 한눈에 파악할 수 있다니, 절친이 될 수 있을 거 같다. 특히 컴포넌트를 하나씩 구성해서 내가 원하는 데로 배치하고, 재활용할 수 있는 점이 매력적이었다. Tomorrow I\u0026rsquo;ll learn # React State \u0026amp; Props 두 객체 모두 렌더링 결과물에 영향을 주는 정보를 갖고 있음 props는 함수 매개변수처럼 컴포넌트에 전달 state는 함수 내에 선언된 변수처럼 컴포넌트 안에서 관리됨 ","date":"16 September 2021","permalink":"/posts/bootcamp/bc-4w-4/","section":"Posts","summary":"Today I learned #SPA # 전통적인 웹사이트는 페이지 전체를 로딩 SPA는 Menu와 Footer와 같이 페이지 전환 전후에 중복되는 부분은 새로 불러오지 않음 SPA는 무거운 JS 파일을 기다리는 시간으로 인해 첫 화면의 로딩 시간이 길어짐 SPA는 검색 엔진 최적화(SEO)가 좋지 않음(구글 등이 HTML을 기반으로 자료 수집) React Router # npm i react-router-dom 라우팅(Routing) 경로(주소)에 따라 다른 뷰를 보여줌 \u0026lt;BrowserRouter\u0026gt; \u0026lt;App /\u0026gt;을 감쌈 \u0026lt;Switch\u0026gt; Route를 감쌈 \u0026lt;Route\u0026gt; exact 속성은 정확한 주소 매칭 path 속성에 경로 \u0026lt;Link\u0026gt; to 속성에 path의 경로 Ex.","title":"BC-4w-4 / [React] Router + {FC} React(2)"},{"content":"Today I learned #React Intro # React\n프런트 앤드 개발을 위한 JS 오픈소스 라이브러리 선언형 하나의 파일에 명시적으로 작성(JSX 활용) 컴포넌트 기반 컴포넌트는 하나의 기능 구현을 위해 여러 코드를 묶어둔 것(독립적, 재사용 가능) 범용성 JS 프로젝트 어디든 유연하게 적용 가능(프레임 워크(Ex. angular)는 생태계에 존속) JSX\nJavaScript + XML DOM: HTML+CSS+JS\nReact DOM: CSS+JSX 오프닝 태그와 클로징 태그로 감싸야 함 CSS class 속성은 className으로 표기(class는 JS 클래스로 인식) JS 표현식 사용 시, 중괄호({}) 이용 React 요소를 JSX로 작성 시, 대문자로 시작(사용자 정의 컴포넌트) 조건부 렌더링은 if 문이 아닌 삼항 연산자 사용 React에서 여러 개의 HTML 요소를 표시할 때는, map() 사용(반드시 \u0026ldquo;key(고유한 id 값)\u0026rdquo; JSX 속성을 넣어야 함) const posts = [ { id: 1, title: \u0026#34;Hello World\u0026#34;, content: \u0026#34;Welcome to React!\u0026#34; }, { id: 2, title: \u0026#34;Installation\u0026#34;, content: \u0026#34;Install React\u0026#34; }, { id: 3, title: \u0026#34;Practice\u0026#34;, content: \u0026#34;Practice React\u0026#34; }, ]; // JSX 요소(컴포넌트)는 대문자로 시작 export default function Blog() { // {JS 표현식} // map으로 요소 나열( .map(() =\u0026gt; ()) ) const blogs = posts.map((post) =\u0026gt; ( // 오프닝 태그, key 값\u0026lt;h3\u0026gt;{post.title}\u0026lt;/h3\u0026gt; \u0026lt;div key={post.id}\u0026gt; \u0026lt;p\u0026gt;{post.content}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; )); // className return \u0026lt;div className=\u0026#34;post-wrapper\u0026#34;\u0026gt;{blogs}\u0026lt;/div\u0026gt;; } Create React App\nSPA를 쉽고 빠르게 만들 수 있도록 만들어진 툴 체인 npx create-react-app 폴더명 Font Awesome\nnpm i @fortawesome/fontawesome-svg-core npm i @fortawesome/free-solid-svg-icons @fortawesome/free-regular-svg-icons @fortawesome/free-brands-svg-icons npm i @fortawesome/react-fontawesome import { FontAwesomeIcon } from \u0026#34;@fortawesome/react-fontawesome\u0026#34; import { faCamera } from \u0026#34;@fortawesome/free-solid-svg-icons\u0026#34; export default () =\u0026gt; \u0026lt;FontAwesomeIcon icon={faCamera} className=\u0026#34;fas faCamera\u0026#34; /\u0026gt;​ *props link\nReact Twittler Intro #// index.js import React from \u0026#34;react\u0026#34;; // 리액트 컴포넌트 만들기 import ReactDOM from \u0026#34;react-dom\u0026#34;; // 리액트 컴포넌트 -\u0026gt; HTML import App from \u0026#34;./App\u0026#34;; // App.js -\u0026gt; index.js // HTML에 연결 ReactDOM.render(\u0026lt;App /\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;)); // App.js import React from \u0026#34;react\u0026#34;; // React 컴포넌트 만들기 import \u0026#34;./App.css\u0026#34;; // CSS 연결 import { dummyTweets } from \u0026#34;./static/dummyData\u0026#34;; // Footer 컴포넌트 const Footer = () =\u0026gt; { return \u0026lt;footer\u0026gt;Copyright 2021\u0026lt;/footer\u0026gt;; }; / Tweets 컴포넌트 const Tweets = () =\u0026gt; { return ( // map()으로 반복 요소 처리 \u0026lt;ul className=\u0026#34;tweets\u0026#34;\u0026gt; {dummyTweets.map((tweet) =\u0026gt; { const isParkHacker = tweet.username === \u0026#34;parkhacker\u0026#34;; const tweetUserNameClass = isParkHacker ? \u0026#34;tweet__username tweet__username--purple\u0026#34; : \u0026#34;tweet__username\u0026#34;; return ( \u0026lt;li className=\u0026#34;tweet\u0026#34; key={tweet.id}\u0026gt; \u0026lt;div className=\u0026#34;tweet__profile\u0026#34;\u0026gt; \u0026lt;img src={tweet.picture}\u0026gt;\u0026lt;/img\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;tweet__content\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;tweet__userInfo\u0026#34;\u0026gt; \u0026lt;span className={tweetUserNameClass}\u0026gt;{tweet.username}\u0026lt;/span\u0026gt; \u0026lt;span className=\u0026#34;tweet__createdAt\u0026#34;\u0026gt;{tweet.createdAt}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;tweet__message\u0026#34;\u0026gt;{tweet.content}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; ); })} \u0026lt;/ul\u0026gt; ); }; // App 컴포넌트 const App = () =\u0026gt; { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Tweets /\u0026gt; \u0026lt;Features /\u0026gt; \u0026lt;/div\u0026gt; ); }; // 컴포넌트들 한 번 이상 export 해줘야 함 export { App, Tweets, Footer }; + React with FastCampus(1) # React basic\n엥귤러는 프레임 워크, 뷰는 중간, 리엑트는 라이브러리 컴포넌트는 특정 기능을 하는 사용자 정의 태그 Virtual DOM으로 이전 상태와 이후 상태를 비교하여, 바뀐 부분을 자동으로 바꿈\n(State Change -\u0026gt; Compute Diff -\u0026gt; Re-render) Client Side Rendering(CSR) JS 전부 다운되기 전까지 화면 보이지 않음(사용 불가능) Server Side Rendering(SSR) JS 전부 다운되기 전에 일부 화면 볼 수 있음(사용 불가능) import React from \u0026#34;react\u0026#34;; // 리액트 컴포넌트 만들기 import ReactDOM from \u0026#34;react-dom\u0026#34;; // 리액트 컴포넌트 -\u0026gt; HTML import \u0026#34;./index.css\u0026#34;; import App from \u0026#34;./App\u0026#34;; import reportWebVitals from \u0026#34;./reportWebVitals\u0026#34;; // 시작 함수, 리액트 컴포넌트를 연결 ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, // 실제 DOM(HTML) document.getElementById(\u0026#34;root\u0026#34;) ); reportWebVitals(); Today\u0026rsquo;s takeaway # 리엑트를 공부했다. 아직 많이 낯설다. 하지만 직관적이라 익숙해지면 웹을 훨씬 쉽고 이쁘게 꾸밀 수 있을 거 같다. 따로 강의를 추가로 들으면서 따라가고 있다. 어드벤스 과제에서 아직 배우지 않는 내용을 이용해야해서 매우 힘들었다. 직접 실습하며 계속해서 구조를 만져보고 있는 중이라 따로 정리할 시간이 부족했다. Tomorrow I\u0026rsquo;ll learn # React Router에 대해 배울 것이다. 라우팅은 다른 주소에 다른 화면을 보여주는 것이다. ","date":"15 September 2021","permalink":"/posts/bootcamp/bc-4w-3/","section":"Posts","summary":"Today I learned #React Intro # React","title":"BC-4w-3 / [React] Intro + {FC} React(1)"},{"content":"Today I learned #고차함수 # 일급 객체(first-class citizen) -\u0026gt; Ex. 함수 변수에 할당(assignment) 가능 -\u0026gt; 함수 표현식 다른 함수의 인자(argument)로 전달 가능 -\u0026gt; 콜백 함수 다른 함수의 결과로 리턴(return) 가능 -\u0026gt; 커리 함수 고차 함수(higher-order function) 함수를 인자로 받는 함수 + 함수를 리턴하는 함수 고차 함수 문제 # 05\nfunction func(func1, func2) { return (num) =\u0026gt; func1(func2(num)); } // func(func1, func2)은 함수를 리턴 // func(func1, func2)(num)은 값을 리턴 06\nfunction func(...funcs) { // ...funcs는 나머지 인자들, funcs는 인자들의 배열 return (num) =\u0026gt; { let result = num; // 계속 누적해서 둘러쌈 // item은 함수 for (item of funcs) { result = item(result); } return result; }; } 08\nfunction func(func, arr) { let result = []; for (let item of arr) { result.push(func(item)); } return result; } 13\nfunction func_r(arr, num) { return arr.filter((item) =\u0026gt; item \u0026lt; num).length; } // 배열을 추가한다고 가정이었는데 배열의 추가에 너무 집착! 14\nfunction firstFunc(num) { return num \u0026lt; 100; } function func(obj, key) { if (Array.isArray(obj[key])) { return obj[key] .filter((item) =\u0026gt; typeof item === \u0026#34;number\u0026#34;) .filter((item) =\u0026gt; innerFunc(item)); } return []; } function func_r(obj, key) { if (Array.isArray(obj[key])) { return obj[key].filter( // \u0026amp;\u0026amp;로 간단히, firstFunc는 boolean을 return (item) =\u0026gt; typeof item === \u0026#34;number\u0026#34; \u0026amp;\u0026amp; firstFunc(item) ); } return []; } 21\nfunction func(arr) { const result = []; arr.forEach((item) =\u0026gt; { // map으로 바로 배열로 만들면 원본 길이만큼 무조건 만들어짐 // 그래서 PUSH로 새로운 배열을 만듬 if (item.age \u0026gt;= 18) { result.push(item.name); } }); return result; } function func_r(arr) { // 메소드 체이닝, 필터로 먼저 거르고 맵으로 배열로 만듦 return arr.filter((item) =\u0026gt; item.age \u0026gt;= 18).map((item) =\u0026gt; item.name); } 26\nfunction func_r(records, value) { return records.reduce((acc, cur) =\u0026gt; { if (cur.animal === value) { // 특정 조건일 때, return acc + cur.score; // return 값이 acc에 대입 } else { return acc; // 변화X } }, 0); // 앞에 0을 두고 쌓음! } 27\nfunction func(arr) { return arr.reduce((acc, cur) =\u0026gt; { if (acc.length \u0026gt;= cur.length) { return acc; } else { return cur; } }, \u0026#34;\u0026#34;); // \u0026#39;\u0026#39;을 시작으로 더 큰 값이 있으면 바꿈! } 29\nfunction func(arr) { const result = []; arr.forEach((item) =\u0026gt; result.push(...item)); return result; } function func_r(arr) { return arr.reduce((acc, cur) =\u0026gt; { return acc.concat(cur); }); } 30\nfunction mine_1(arr) { const onlyStr = arr.filter((item) =\u0026gt; typeof item === \u0026#34;string\u0026#34;); const newArr = onlyStr.map((item) =\u0026gt; item.length).sort((a, b) =\u0026gt; a - b); // 오름차순 정리 const minLength = newArr[0]; const result = onlyStr.find((item) =\u0026gt; item.length === minLength); return result ? result : \u0026#34;\u0026#34;; } function mine_2(arr) { const onlySrt = arr.filter((item) =\u0026gt; typeof item === \u0026#34;string\u0026#34;); if (onlySrt.length !== 0) { return onlySrt.reduce((acc, cur) =\u0026gt; { if (acc.length \u0026lt;= cur.length) { return acc; } else { return cur; } }); } return \u0026#34;\u0026#34;; } 31\nfunction func(arr) { return arr .filter((item) =\u0026gt; item.gender === \u0026#34;female\u0026#34;) .map((item) =\u0026gt; { // 재할당 item.grades = item.grades.reduce((acc, cur) =\u0026gt; acc + cur) / item.grades.length; return item; }); } 32\nfunction func(arr) { const newArr = []; arr.forEach((item) =\u0026gt; newArr.push(...item)); const onlyNum = newArr.filter((item) =\u0026gt; typeof item === \u0026#34;number\u0026#34;); return onlyNum.reduce((acc, cur) =\u0026gt; acc + cur, 0); } 기존 요소를 변경하지 않고, 다른 길이의 배열을 리턴할 때는 filter()\n기존 요소를 변경하면서, 같은 길이의 배열을 리턴할 때는 map()\n하나의 응축된 값을 리턴할 때는 reduce()\nToday\u0026rsquo;s takeaway # 고차 함수는 내 예상보다 훨씬 어려웠다. 문제는 어찌어찌 풀었으나 완전히 이해하지 못하였고, 완벽한 이해를 위해 문제를 다시 한번 풀어보며 메소드들을 익혔다. 메소드의 특징을 이해하고 나니 어떤 목적을 위해 어떤 메소드를 써야 하는지 쉽게 알 수 있었다. 기능의 사용법 못지않게 사용 이유도 중요하다는 것을 깨달았다. 고차 함수를 정리하는데 많은 시간을 소모해서 SCSS를 공부하지 못했다. 다행히 다음 주가 추석이라 추석 때 혼자서 FastCampus의 react와 scss를 공부할 것이다. 추가로 이때까지 코드 스테이츠에서 공부한 것도 모두 복습할 것이다. Tomorrow I\u0026rsquo;ll learn # 드디어 리액트를 배운다. 처음으로 조금도 공부하지 않은 부분이라 많은 기대가 된다. 리액트는 싱글 페이지 애플리케이션이나 모바일 애플리케이션 개발에 사용될 수 있다. ","date":"14 September 2021","permalink":"/posts/bootcamp/bc-4w-2/","section":"Posts","summary":"Today I learned #고차함수 # 일급 객체(first-class citizen) -\u0026gt; Ex.","title":"BC-4w-2 / [JS/Node] 고차 함수"},{"content":"Today I learned #DOM API 정리 # childrenNodes는 텍스트와 태그가 섞여 있을 때 사용 dataset \u0026lt;tag data-user|role|user-id=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/tag\u0026gt;\n// tagEl.dataset.user|role|userId 좌표 정보: offsetTop, offsetLeft scrollTop, scrollLeft clientTop, clientLeft 위치 정보: offsetWidth, offsetHeight scrollWidth, scrollHeight clientWidth, clientHeight event.target은 해당 이벤트의 대상 요소를 선택 + TypeScript with FastCampus # JavaScript는 Dynamic Types, TypeScript는 Static Types\n즉, JS는 실행하기 전까지 에러를 알 수가 없음 타입은 해당 변수가 할 수 있는 일을 결정 TypeScript는 structural type system(구조가 같으면 같은 타입) 데이터의 타입이 같거나 서브 타입인 경우, 할당 가능 -\u0026gt; 공변\n함수의 매개변수 타입이 같거나 슈퍼 타입인 경우, 할당 가능 -\u0026gt; 반병 Today\u0026rsquo;s takeaway # 주말에 이전 기수들의 프로젝트를 보았을 때, 잘 만든 팀들은 전부 타입 스크립트를 사용하였길래 무엇인지 알아보니 코딩의 안정성을 높여주는 매력적인 언어라 공부해야겠다고 마음먹었었다. 마침 오늘 코드 스테이츠 일정이 여유로워서 빨리 끝내고, 혼자서 타입 스크립트를 공부했다. 기본적으로 자바 스크립트와 크게 다르지 않아서 어렵지 않게 배울 수 있었다. 하지만 아직 실전에서 사용해 보거나, 문제를 풀어본 적이 없어서 체화의 기회는 없었다. 원래 코딩을 할 때도 edge case를 찾으려고 애쓰면서 하는데, 오류를 최대한 줄일 수 있는 타입 스크립트는 나에게 정말 매력적인 언어였다. 코드를 작성하는 와중에 오류가 계속 보이니 코드의 흐름을 좀 더 쉽게 이해하면서 작성할 수 있었다. 영어 공부도 열심히 해야 하는데 코딩 공부가 너무 재미있어서 진도가 거의 나가지 않았다. 듣기 조금과 단어 조금 외운 것이 전부다. 밸런스를 찾을 수 있게 신경 써야겠다. Tomorrow I\u0026rsquo;ll learn # 내일은 JS 고차 함수를 배운다. 이름만 보고 겁먹었는데, 내용을 보니 이미 사용해보았던 콜백 함수나 배열의 메소드들 이여서 어렵지 않게 진행할 수 있을 거 같다. 혹시 빠르게 끝낸다면 혼자서 SCSS를 공부할 예정이다. 모래 react를 배우는데, 그전에 SCSS까지는 혼자 공부를 끝내고 싶다. ","date":"13 September 2021","permalink":"/posts/bootcamp/bc-4w-1/","section":"Posts","summary":"Today I learned #DOM API 정리 # childrenNodes는 텍스트와 태그가 섞여 있을 때 사용 dataset \u0026lt;tag data-user|role|user-id=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/tag\u0026gt;","title":"BC-4w-1 / [JS/브라우저] DOM(2) + {FC} TypeScript"},{"content":"","date":null,"permalink":"/tags/dom/","section":"Tags","summary":"","title":"DOM"},{"content":"3주 차 정리 # 이번 주는 전체적으로 평이한 난이도였다. JS 기본을 마무리하고(객체, 자료형, 스코프, 클로저, DOM), CSS 중급(플렉스)을 다루어 봤다. 개발자의 글쓰기(김철수)를 완독하고 간략하게 정리했다. 페어 프로그래밍을 하다 보면 가끔 설명 능력이 많이 부족한 페어를 만나기도 한다. 그런 분들이 이 책을 읽는다면 많은 도움이 될 것 같다. 그저 글 쓰는 법이 아닌 잘 요약하고 전달하는 법을 설명해 주기 때문이다. 현재 나에게는 변수명, 함수명을 짓는 법 부분이 가장 도움이 되고 있다. 나중에 취업하면 다른 부분도 많은 도움이 될 것 같다. 이번 주에는 프로젝트에 대한 구상에 가장 많은 시간을 할애했다. 아직 뭘 할지도, 뭘 할 수 있는지도, 누구와 하게 될지도 모르지만 최소한 미리 몇 개의 아이디어는 가진 상태로 프로젝트를 시작하고 싶었다. 우선 정보 수집을 위해 코드 스테이츠 유튜브에 올라온 이전 기수들의 프로젝트 발표 영상들을 봤다. 당장 사용해도 될 만큼 잘 만든 팀들도 있었고, 많이 부족한 팀들도 있었다. 대부분의 팀들이 과정에 없는 기술도 추가로 사용한 것을 보고 나도 무엇을 만들지 어느 정도 구상한 다음 틈틈이 관련 기술을 추가로 공부해야겠다고 생각했다. 몇 개의 아이디어를 떠올렸지만 대부분은 기술적으로도, 시간적으로도 아직 구현이 불가능한 아이디어들이었다. 그래서 다시 근본으로 돌아가 무엇을 만들고 싶은지 깊이 고민해 봤다. 내가 배운 기술들을 잘 보여줄 수 있는 웹? 사업화가 가능한 웹? 한참의 고민 끝에 내가 내린 결론은 자주 방문하지는 않더라도 무언가 특정한 목적을 위해서는 방문해야 하는 또는 방문하고 싶은 웹을 만들고 싶다는 것이다. 일단 일상 속의 작은 불편함을 해결해 보는 방향으로도 생각해보았는데, 내가 워낙 불편한 게 없이 상황에 적응하며 사는 사람이라 친구와 부모님께 물어보며 불편들을 찾았다. 아직 이렇다 할 아이디어는 떠올리지 못했지만 방향성은 잡은 거 같으니 남은 시간 동안 잘 생각해 보아겠다. 반응형 내비게이션 바 만들기 # media query라는 것을 이용해 반응형 내비게이션 바를 만들었다. 처음 이용해 보았는데 아주 요긴하게 쓸 것 같다. root를 이용해 property를 관리하는 법을 배웠다. 이 역시 처음 이용해 보았는데 해당 CSS의 색과 값들을 미리 지정하고, 언제든지 일괄 변경이 가능해서 작성과 관리에 도움이 많이 될 것이다. 이번 주는 다른 일정이 바빠서 내비게이션 바만 만들었지만 다음번에는 각 메뉴들도 만들 것이다. ","date":"12 September 2021","permalink":"/posts/bootcamp/bc-3w-6/","section":"Posts","summary":"3주 차 정리 # 이번 주는 전체적으로 평이한 난이도였다.","title":"BC-3w-6 / 3주 차 정리, 반응형 내비게이션 바 만들기"},{"content":"Today I learned #DOM 이해하기 # Document Object Model의 약자로, HTML 요소를 Object처럼 조작할 수 있는 Model\n\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt;는 등장과 함께 실행 즉 순서상의 문제 발생 defer를 DOM 전체가 필요한 스크립트나 실행 순서가 중요한 경우에 적용 async는 방문자 수 카운터나 광고 관련 스크립트같이 독립적인 스크립트에 혹은 실행 순서가 중요하지 않은 경우에 적용 DOM은 document 객체에 구현되어 있음 console.dir은 DOM을 객체의 모습으로 출력 node.children은 자식 요소 조회 node.parentElement은 부모 요소 조회 DOM으로 HTML 조작하기 # CREATE - createElement\nREAD - querySelector, querySelectorAll\nUPDATE - textContent, id, classList, setAttribute\nDELETE - remove, removeChild, innerHTML = \u0026quot;\u0026quot; , textContent = \u0026quot;\u0026quot;\nAPPEND - append, appendChild\nparentEl = document.querySelector(\u0026#34;.parent\u0026#34;); childrenEls = document.querySelectorAll(\u0026#34;.parent .children\u0026#34;); while (parentEl.firstElementChild) { parentsEl.removeChild(parentsEl.firstElementChild); } while (parentsEl.children.length \u0026gt; 0) { parentsEl.removeChild(parentsEl.lastElementChild); } childrenEls.forEach(function (children) { children.remove(); }); for (let item of childrenEls) { item.remove(); } 유효성 검사(Form validation) # .onkeyup = function() {} .onclick = function() {} 이벤트 속성(onclick)에 이벤트 핸들러를 등록할 때에는 함수 그 자체로 등록해야 함. 함수 실행을 등록하는 것이 아님 function handler() {}\nbtn.onclick = handler \u0026mdash;(O)\nbtn.onclick = handler() \u0026mdash;(X) /^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[@$!%*#?\u0026amp;])[A-Za-z\\d@$!%*#?\u0026amp;]{8,}/.test(str) 8글자 이상이면서, 소문자와 대문자, 숫자 및 특수문자(!@#$%\u0026amp;*?) 하나 이상 포함 Today\u0026rsquo;s takeaway # 이미 배웠던 내용이지만 실습을 통해 한 번 더 복기할 수 있었다. 정규 표현식을 활용하여 유효 검사를 하는 법을 배웠다. 이미 알던 내용이지만 직접 사용하는 것을 보고 어떻게 활용할 수 있는지를 알았다. 오늘 페어 프로그래밍 직전에 페어가 갑자기 중도 포기를 했다. 갑작스러웠지만 혼자서 잘 해낼 수 있었다. Weekend I\u0026rsquo;ll learn # CSS를 좀 더 다뤄보기 위해서 간단한 방응형 웹사이트를 만들며 연습할 것이다. 부트 캠프의 마지막 단계인 프로젝트를 대비하기 위해서 자료를 찾아보다가 코드 스테이츠 유튜브에 이전 기수들의 프로젝트가 있는 것을 봤다. 일단 영상들을 확인해 보고 어떤 느낌으로 진행되는지를 파악한 다음 적절한 프로젝트 아이디어를 미리 생각해 볼 것이다. ","date":"10 September 2021","permalink":"/posts/bootcamp/bc-3w-5/","section":"Posts","summary":"Today I learned #DOM 이해하기 # Document Object Model의 약자로, HTML 요소를 Object처럼 조작할 수 있는 Model","title":"BC-3w-5 / [JS/브라우저] DOM(1)"},{"content":"Toady I learned #JavaScriptKoans # chai_expect expect(value).to.be.true expect(value).to.be.false expect(value).to.equal(expectedValue) type-1 123 - \u0026lsquo;1\u0026rsquo; // -\u0026gt; 122 1 + true // -\u0026gt; 2 let/const scope arrow function type-2 함수의 인수가 원시형 자료 변수일 때, 값만 복사해옴(변수에 변화 X) Object.keys(obj).length로 object 요소의 수 확인 참조형 자료를 할당하면 같은 주소를 저장하고, 이때 한쪽에서 수정하면 주소지의 내용을 수정하는 거라 양쪽 다 바뀌는 것과 같은 결과 array 함수의 인수가 배열 변수일 때, 주소가 전달(주소지의 변화 적용) object const currentYear = new Date().getFullYear() // 현재 년도 구하기 Object.values(obj) spread syntax arguments는 모든 함수의 실행 시 자동으로 생성되는 객체 함수의 인수를 다룰 때, spread syntax는 배열, arguments는 객체 Array.from()은 반복 가능한 객체를 얕게 복사해 새로운 array객체를 만듦 function(a1, a2, \u0026hellip;as) {return [a1, a2, \u0026hellip;as]}\nfunction(1) // -\u0026gt; [1, undefined, []] destructuring Today\u0026rsquo;s takeaway # 이때까지 공부했던 내용들을 50개의 문제를 통해 확인해 보는 날이었다. 이번에도 코딩은 처음인 페어와 함께 해서, 설명하는 연습을 많이 할 수 있었다. 설명하는 능력이 많이 늘고 있다. 혼자서 헷갈리던 부분을 페어가 물어봤을 때, 설명하다가 더 완벽하게 이해하게 되었다. 문제에서 헷갈리거나 모르는 내용은 없었고, 다시 한번 정리한다는 마음가짐으로 차근차근 풀었다. 오늘은 책(개발자의 글쓰기)에서 제안서 쓰기 부분과 마지막 장인 기술 블로그 쓰기 부분을 읽었다.\n제안서 쓰기 부분에서는 특히 상황에 따라 나눠서 제안서를 준비하는 방식이 흥미로웠다. 마케팅 수업에서 배웠던 SWOT 분석 형태의 분석을 여러 분야에 적용할 수 있구나 싶었다.\n기술 블로그 쓰기 부분은 주로 회사 차원에서 운용하는 기술 블로그에 관한 내용이었다. 취업 후 회사의 기술 블로그에 기여를 할 수 있게 지금 블로깅을 통해 미리 연습한다고 생각한다. Tomorrow I\u0026rsquo;ll learn # 드디어 DOM API이다. 혼자 공부할 때 이 부분에서 멈춰서 어느 정도 기본은 알고 있지만 자세히는 알지 못하는 부분이라 빨리 공부하고 WIL에 정리하고 싶다. DOM API를 잘 다루면 HTML/CSS와 JS를 유기적으로 사용할 수 있게 된다. 오늘을 끝으로 혼자서 공부했던 진도를 코드 스테이츠의 진도가 따라잡았다. 이제 새로운 내용들을 배우니 더욱 기대가 된다. ","date":"9 September 2021","permalink":"/posts/bootcamp/bc-3w-4/","section":"Posts","summary":"Toady I learned #JavaScriptKoans # chai_expect expect(value).","title":"BC-3w-4 / [JS/Node] JavaScript Koans"},{"content":"Today I learned #원시 자료형과 참조 자료형 # 변수는 메모리의 이름표\n원시형 자료는 하나의 변수에 하나의 값만 저장\n참조형 자료는 변수에 값이 아닌 주소를 저장\n(heap에 값을 저장하고 주소로 불러옴)\n함수 changeValue에 x의 값을 파라미터로 전달하여 실행\n(변수 x에 직접 할당한 것이 아니라 변수 x에는 여전히 9가 저장)\nlet x = 9; function changeValue(value) { value = 99; } changeValue(x); condole.log(x); // -\u0026gt; 9 함수 changeValue에 x의 주소를 파라미터로 전달하여 실행\n(변수 x에 직접 할당한 것은 아니어도 해당 주소의 값에 할당)\nlet x = { value: 3 }; function changeValue(address) { address.value = 2; } changeValue(x); console.log(x); // -\u0026gt; {value:2}​ 스코프 # 함수 안에서 선언 시 지역 변수로 선언(함수 밖에서 참조 불가능)\nlet firstName = \u0026#34;Yuchan\u0026#34;; let lastName = \u0026#34;Jeong\u0026#34;; function changeName() { let firstName = \u0026#34;Chesley\u0026#34;; lastName = \u0026#34;Mancao\u0026#34;; console.log(firstName); // -\u0026gt; \u0026#39;Chesley\u0026#39; console.log(lastName); // -\u0026gt; \u0026#39;Mancao\u0026#39; } changeName(); console.log(firstName); // -\u0026gt; \u0026#39;Yuchan\u0026#39; console.log(lastName); // -\u0026gt; \u0026#39;Mancao\u0026#39;​ 선언 없이 변수를 할당하면, var로 선언된 전역 변수처럼 작동(금지 사항)\n(\u0026ldquo;use strict\u0026quot;를 JS에 적용하면 선언 없는 변수 할당 금지)\nconst로 선언하더라도, 참조 자료형인 배열이나 객체의 요소는 추가 및 삭제 가능\n클로저 # 함수와 함수가 선언된 어휘적(lexical) 환경의 조합을 말한다. 이 환경은 클로저가 생성된 시점의 유효 범위 내에 있는 모든 지역 변수로 구성된다.\n(1) 클로저 함수는 함수를 리턴하는 함수(스코프를 이용해서, 변수의 접근 범위를 닫음)\nconst sum = (x) =\u0026gt; (y) =\u0026gt; x + y; // const sum = function(x) { // 외부함수의 변수 x // return function(y) { // 내부함수의 변수 y, 외부함수는 y에 접근 불가능 // return x + y // } // } sum(5)(7); // -\u0026gt; 12 typeof sum(5); // -\u0026gt; \u0026#34;function\u0026#34; sum(5); // -\u0026gt; y =\u0026gt; 5 + y sum(5)(7); // -\u0026gt; 7 =\u0026gt; 5 + 7 (2) 클로저 함수는 외부 함수의 변수를 보존하는 함수\n// 외부 함수(sum)의 실행이 끝나도, 외부 함수내 변수(x) 사용 가능 const sum = function (x) { return function (y) { return x + y; }; }; const sum5 = sum(5); // 함수 실행이 끝나도 5라는 값 사용 가능 sum5(7); // -\u0026gt; 12 sum5(10); // -\u0026gt; 15 Ex. HTML 문자열 생성기\nconst tagMaker = (tag) =\u0026gt; (content) =\u0026gt; `\u0026lt;${tag}\u0026gt;${content}\u0026lt;/${tag}\u0026gt;`; const divMaker = tagMaker(\u0026#34;div\u0026#34;); divMaker(\u0026#34;hello\u0026#34;); // -\u0026gt; \u0026#39;\u0026lt;div\u0026gt;hello\u0026lt;/div\u0026gt;\u0026#39; divMaker(\u0026#34;yuchan\u0026#34;); // -\u0026gt; \u0026#39;\u0026lt;div\u0026gt;yuchan\u0026lt;/div\u0026gt;\u0026#39; const anchorMaker = tagMaker(\u0026#34;a\u0026#34;); anchorMaker(\u0026#34;hi\u0026#34;); // -\u0026gt; \u0026#39;\u0026lt;a\u0026gt;hi\u0026lt;/a\u0026gt;\u0026#39; anchorMaker(\u0026#34;yuchan\u0026#34;); // -\u0026gt; \u0026#39;\u0026lt;a\u0026gt;yuchan\u0026lt;/a\u0026gt;\u0026#39; tagMaker(\u0026#34;span\u0026#34;)(\u0026#34;Hello world\u0026#34;); // -\u0026gt; \u0026#39;\u0026lt;span\u0026gt;Hello world\u0026lt;/span\u0026gt;\u0026#39; 클로저 모듈 패턴(정보의 접근 제한)\n// 클로저 모듈 패턴(정보의 접근 제한) 예시 const makeCounter = (x) =\u0026gt; { let value = x; // 함수 변경 없이 value에 할당 불가능(캡슐화) return { // 내부함수 여러개 생성 가능 up: (x) =\u0026gt; { value += x; return value; }, down: (x) =\u0026gt; { value -= x; // 스코프 체이닝(하위 스코프 우선!) return value; }, }; }; const counter1 = makeCounter(1); // 함수 재활용 가능! const counter2 = makeCounter(2); counter1.up(7); // -\u0026gt; 8 counter2.down(7); // -\u0026gt; -5 counter2.up(7); // -\u0026gt; 2 // counter1과 counter2의 value는 서로에게 영향X! * 모듈화: 함수 하나를 완전히 독립적인 부품 형태로 분리, 함수 재사용화 극대화\n전개 구문과 구조 분해 할당 # Ex. 함수에서 객체 분해\nfunction whoIs({ id, fullName: { firstName: name } }) { console.log(id + \u0026#34; is \u0026#34; + name); } let user = { age: 27, id: \u0026#34;werty\u0026#34;, fullName: { firstName: \u0026#34;Yuchan\u0026#34;, lastName: \u0026#34;Jeong\u0026#34;, }, }; whoIs(user); // -\u0026gt; \u0026#39;werty is Yuchan\u0026#39; Today\u0026rsquo;s takeaway # 내가 이전에 정리했던 내용과 조금 달랐다. 오늘 배운 내용이 좀 더 직관적이라 정리한 내용을 수정했다.\n(Ex. 원시형 자료는 같은 값은 같은 메모리에 저장된다 -\u0026gt; 원시형 자료는 값을 저장한다) 이전에 함수 밖의 변수 이름과 함수의 인수 이름이 똑같을 때 어떻게 처리될까 궁금해서 확인해 보았는데,\n오늘 스코프 체이닝을 배워서 좀 더 명확하게 작동 원리를 알게 되었다. 클로저는 처음 보는 개념이라 낯설었다. 처음에는 콜백 함수와 비슷한 건가 했지만 달랐다. 예제를 통해 어디에 쓰이는지(함수의 재활용)를 보고 나니 이해할 수 있었다. 구조 분해 할당을 함수의 인수에도 사용할 수 있다. 오늘은 책(개발자의 글쓰기)에서 개발 가이드 쓰기 부분을 읽었는데, 코드스테이츠 프로젝트를 진행할 때 도움이 될 것이다. Tomorrow I\u0026rsquo;ll learn # 오늘 배운 내용을 바탕으로 페어 프로그래밍으로 문제를 풀 것이다. ","date":"8 September 2021","permalink":"/posts/bootcamp/bc-3w-3/","section":"Posts","summary":"Today I learned #원시 자료형과 참조 자료형 # 변수는 메모리의 이름표","title":"BC-3w-3 / [JS/Node] 자료형, 스코프, 클로저"},{"content":"Today I learned #CSS 중급 # CSS Selector selector1 + selector2는 selector1의 형제 요소 중 다음 selector2 selector1 ~ selector2는 selector1의 형제 요소 중 모든 selector2 selector:last-child는 자식 요소인 selector 중 마지막 요소 selector1 \u0026gt; selector2:lastChild는 selector1의 자식 요소인 selector2 중 마지막 요소 selector:last-child(n)은 자식 요소인 selector 중 마지막에서 n번째요소 selector1 \u0026gt; selector2:nth-last-child(2n+1)은 selector1의 자식 요소인 selector2 중 마지막에서 홀수 번째 요소 selector:first-of-type은 자식요소인 selector 중 첫 등장 요소 selector:last-of-type은 자식요소인 selector 중 마지막 등장 요소 selector:nth-of-type(n)은 n번째자식 요소인 selector(selector 중에서 n번째) selector1:not(selector2)는 selector2가 아닌 selector1 기본 스타일링을 제거하는 CSS 코드 body { margin: 0; padding: 0; } Flex box flex: 1 0 0;을 이용한 1:1 비율 배치 와이어프레임 설계 및 목업 구현 참조 사이트 https://material-ui.com https://ant.design https://getbootstrap.com Twitter 목업 만들기 # 아직은 하드코딩으로 정보를 일일히 입력했다. 조금 더 배워서 정보를 불러오는 방식으로 만들고 싶다. vw와 vh를 활용해서 반응형으로 만들었다. 아직 class 이름 만들기가 많이 어려웠다. Today\u0026rsquo;s takeaway # 오늘은 CSS를 활용해서 직접 웹 화면을 구성해 봤다. 이론적으로는 잘 알고 있었지만, 직접 화면을 만들어보니 어려웠다. 내가 원하는데로 자연스럽게 구성하고 작동 시키는데 어려움이 있었다. 특히 HTML 구조를 만들 때, 어떻게 효율적으로 묶어서 만들지 고민이 많이 되었다. CSS에서도 선택자를 어떻게 활용하는 것이 효율적일지 아직은 잘 모르겠다. 이번 주말에는 CSS로 여러 레이아웃들을 만들어보면서 연습해야겠다. Tomorrow I\u0026rsquo;ll learn # 원시 자료형과 참조 자료형 원시 자료형은 같은 형태는 같은 메모리에 저장 참조 자료형은 같은 형태도 다른 메모리에 저장 스코프 const와 let은 block level scope 이다. 클로저 함수를 리턴하고, 리턴하는 함수가 클로저를 형성한다. 클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다. 이 환경은 클로저가 생성된 시점의 유효 범위 내에 있는 모든 지역 변수로 구성된다. ","date":"7 September 2021","permalink":"/posts/bootcamp/bc-3w-2/","section":"Posts","summary":"Today I learned #CSS 중급 # CSS Selector selector1 + selector2는 selector1의 형제 요소 중 다음 selector2 selector1 ~ selector2는 selector1의 형제 요소 중 모든 selector2 selector:last-child는 자식 요소인 selector 중 마지막 요소 selector1 \u0026gt; selector2:lastChild는 selector1의 자식 요소인 selector2 중 마지막 요소 selector:last-child(n)은 자식 요소인 selector 중 마지막에서 n번째요소 selector1 \u0026gt; selector2:nth-last-child(2n+1)은 selector1의 자식 요소인 selector2 중 마지막에서 홀수 번째 요소 selector:first-of-type은 자식요소인 selector 중 첫 등장 요소 selector:last-of-type은 자식요소인 selector 중 마지막 등장 요소 selector:nth-of-type(n)은 n번째자식 요소인 selector(selector 중에서 n번째) selector1:not(selector2)는 selector2가 아닌 selector1 기본 스타일링을 제거하는 CSS 코드 body { margin: 0; padding: 0; } Flex box flex: 1 0 0;을 이용한 1:1 비율 배치 와이어프레임 설계 및 목업 구현 참조 사이트 https://material-ui.","title":"BC-3w-2 / [CSS] 레이아웃, Selector"},{"content":"","date":null,"permalink":"/tags/css/","section":"Tags","summary":"","title":"CSS"},{"content":"2주 차 정리 # 월요일에 처음으로 계산기를 만드는 과제를 했다. 생각보다 높은 난이도에 애를 먹었다. 하지만 동시에 드디어 좀 어려운 과제를 하는구나 싶어 기쁘게 만들었다. 어드밴스 난이도까지는 그렇게 어렵지는 않게 했지만 나이트메어 난이도는 정말 악몽과도 같았다. 원래 끝을 보지 못하면 안 되는 성격이라 나이트메어 모드를 통과하고 또 스스로 만져보면서 발견한 에지 케이스까지 해결하느라 아침까지 코딩을 했다. 화요일에는 1시간 쪽잠을 자고 일어나서 계산기 만들기 페어 프로그래밍을 진행했다. 어제오늘까지 각자 최대한 만들고 아침에 만든 부분까지 서로 설명을 해주기로 약속했었다. 설명을 해주다 보니 필요 없는 코드들이 좀 보였다. 그리고 페어의 코드에서 새로운 아이디어를 얻기도 했다. 그 뒤 리팩토링을 하고, 남는 시간에 새로운 기능도 넣어보고 하며 계산기 만들기를 완성했다. 처음부터 만든 게 아니라 주어진 틀 위에서 만든 거라 조금 아쉬워서, 주말에 혼자서 처음부터 끝까지 만들 계획을 세웠다. 수요일에는 CLI 기본 명령어들을 배웠다. 이미 정리까지 끝마친 부분이고 어렵지는 않아서 적절한 휴식 시간이 되었다. 목요일에는 Git에 대해서 배웠는데 이 부분도 이미 정리까지 끝마친 부분이었으나 여전히 조금 헷갈렸는데, 코드 스테이츠에서 제공하는 퀴즈의 퀄리티가 아주 좋아서 헷갈리던 부분을 확실하게 이해할 수 있었다. 금요일에는 다시 JS로 넘어와서 배열에 대하여 배웠다. 오랜만에 다시 문제를 푸니 반가웠다. 난이도도 어렵지 않아서 빠르게 끝내고, 주말에 만들 계산기의 알고리즘을 설계했다. 금요일 밤부터 일요일 늦은 밤까지 잠깐의 휴식과 식사, 수면 외에는 아무것도 하지 않고 코딩만 계속했다. 다 끝난 지금은 조금 지친 것이 느껴지지만 코딩을 하는 동안에는 피곤함을 전혀 느끼지 않고 즐겁게 할 수 있었다. 현재 내 실력이 얼마나 형편없는지 여실히 느낄 수 있었다. 구조를 완벽히 이해하고 알고리즘을 잘 짠 다음 코딩을 하려고 하였으나 터무니없는 일이었다. 구조를 완벽히 이해하고 있지 못하니 에러가 발생하였을 때 해결하는 데 많은 시간이 걸리고, 추가 기능을 넣으려고 할 때 어디부터 어디까지 손을 데어야 하는지를 알 수 없었다. 열심히 공부해서 구조를 이해하면서 개발하는 개발자가 되는 것이 현재의 목표이다. ","date":"6 September 2021","permalink":"/posts/bootcamp/bc-2w-7/","section":"Posts","summary":"2주 차 정리 # 월요일에 처음으로 계산기를 만드는 과제를 했다.","title":"BC-2w-7 / 2주 차 정리"},{"content":"Today I learned #객체 문제 # 15\nfunction func(arr, obj) { let result = {} for (let key in obj) { for (let item of arr) { if (key === item) { // result안에 key가 없으면, // key를 만들며 obj[key] 할당 result[key] = obj[key] } } } return result }​ 21-continue\nfunction func(str) { let arr = str.split(\u0026#34; \u0026#34;); let newStr = arr.join(\u0026#34;\u0026#34;); // 빈 객체에 정보 저장(result + count) let obj = { mostLetter: \u0026#34;\u0026#34;, maxCount: 0 }; for (let i = 0; i \u0026lt; newStr.length; i++) { // if (str[i] === \u0026#39; \u0026#39;) { // continue // 특정 조건일 때, 반복문을 넘길 수 있음!!! // }\t// newStr 쓸 필요 없음 obj[newStr[i]] = (obj[newStr[i]] || 0) + 1; // or은 먼저 걸리면 그거 사용 // key가 없으면 생성 하면서, newStr[i]에 value 할당 // if (obj[newStr[i]] === undefined) { // obj[newStr[i]] = 1 // } else { // obj[newStr[i]]++ // } if (obj[newStr[i]] \u0026gt; obj.mostCount) { obj.maxNum = obj[newStr[i]]; obj.mostLetter = newStr[i]; } } return obj.mostLetter; } Today\u0026rsquo;s takeaway # obj.key와 obj[\u0026ldquo;key\u0026rdquo;] 구분 중요 대부분의 문제가 obj1[key] = obj2[key]를 활용 빈 객체에 필요한 정보만 저장하는 형태로 사용 가능 배열은 인덱스, 객체는 이름으로 정보를 저장하고 불러올 수 있음 오늘은 책(개발자의 글쓰기)에서 릴리스 문서와 장애 보고서 쓰기 부분을 읽었다. 개발자의 주 업무는 개발과 보고서 작성이다. 개발만큼이나 보고서 작성도 잘하도록 공부하자. Tomorrow I\u0026rsquo;ll learn #CSS 레이아웃, Selector # 웹 앱 화면 설계하기 앞서 배운 HTML/CSS를 활용한 화면 설계 Twittler 목업 만들기 화면 설계 방법을 실전에 적용 ","date":"6 September 2021","permalink":"/posts/bootcamp/bc-3w-1/","section":"Posts","summary":"Today I learned #객체 문제 # 15","title":"BC-3w-1 / [JS/Node] 객체"},{"content":" HTML과 CSS # 크게 display(출력)와 buttonWrap(입력) 부분으로 구분 background를 flex로 설정하고, justify-content와 align-items에 center 값을 줘서 계산기를 가운데 배치 맥 계산기는 커서 모양이 변하지 않아서 cursor: default;로 커서가 변하지 않게 함 user-select: none;을 이용해서 계산기의 contents들이 선택되지 않게 함\n(-webkit-user-select: none; -ms-user-select: none; -moz-user-select: none;) display의 윗부분과 0 버튼, = 버튼의 아래 부분을 각각 border-radius로 둥글게 만듦 text-align으로 글자 가로 정렬, line-height으로 글자 세로 정렬 buttonWrap을 flex로 설정하고, flex-wrap: wrap;을 이용해서 버튼 배치 가상 선택자(:active)를 이용해서 클릭 시 색상 변경 operator가 isPressed 클래스를 지니고 있을 경우, border를 두껍게 해서 현재 선택된 연산자를 알 수 있게 함 JavaScript # 1. 우선 맥 계산기에 여러 숫자들을 넣어보며 어떻게 작동하는지 파악 #2. 수도 코드 작성 # 아래 글로 적은 것들이 작성한 수도 코드 3. 수도 코드를 코드로 작성 # clearButton은 target이 아닐 때도, 사용되어야 해서 전역 변수로 선언\nconst displayEl = document.querySelector(\u0026#39;.calculator .display\u0026#39;) const buttonWrapEl = document.querySelector(\u0026#39;.calculator .buttonWrap\u0026#39;) const clearButtonEl = document.querySelector(\u0026#39;.calculator .button.clear\u0026#39;) const operatorButtonEls = document.querySelectorAll(\u0026#39;.calculator .button.operator\u0026#39;) let displayNum = \u0026#39;0\u0026#39;, previousNum = \u0026#39;0\u0026#39;, previousOperator, previousKey buttonWrapEl.addEventListener(\u0026#39;click\u0026#39;, function(event) { const target = event.target const action = target.classList[1] const buttonContent = target.textContent function cancelPress() { for(let i = 0; i \u0026lt;= 3; i++) { operatorButtonEls[i].classList.remove(\u0026#39;isPressed\u0026#39;) } } ... changeToIEEE() changeFontSize() }) 연산\nJS에서 나타나는 계산 오류를 줄이기 위해, 「x 1 e12 ÷ 1 e12」를 해줌. Ex. 0.3 + 0.6 = 0.8999999999999999(JS 기본 연산 시) function calculate(num1, operator, num2) { let result; if (operator === \u0026#34;＋\u0026#34;) { result = Math.round((Number(num1) + Number(num2)) * 1e12) / 1e12; } else if (operator === \u0026#34;－\u0026#34;) { result = Math.round((Number(num1) - Number(num2)) * 1e12) / 1e12; } else if (operator === \u0026#34;×\u0026#34;) { result = Math.round(Number(num1) * Number(num2) * 1e12) / 1e12; } else if (operator === \u0026#34;÷\u0026#34;) { result = Math.round((Number(num1) / Number(num2)) * 1e12) / 1e12; } return String(result); } display\n디스플레이의 수가 20자리 이상이면 소수점이 16자리인 부동 소수점 e로 표현 맥 계산기는 부동 소수점 e를 표현할 때, 소수점 맨 뒤의 0들은 생략하기 때문에, 소수 부분만 따로 떼어서 숫자화로 소수점 맨 뒤의 0들을 없애 주고, 다시 문자 화하여 나머지 부분과 합쳐줌 디스플레이에 보이는 수와 계산에 사용하는 디스플레이의 수를 분리(부동 소수점 e는 문자화와 숫자화를 자유롭게 할 수 없기 때문) 디스플레이의 수가 10자리 이상이면 폰트가 점점 작아짐 숫자 버튼 이외의 버튼을 클릭하면 디스플레이가 깜박임 function changeToIEEE() { if (displayNum.length \u0026gt;= 20) { let exponentialNum, intPart, decimalPart, exponentialPart; exponentialNum = Number.parseFloat(displayNum).toExponential(16); intPart = exponentialNum.slice(0, 1); decimalPart = String( parseFloat(`0.${exponentialNum.slice(2, 18)}`) ).slice(1); exponentialPart = exponentialNum.slice(18); displayEl.textContent = `${intPart}${decimalPart}${exponentialPart}`; } else { displayEl.textContent = displayNum; } } function changeFontSize() { const displayLength = displayEl.textContent.length; let displayFontSize; if (displayLength \u0026lt;= 10) { displayFontSize = 40; } else if (displayLength \u0026lt;= 15) { displayFontSize = 40 * Math.pow(0.915, displayLength - 10); } else if (displayLength \u0026lt;= 20) { displayFontSize = 25.65 * Math.pow(0.93, displayLength - 15); } else { displayFontSize = 17.84; } displayEl.style.fontSize = `${displayFontSize}px`; } function blink() { displayEl.style.color = \u0026#34;rgb(90, 90, 90)\u0026#34;; setTimeout(function () { displayEl.style.color = \u0026#34;aliceblue\u0026#34;; }, 100); } number\n디스플레이 수가 0이거나 연산자 혹은 계산 다음일 때, 디스플레이에 입력이 그대로 할당. 나머지 경우는 디스플레이의 수에 입력 할당 연산 if (action === \u0026#34;number\u0026#34;) { if ( displayNum === \u0026#34;0\u0026#34; || previousKey === \u0026#34;operator\u0026#34; || previousKey === \u0026#34;calculate\u0026#34; ) { displayNum = buttonContent; } else { displayNum += buttonContent; } clearButtonEl.textContent = \u0026#34;C\u0026#34;; previousKey = \u0026#34;number\u0026#34;; } decimal\n디스플레이의 수에 소수점이 없으면서 연산자 다음이 아닐 때, 소수점을 입력 할당 연산. 연산자 다음 일 때는 \u0026lsquo;0.\u0026rsquo; 할당 숫자 버튼과 같은 취급 if (action === \u0026#34;decimal\u0026#34;) { if (!displayNum.includes(\u0026#34;.\u0026#34;) \u0026amp;\u0026amp; previousKey !== \u0026#34;operator\u0026#34;) { displayNum += \u0026#34;.\u0026#34;; } else if (previousKey === \u0026#34;operator\u0026#34;) { displayNum = \u0026#34;0.\u0026#34;; } clearButtonEl.textContent = \u0026#34;C\u0026#34;; previousKey = \u0026#34;number\u0026#34;; } operator\n기존의 isPressed 초기화 후 타깃에 isPressed 클래스 부여 숫자 다음이며 이미 기억하고 있는 연산자가 있을 때, 연산(previousNum, previousOperator, displayNum) 연산 여부와 상관없이, 디스플레이의 수와 연산자 기억 초기화 다음에는 디스플레이의 수를 기억하지 않는데, 0이 되어버린 디스플레이의 수로 이전의 수를 덮지 않게 하기 위함 if (action === \u0026#34;operator\u0026#34;) { cancelPress(); target.classList.add(\u0026#34;isPressed\u0026#34;); if (previousKey === \u0026#34;number\u0026#34; \u0026amp;\u0026amp; previousOperator !== undefined) { displayNum = calculate(previousNum, previousOperator, displayNum); } if (previousKey !== \u0026#34;clear\u0026#34;) { previousNum = displayNum; } previousOperator = buttonContent; previousKey = \u0026#34;operator\u0026#34;; blink(); } calculate\nisPressed 초기화 이미 기억하고 있는 연산자가 있을 때 연속 계산이 아니면, 디스플레이의 수를 임의의 변수에 할당하고(연속 계산시, 기호 다음의 숫자를 기억하고 있기 위해), 연산(previousNum, previousOperator, displayNum) 후 이전 디스플레이의 수 기억 초기화 다음일 때, 다른 방식으로 연산(previousNum, previousOperator, previousNum) 연속으로 계산할 때, 또 다른 방식으로 연산(displayNum, previousOperator, previousNum) 코드로 작성 할때는 내가 작성한 수도코드와 반대로 예외부터 걸러줘야함! if (action === \u0026#34;calculate\u0026#34;) { cancelPress(); let pseudoNum; if (previousOperator !== undefined) { if (previousKey === \u0026#34;calculate\u0026#34;) { displayNum = calculate(displayNum, previousOperator, previousNum); } else if (previousKey === \u0026#34;clear\u0026#34;) { displayNum = calculate(previousNum, previousOperator, previousNum); } else { pseudoNum = displayNum; displayNum = calculate(previousNum, previousOperator, displayNum); previousNum = pseudoNum; pseudoNum = undefined; } previousKey = \u0026#34;calculate\u0026#34;; } blink(); } clear\n수나 소수점을 누르면 C로 변환. clear를 누르면 다시 AC로 변환 숫자 다음일 때, 디스플레이의 수를 초기화 연산자 다음일 때, 연산자와 isPressed 초기화 계산 다음일 때, 디스플레이의 수를 기억하고 나서 초기화 초기화 다음일 때, 모두 초기화(처음에 이걸 젤 마지막에 둬서 항상 모두 초기화되어 버렸음) if (action === \u0026#34;clear\u0026#34;) { clearButtonEl.textContent = \u0026#34;AC\u0026#34;; if (previousKey === \u0026#34;clear\u0026#34;) { displayNum = \u0026#34;0\u0026#34;; previousNum = \u0026#34;0\u0026#34;; previousOperator = undefined; cancelPress(); previousKey = undefined; } if (previousKey === \u0026#34;number\u0026#34;) { displayNum = \u0026#34;0\u0026#34;; previousKey = \u0026#34;clear\u0026#34;; } if (previousKey === \u0026#34;operator\u0026#34;) { previousOperator = undefined; cancelPress(); previousKey = \u0026#34;clear\u0026#34;; } if (previousKey === \u0026#34;calculate\u0026#34;) { previousNum = displayNum; displayNum = \u0026#34;0\u0026#34;; previousKey = \u0026#34;clear\u0026#34;; } blink(); } sign \u0026amp; percent\n디스플레이의 수가 0이 아닐 때, sing은 -1을 곱해주고, percent는 0.01을 곱해줌 if (action === \u0026#34;sign\u0026#34; \u0026amp;\u0026amp; displayNum !== \u0026#34;0\u0026#34;) { displayNum *= -1; blink(); } if (action === \u0026#34;percent\u0026#34; \u0026amp;\u0026amp; displayNum !== \u0026#34;0\u0026#34;) { displayNum *= 0.01; blink(); } undefined is not an object error를 만났다. 한참을 해결하지 못하였고, 새벽이라 너무 피곤해서 일단 잠을 잤다. 일어나자말자 기능별로 하나씩 때서 콘솔을 통해 확인했다. 생각보다 쉽게 error의 이유와 해결 방안을 찾을 수 있었다. 함수의 return 부분이 한 줄 밀려서 if문의 괄호 안으로 들어간 것이었다. 처음 만나는 error에 error 메시지가 말해주는 부분만 계속 고치며 확인한 것이 시간이 오래 걸린 이유였다. 좀 더 구조를 잘 이해하고 유기적으로 생각하는 법을 길러야겠다. 여담으로 error가 발생했을 때, 화가 나기보다는 어디가 잘못되었을까 찾고 더 보완하고 싶은 마음에 기뻐하는 나를 보며 개발자가 천직이 아닐까 하고 생각했다.\n기능을 만들어 가는 와중에 치명적인 문제점을 발견했다. 이전까지 맥 계산기는 숫자 다음에 오는 두 번째 이후 연산자일 때, 디스플레이에 연산이 바로바로 반영되었기에, 곱셈/나눗셈이 먼저 진행되어야 하는 사칙연산의 기본 규칙을 적용하지 않아도 된다고 생각하고 있었다. 기능을 쉽게 파악하기 위해 덧셈/뺄셈 위주로 기능을 확인했던 것이 문제점을 늦게 발견하게 된 이유이다. 우선은 기존에 구상한 데로 순서대로 계산하는 계산기를 먼저 만들고, 추가로 사칙 연산 규칙을 따르게 만들 것이다.\n사칙 연산 규칙 적용하기-advenced # 사칙 연산 규칙 적용 안됨\n사칙 연산 규칙 적용됨\n현재는 연산자가 있을 때, 숫자 다음 연산자를 누르면 즉시 연산(previousNum, previousOperator, displayNum) 후 previousNum = displayNum, previousOperator = buttonContent\n사칙연산 규칙을 적용하면, 덧셈/뺄셈 다음에 곱셈/나눗셈이 나오면 덧셈/뺄셈이 나오거나 계산을 누를 때까지 제일 앞의 숫자 하나와 연산자 하나를 보류해두고 뒤에는 계속 연산\n즉, previousOperator가 +/-이면서 buttonContent가 ×/÷일 때, 연산 전에 스택으로 previousNum과 previousOperator 이동(previousOperator가 없어서 연산은 일어나지 않고, previousNum = displayNum, previousOperator = buttonContent)\nstack !== undefined면서 buttonContent가 +/-일 때, 연산(previousNum, previousOperator, displayNum) 후 스택을 불러와서 추가 연산(stack[0], stack[1], 앞의 연산 결과) 후 스택 초기화\n계산은 스택이 있을 때, 추가연산만 해주면 기존과 같음\n연산자 다음 초기화하면, 스택은 연산 안 하고 사라짐\n조건을 만족할 때, 스택을 쌓는 부분과 스택을 포함해서 계산해 주는 부분 추가\nif (action === \u0026#34;operator\u0026#34;) { cancelPress(); target.classList.add(\u0026#34;isPressed\u0026#34;); if (previousKey === \u0026#34;number\u0026#34;) { if (previousOperator === \u0026#34;＋\u0026#34; || previousOperator === \u0026#34;－\u0026#34;) { if (buttonContent === \u0026#34;×\u0026#34; || buttonContent === \u0026#34;÷\u0026#34;) { stackCalculate = []; stackCalculate.push(previousNum, previousOperator); previousOperator = undefined; } } if (previousOperator !== undefined) { displayNum = calculate(previousNum, previousOperator, displayNum); } } if (stackCalculate !== undefined) { if (buttonContent === \u0026#34;＋\u0026#34; || buttonContent === \u0026#34;－\u0026#34;) { displayNum = calculate( stackCalculate[0], stackCalculate[1], displayNum ); stackCalculate = undefined; } } if (previousKey !== \u0026#34;clear\u0026#34;) { previousNum = displayNum; } previousOperator = buttonContent; previousKey = \u0026#34;operator\u0026#34;; blink(); } 기존 코드에 스택이 있을 때, 스택을 포함해서 계산 해주는 부분 추가\nif (action === \u0026#34;calculate\u0026#34;) { cancelPress(); let pseudoNum; if (previousOperator !== undefined) { if (previousKey === \u0026#34;calculate\u0026#34;) { displayNum = calculate(displayNum, previousOperator, previousNum); } else if (previousKey === \u0026#34;clear\u0026#34;) { displayNum = calculate(previousNum, previousOperator, previousNum); } else { pseudoNum = displayNum; displayNum = calculate(previousNum, previousOperator, displayNum); previousNum = pseudoNum; pseudoNum = undefined; } if (stackCalculate !== undefined) { displayNum = calculate( stackCalculate[0], stackCalculate[1], displayNum ); stackCalculate = undefined; } previousKey = \u0026#34;calculate\u0026#34;; } blink(); } ","date":"5 September 2021","permalink":"/posts/bootcamp/bc-2w-6/","section":"Posts","summary":"HTML과 CSS # 크게 display(출력)와 buttonWrap(입력) 부분으로 구분 background를 flex로 설정하고, justify-content와 align-items에 center 값을 줘서 계산기를 가운데 배치 맥 계산기는 커서 모양이 변하지 않아서 cursor: default;로 커서가 변하지 않게 함 user-select: none;을 이용해서 계산기의 contents들이 선택되지 않게 함","title":"BC-2w-6 / 맥 계산기 만들기"},{"content":"Today I learned #배열 # 대소문자 구분 잘하자 console.table() 테이블로 콘솔에 출력 arr.shift() 배열 첫 번째 요소 삭제 arr.pop() 배열 마지막 요소 삭제 .join([separator]) 요소를 구분자로 구분한 문자열 Array.isArray(variable) 배열 요소인지 여부 판단\n*null은 variable === null로 판단 for\u0026hellip;of for\u0026hellip;in for (let item of array) { 반복내용 } for\u0026hellip;in for (let key in object) { 반복내용 } [] === []은 false, 주소가 다른 두 개의 빈 배열 배열 문제 # 24\nfunction mine(arr) { let str; if (arr.length === 8) { arr.splice(4, 0, \u0026#34;-\u0026#34;); str = arr.join(\u0026#34;\u0026#34;); return \u0026#34;(010)\u0026#34; + str; } else { arr.splice(0, 0, \u0026#34;(\u0026#34;); arr.splice(4, 0, \u0026#34;)\u0026#34;); arr.splice(9, 0, \u0026#34;-\u0026#34;); str = arr.join(\u0026#34;\u0026#34;); return str; } } function ref(arr) { const len = arr.length; let first = \u0026#34;(010)\u0026#34;; const middle = arr.slice(len - 8, len - 4).join(\u0026#34;\u0026#34;); const last = arr.slice(len - 4, len).join(\u0026#34;\u0026#34;); if (len === 11) { first = `(${arr.slice(0, 3).join(\u0026#34;\u0026#34;)})`; } return `${first}${middle}-${last}`; } 객체 # delete 키워드로 key-value 삭제 가능\nEx. delete object.key in 연산자로 key 존재 여부 확인 가능\nEx. \u0026lsquo;key\u0026rsquo; in object // \u0026ndash;\u0026gt; boolean let yuchan = {}; // A~C 중 하나를 여기에 넣으면, 아래의 결과가 나와야 함. question(yuchan, \u0026#34;isKorean\u0026#34;, true); console.log(yuchan.isKorean); // true // A. function question(obj, property, value) { obj[\u0026#34;property\u0026#34;] = value; } // B. function question(obj, property, value) { obj[property] = value; } // C. function question(obj, property, value) { obj.property = value; } // A와 C는 property라는 key을 만들고 그 key에 value를 담음. // B가 되는 이유는 property가 문자열 타입의 파라미터기 때문. Today\u0026rsquo;s takeaway # 배열은 반복문과 자주 쓰인다. 배열은 원본이 변하는 메소드가 많다. 오늘 처음으로 사전 지식이 없는 페어와 페어 프로그래밍을 진행했다. 페어가 \u0026ldquo;진행이 빠르다\u0026rdquo;, \u0026ldquo;이해 속도가 차이 나니 한번 혼자 생각할 시간을 달라\u0026rdquo;, \u0026ldquo;이미 알고 있는 내용이라 설명 안 해도 되고, 물어보는 거만 답해주면 된다\u0026rdquo; 등 적극적으로 피드백을 주셨고, 그 덕에 빠르게 나의 문제점들을 고쳐나가며 페어 프로그래밍을 진행할 수 있었다. 리스닝 진단 평가를 완료했다. 코딩 공부가 주기 때문에 영어 공부는 미리 계획을 다 잡아두기보단 하루에 할 최소 분량만 정해두고, 유동적으로 진행하기로 했다. Weekend I\u0026rsquo;ll learn # 맥 기본 계산기를 처음부터 만들어 볼 것이다. 이미 형태는 완료하였고, 기능만 구현하면 된다. 블로그 글들을 전체적으로 다듬을 것이다. WIL에 정리한 내용들을 다시 한번 확인하고 다듬을 것이다. ","date":"3 September 2021","permalink":"/posts/bootcamp/bc-2w-5/","section":"Posts","summary":"Today I learned #배열 # 대소문자 구분 잘하자 console.","title":"BC-2w-5 / [JS/Node] 배열, 객체"},{"content":"Today I learned #Git 설치 # git config \u0026ndash;global core.editor nano 텍스트 에디터를 나노로 변경 SSH 등록 # ssh-keygen 경로 ~/.ssh/ 에 두 파일 id_rsa 와 id_rsa.pub를 생성 id_rsa.pub는 공개키(Public Key) id_rsa는 개인키(Private Key) 또는 비밀키(Secret Key) cat ~/.ssh/id_rsa.pub 공개키 복사 Settings SSH and GPG keys에 등록 git 명령어 # git restore 커밋되지 않은 변경 사항을 폐기 origin 대신 다른 이름으로 여러 원격 저장소 관리 가능 master 대신 다른 이름으로 여러 브랜치 관리 가능\n*BLM운동의 일환으로 main으로 바뀌는 중 페어로 Git 실습 # 간단한 계산 함수의 기능들을 하나씩 작성하면 원격 저장소를 통해 페어와 협업을 연습 각자 작업을 하면서 커밋 기록, 일부러 충돌이 생기는 상황도 만들고 해결 Today\u0026rsquo;s takeaway # Git Command Quiz로 깃 사용 과정을 한눈에 볼 수 있게 만들어 놓아서, untracked files -\u0026gt; staging area -\u0026gt; (stash) -\u0026gt; local main, remote origin/pair의 흐름을 쉽게 이해할 수 있었다. 터미널에서 Tap으로 자동완성을 할 수 있다는 것을 페어에게 배웠다. 오늘은 책(개발자의 글쓰기)에서 에러 메시지 작성에 대한 부분을 읽었다. 나는 기능만 잘 작동하게 만들면 에러를 만들지 않을 수 있다고 생각했으나, 책에서 나온 대부분의 에러 예시는 사용자가 잘못 입력한 것이 원인이었다. 에러를 해결하기 위해 유저 친화적으로 유저의 입장에서 생각하고 개발을 해야 한다는 점을 배웠다. 개발은 잠시라도 생각을 멈추면 안 되는 작업인 거 같다. 영어 단어 정리가 완료되었다. 처음의 3,300 단어를 2,300 단어까지 줄였다. 이제 내일부터 틈이 날 때마다(화장실, 계단 타기, 식사시간, 취침 직전 등) 단어를 외울 것이다. 리스닝의 경우 생각보다 단어 정리에 시간이 걸려서 진단고사를 반밖에 진행하지 못하여서 내일 진단고사를 마무리할 것이다. Tomorrow I\u0026rsquo;ll learn # 배열은 위치로 값을 불러오는 참조형 데이터이다. 객체는 key로 값을 불러오는 참조형 데이터이다. ","date":"2 September 2021","permalink":"/posts/bootcamp/bc-2w-4/","section":"Posts","summary":"Today I learned #Git 설치 # git config \u0026ndash;global core.","title":"BC-2w-4 / [Git] 기초"},{"content":"Today I learned #CLI 명령어 # 기본적인 이동/생성/삭제/복사 등의 명령어 관리자 권한을 획득하는 명령어 sudo 텍스트 에디터 nano ls -l d: 폴더 / -: 파일 r: 읽기 권한 w: 쓰기 권한 e: 실행 권한 -: 권한 없음 -f는 강제 명령 패키지와 패키지 매니저 Home Brew # eval $(/opt/homebrew/bin/brew shellenv)\n명령어 설명 brew update brew 자체 업데이트 brew outdated 업데이트 필요한 파일 조회 brew upgrade 프로그램명 프로그램 업그레이드 brew search 프로그램명 프로그램 검색 brew info 프로그램명 프로그램 정보 확인 brew install 프로그램명 프로그램 설치 brew uninstall 프로그램명 프로그램 삭제 brew list 설치된 프로그램 보기 Node.js # JavaScript 런타임 환경 M1이라 막히는 부분이 있었느냐, 검색으로 잘 해결 짝수 생성기 과제 # 에러 발생 에러는 무엇을 말하고 있나요? Cannot find module \u0026lsquo;range\u0026rsquo; 처음 에러가 발생한 파일은 어떤 파일인가요? internal/modules/cjs/loader 무슨 파일에서 에러가 발생했는지 알아냈다면, 몇 번째 줄인지도 알아낼 수 있을까요? :928 node:internal/modules/cjs/loader:928 throw err; ^ Error: Cannot find module \u0026#39;range\u0026#39; Require stack: - /Users/gotoweb/sw-sprints-cli-practice-master/getListMultiplesOfTwo.js - /Users/gotoweb/sw-sprints-cli-practice-master/index.js at Function.Module._resolveFilename (node:internal/modules/cjs/loader:925:15) at Function.Module._load (node:internal/modules/cjs/loader:769:27) at Module.require (node:internal/modules/cjs/loader:997:19) at require (node:internal/modules/cjs/helpers:92:18) at Object.\u0026lt;anonymous\u0026gt; (/Users/gotoweb/sw-sprints-cli-practice-master/getListMultiplesOfTwo.js:1:19) at Module._compile (node:internal/modules/cjs/loader:1108:14) ...생략... code: \u0026#39;MODULE_NOT_FOUND\u0026#39;, requireStack: [ \u0026#39;/Users/gotoweb/sw-sprints-cli-practice-master/getListMultiplesOfTwo.js\u0026#39;, \u0026#39;/Users/gotoweb/sw-sprints-cli-practice-master/index.js\u0026#39; ] } npm install range로 설치 range 모듈을 이용하여 getListMultiplesOfTwo함수를 구현(range 모듈 사용법) range(이상, 미만, 증가 수) 이전에 만들었던 과제들도 전부 npm run submit을 이용해 제출 Today\u0026rsquo;s takeaway # 여러 CLI 명령어들을 공부하고 개발을 위한 기본 세팅을 했다. 아직 M1에서는 여러 제한들이 있어서 검색으로 해결했다. 이틀 동안 계산기를 만드느라 바빠서 책(개발자의 글쓰기)을 못 읽었는데, 오늘은 시간이 나서 다시 독서 및 정리를 했다. 아직 개발에 관한 상식이 부족한 나에게 많은 도움이 되고, 관련 일화들도 재미있어서 좋다. 마지막 장이 기술 블로그 쉽게 쓰고 운영하기이니 다 읽고 나서 발전한 블로그를 볼 수 있으면 좋겠다. 탭스 리딩 진단고사를 봤다. 결과는 처참했다. 아무리 영어 공부를 조금 쉬었어도 토익 955점 + 외국인 여자 친구의 영어 자부심이 와르르 무너졌다. 다시 단어부터 차근차근 외우며 영어와 친해져야겠다. 주가 코딩 공부이다 보니 시간도 부족하고, 기본적으로 어휘력이 너무 부족해서 일단 리딩은 단어부터 다 외우고, 리스닝만 공부하기로 결정했다. 내일은 리스닝 진단고사를 치고 공부 계획을 잡을 예정이다. 3,300개의 단어 중에서 0.2초 안에 정확한 뜻을 아는 단어를 걸러내는 작업을 했다. 내일 마무리될 것이다. Tomorrow I\u0026rsquo;ll learn # 하루 종일 깃에 대하여 배울 예정이다. 깃은 버전 관리를 하기 위해 사용하며, 깃허브를 통해 원격 저장소에서 관리할 수 있다. 이미 공부하고 정리한 부분이지만 아직 실전에서 제대로 써본 적이 없기에 기대하고 있다. 각종 명령어와 브랜치의 개념을 배울 것이다. 확실히 아는 단어 고르기 작업을 완료하고 28개의 챕터를 2개씩 묶어 14개 챕터로 만들 것이다. 리스닝 진단고사를 치르고, 리스닝 공부 계획을 세울 것이다. ","date":"1 September 2021","permalink":"/posts/bootcamp/bc-2w-3/","section":"Posts","summary":"Today I learned #CLI 명령어 # 기본적인 이동/생성/삭제/복사 등의 명령어 관리자 권한을 획득하는 명령어 sudo 텍스트 에디터 nano ls -l d: 폴더 / -: 파일 r: 읽기 권한 w: 쓰기 권한 e: 실행 권한 -: 권한 없음 -f는 강제 명령 패키지와 패키지 매니저 Home Brew # eval $(/opt/homebrew/bin/brew shellenv)","title":"BC-2w-3 / [Linux] 기초"},{"content":"Today I learned #계산기 과제 # 어제 혼자 만든 계산기의 코드를 페어에게 설명해주고 페어의 코드 설명도 들었다. 코드를 설명하다 보니 하드코딩의 결과로 쓸모없는 코드들이 눈에 띄었다. 그래서 각자 설명을 마친 뒤 리팩토링을 진행했다. 리팩토링을 하면서 기능 하나하나에 왜 해당 코드를 적었는지 주석을 달다 보니 코드를 한층 더 깊게 이해하고, 쓸모없는 코드들을 찾아서 없앨 수 있었다. 테스트는 모두 통과하였으나 테스트에 없는 엣지 케이스를 찾기 위해 이것저것 눌러보았고, 생각보다 많은 엣지 케이스를 찾아서 처리했다. 시간이 남고 계산기에 빈칸도 존재하여 CE버튼을 추가했다. 기능을 구현하기 위해 많은 고민을 하다가 표로 각 버튼을 눌렀을 때 어떤 값이 어디에 저장되는지를 정리하고, 이를 통해 한 단계 전으로 가기 위해서는 저장된 값들을 어떻게 처리해야 하는지 알게 되었고, 다음은 쉽게 코드로 구현했다.\n*기존 AC버튼은 모든 값을 초기화 하지만 CE버튼은 연산자 다음의 숫자만 초기화한다.\n(Enter가 입력된 상태일 때는 AC버튼과 동일한 기능) 버튼 클릭시 색이 변하고, 연산자는 다음 숫자를 입력하기 전까지 해당 연산자가 클릭된 상태를 유지하게 만들었고, 특정 버튼이 기능하지 않을 때, 설명을 하기 위한 경고 창도 만들었다.\nToday\u0026rsquo;s takeaway # 처음으로 무엇인가 제대로 만들어 봤는데 매우 재미있었다. 동시에 매우 어렵고 신경 쓸 부분이 많다는 것도 배웠다. 과제는 주어진 틀 위에서 만들었기 때문에 주말에 처음부터 끝까지 혼자서 한번 만들어 봐야 할 것 같다. 아마 혼자서 만들다 보면 모르고 놓친 부분도 찾을 수 있을 것이다. 목표는 맥 OS 기본 계산기이다. 저녁식사 후 외형과 클릭 시 색상 변화는 HTML과 CSS를 이용해 제작 완료했다.\n나는 각각 케이스를 나누어서 boolean데이터를 활용하여 조건을 만들었는데, previousKey로 카테고리를 나누어 조건을 만드는 것도 좋은 방법인 것 같다. Tomorrow I\u0026rsquo;ll learn # Linux 기초 터미널에서 사용할 수 있는 다양한 명령어들을 공부할 예정이다. ","date":"31 August 2021","permalink":"/posts/bootcamp/bc-2w-2/","section":"Posts","summary":"Today I learned #계산기 과제 # 어제 혼자 만든 계산기의 코드를 페어에게 설명해주고 페어의 코드 설명도 들었다.","title":"BC-2w-2 / [HTML/CSS] 계산기 만들기"},{"content":"Today I learned #CSS # CSS는 구조의 외부와 내부를 꾸미는 역할 CSS 기본 구조 selector { property: value; } CSS 연결 \u0026lt;link rel=\u0026ldquo;stylesheet\u0026rdquo; href=\u0026quot;./cssName.css\u0026quot;\u0026gt; inline CSS \u0026lt;tag style=\u0026ldquo;property: value;\u0026rdquo;\u0026gt;\u0026hellip;\u0026lt;/tag\u0026gt; 관심사 분리 측면에서 inline은 비추천 id(#) 유일한 구분 요소 class(.) 유일하지 않은 구분 요소 여러 개의 클래스는 띄어쓰기로 구분 QuerySelector 과제 # 기본적인 querySelector사용법과 깃허브에서 Fork와 Pull requests 하는 법을 배움 계산기 과제 # boolean을 이용한 스위치 형태의 조건문 만들기(on/off) .classList를 이용한 elements의 조건 관리 querySelector를 이용한 HTML요소 관리, querySelectorAll과 반복문의 이용 Today\u0026rsquo;s takeaway # 계산기 과제의 advanced 난이도는 현재의 나에게는 매우 힘들었다. 하나의 기능을 구현하고 다른 기능을 추가하면 이전에 구현한 기능에 에러가 생겼다. 결국 몇 번의 시도를 반복한 끝에 모든 테스트를 통과하고 디자인도 마음에 드는 계산기가 완성되었다. 하나하나 하드코딩을 하는 것보다 알고리즘을 확실하게 짠 뒤, 코드를 작성하는 것이 이해하기에 훨씬 좋았다. 하지만 처음 혼자 뭔가를 만들어 보는 나에게는 매우 힘든 일이었다. 그래서 우선 기능 하나하나를 하드코딩으로 구현해 보고, 기능을 어떻게 구현할 수 있는지 이해하고 난 다음 처음부터 다시 알고리즘을 짜서 만들었다. 앞으로는 알고리즘을 확실하게 짜고 코딩을 시작할 수 있게 공부하겠다. 나는 무엇인가 해결하지 못한 게 있으면 해결책을 끊임없이 생각하고 거기서 벗어날 수가 없다. 장점은 해결하기 전까지 엄청난 집중력을 발휘하는 것이고, 단점은 잠도 식사도 거르고 해결에 매달린다는 것이다. 오늘도 아침 새벽 4시가 되어서야 과제를 끝냈다. 이번에는 다음날 일정이 해당 과제를 끝내는 것이라 괜찮지만, 만약 다음날 중요한 일정이 있다면 컨디션에 영향을 줄 것이다. 앞으로는 벨런스 있게 집중을 유지하는 법을 좀 더 연습해야겠다. Tomorrow I\u0026rsquo;ll learn # 계산기 과제 마무리 이미 혼자 마무리했으나, 페어와 협동을 통해 좀 더 완벽하게 만들 것이다. ","date":"30 August 2021","permalink":"/posts/bootcamp/bc-2w-1/","section":"Posts","summary":"Today I learned #CSS # CSS는 구조의 외부와 내부를 꾸미는 역할 CSS 기본 구조 selector { property: value; } CSS 연결 \u0026lt;link rel=\u0026ldquo;stylesheet\u0026rdquo; href=\u0026quot;.","title":"BC-2w-1 / [HTML/CSS] CSS 기초, 계산기 만들기"},{"content":"","date":null,"permalink":"/categories/what-i-read/","section":"Categories","summary":"","title":"\u003cWhat I read\u003e"},{"content":"1주 차 정리 # 월요일에는 학습 환경설정과 학습 방향 설정을 했다. 화요일에는 JS 기초 중에서 변수, 타입, 함수 그리고 조건문을 배웠다. 우리가 아는 같다는 ===으로 표현하고 =은 할당이라는 점이 아직 낯설었다. 처음으로 페어 프로그래밍도 진행하였는데, 서로 이미 알고 있는 내용들이라 쉽고 빠르게 넘어갔다. 수요일에는 문자열을 배우고 조건 문과 문자열 문제를 풀었다. 문제풀이는 페어 프로그래밍으로 진행하였는데, 문제가 어려워 지자 페어 프로그래밍이 빛을 바랐다. 특히 비전공자인 나에게는 이미 개발자로 일해본 적이 있는 페어의 여러 조언들이(조건문은 예외부터 처리하면 쉽다, 리턴은 하는 즉시 함수를 종료 킨다 등) 큰 도움이 되었다. 그리고 몇몇 문제는 페어와는 다른 방식으로 풀어서, 서로 어떻게 풀었는지 설명하면서 자신의 코드를 설명하고 이해시키는 연습도 되었다. 목요일에는 반복문을 배우고 반복문 문제를 풀었다. 반복문은 비전공자인 나에게 낯선 개념이라 애를 먹었다. 특히, return 하는 즉시 함수가 종료되기 때문에 result를 미리 선언하고 반복문 내에서 result에 값을 할당하고, 나중에 return result를 하는 방식과 count를 이용해서 반복 횟수를 세는 방식을 스스로 떠올리기까지 많은 시간이 필요했다. 또한, 이전까지 항상 코드를 어떻게 간결하게 적을지만 생각하던 나에게 break, Math.sqrt(), 초깃값과 변화 내용의 조정 등을 활용한 효율적인 코드(반복 수의 최소화)는 개발자가 어떤 생각을 하면서 코드를 적어야 하는지를 알게 해 줬다. 금요일에는 HTML의 기초를 배우고 동기부여 세션을 진행했다. HTML의 기초는 이미 공부하고 정리해둔 내용이라 추가로 공부할 사항은 없었고, 동기부여 세션은 내가 어떤 개발자가 되고 싶은지(더 나은 세상을 만드는 개발자)를 다시 한번 생각하게 해 줬다. 토요일에는 백신 1차 접종을 하고 푹 쉬었다. 일요일에는 이번 주에 공부한 내용을 복습하며, 문제들도 다시 한번 풀어봤다. 이미 다 알고 있다고 생각하였지만, 다시 한번 풀어보니 생각보다 헷갈리는 부분이 많았다.(복습의 중요성!) 그리고 도서관에 가서 개발에 도움이 될만한 책(개발자의 글쓰기-김철수)을 한 권 골라서 빌려왔다. 책을 읽고 필요한 내용들을 요약해서 블로깅할 것이다. 개발+텝스+독서+운동을 꾸준히 잘 병행해서 생산적인 삶을 살 것이다. 이제까지 점수만을 위한 지루한 공부만 해왔다. 하지만 처음으로 무엇인가 하고 싶은 일이 생겼고, 그것을 위해 공부하는 지금은 공부하는 매 순간이 즐겁고 나중에 어떻게 써먹을지 고민하느라 지겨울 틈이 없다. ","date":"29 August 2021","permalink":"/posts/bootcamp/bc-1w-6/","section":"Posts","summary":"1주 차 정리 # 월요일에는 학습 환경설정과 학습 방향 설정을 했다.","title":"BC-1w-6 / 1주 차 정리"},{"content":" 개발자의 글쓰기는 정확하고 간결하고 가독성이 높아야 한다.\n1장. 개발자가 알아야 할 글쓰기 기본 # 핵심 + 부가 설명 들여 쓰기로 단락을 구조화 「-조사/하다, 숫자-, -기호-」만 붙이고 나머지는 띄어 씀 비슷한 의미를 지닌 영단어의 뉘앙스 차이(for 함수명) stop(중단) - restart(재개) / end(종료) - begin(새롭게 시작) / finish(끝)\n/ pause(잠시 중단) / suspend(다음 단계 시작을 중단) / hold(의도적으로 중단) get(값을 가져옴) / retrieve(값을 검색해서 가져옴) / acquire(값을 독점적으로 가져옴)\n/ fetch(현제 값을 가리키는 포인터가 다음 값으로 이동한 것을 가져옴) set(값을 할당) / init(초기값 할당) create(틀을 만듦) / register(만들어진 틀에 값을 입력) change(내용 변화) / modify(틀린 내용 수정) / revise(새로운 내용으로 개정) must(필수) / should(권고) / do(행동) is(boolean 데이터) 2장. 개발 시간을 줄여주는 이름 짓기와 주석 쓰기 # 네이밍 컨벤션 클래스\n: PascalCase\n함수와 변수\n: camelCase\n상수\n: UPPER_DELIMITER_CASE\n패키지와 모듈\n: lowercase 명사+명사+명사\n동사+명사+명사\n형용사+명사+명사 BEM 클래스 표기법 대상__요소\u0026ndash;상태 변수 이름 명확한 의미(Ex. d, day -\u0026gt; today, someday) 복수는 짧을 때는 -s, 길 때는 listOf-나 arrayOf-로 표현 \u0026lt;함수 만들기\u0026gt; 필요한 기능을 문장으로 작성 사용자가 할 일은 삭제(bcs 함수는 시스템이 할 일) 문장을 정리(중복내용 삭제)해서 세세하게 분리 1 함수 1 업무 원칙으로 문장 재분리(기능 별로 묶음) 기능별 함수 작성, 이름은 기능 설명 좋은 이름의 기준, SMART easy to Search 고전적 범주화 Ex. userBuyer, userPayer, userRegister easy to Mix 상위 태그와 조합 Ex. h1.title, h2.title, p.title easy to Agree 구별할 필요가 없는 것까지 이름을 새로 지을 필요 없음 easy to Remember 이미 널리 알려진 용어는 그냥 쓰는 것이 효율적 easy to Type 입력하기 쉽고, 오타를 낼 가능성이 적은 이름 주석 \u0026ldquo;코드는 의미를, 주석은 의도를\u0026rdquo; 주석은 디버깅으로 바로 잡을 수 없으니, 개발자가 신경 써야 함 3장. 사용자와 소통하는 에러 메시지 쓰기 # 에러의 내용, 원인, 해결법을 알려 줘야 함\n(해결법을 먼저 쓰거나 내용은 생략해도 됨) 예/아니오 보다는 구체적인 행동을 선택지로 제시\n(Ex. 페이지에 머물기/페이지에서 나가기) 버튼의 순서에 일관성이 있어야 함 비활성화를 활용해 에러를 미리 예방하자 4장. 독자 관점에서 릴리스 문서와 장애 보고서 쓰기 # 릴리즈 문서 체인지 로그 선정하기 회사와 개발자가 말하고 싶은 것과 독자가 듣고 싶은 것 중 두 개 이상 만족하는 것 선정 분류하기 독자에 따라 개발 관점에서 비슷한 내용 혹은 사용 관점에서 비슷한 내용으로 분류 요약하기 불필요한 부사, 형용사, 조사, 어미 제거 종합하기 종합은 분석의 개념화와 반대로 특징이나 결과로 서술 Semantic Versioning major.minor.patch 기존 버전과 호환이 안 되는 변화. 기존 버전과 호환이 되는 새로운 기능 추가. 작은 규모의 패치 장애 보고서 문제, 문제점, 해결책, 후순 계획 순서로 작성 면책 조항 필수 필수, 권장, 선택, 예외 사항 표기 장애 보고서 구성 장애 내용 장애 영향 장애 원인 조치 사항 조치 결과 핵심 원인 향후 대책 장애의 근본 원인을 찾기 위해 원인의 원인을 계속 찾아라(5 whys) 재발을 막기 위해서는 원인 대신 이유를 묻고 사람 주어로 대답하라 개발 관점은 기능이 작동하지 않은 것, 비즈니스 관점은 손실이 발생한 것 모호하게 말고 정확한 정보를 적어라(Ex. 재발 가능성 30%) 5장. 설명, 묘사, 논증, 서사로 개발 가이드 쓰기 # 서비스 개념을 범주, 용도, 특징으로 설명하라 용도는 범주의 핵심 기능을 써라 특징은 장점(자신 기준)과 강점(경쟁사와 비교)에서 뽑아 써라 이해를 돕기 위해 그림과 글로 묘사해라 주관적 묘사와 객관적 묘사를 둘 다 써라 의견을 쓰려면 근거를 대라 주장과 이유, 문제와 답의 거리를 좁혀라 순서에서 단계를 단계에서 목차를 만들어라 6장. 수주를 돕는 SI 제안서 쓰기 # 고객의 문제인식이 중대하고 제안사의 문제 해결 능력이 탁월할 때,\n경쟁사와 비교하여 강점들을 제안하라 고객의 문제인식이 중대하고 제안사의 문제 해결 능력이 부족할 때,\n일단 동감하고 경쟁사와 다른 방안을 제시하라 고객의 문제인식이 사소하고 제안사의 문제 해결 능력이 탁월할 때,\n고객이 문제를 중대하게 인식하게 만들어라 고객의 문제인식이 중대하고 제안사의 문제 해결 능력이 부족할 때,\n경쟁사의 전략을 확인해서 대처하라 요구사항을 분석하지말고 제시하라 변화하는 요구사항에 대비하라 투 트랙 방식 사용(전체 검수와 기능별 검수) 개발 시간 대비 고객의 예상 만족도가 높은 것 위주로 개발하라 7장. 기술 블로그 쉽게 쓰고 운영하기 # 주제 의식을 버리고 소재 의식으로 쓰자 독자 수준이 아니라 자기 수준으로 쓰자 저 직접 경험하고 실험한 과정이나 결과 목차를 잘 잡고 본문부터 써라 술 어떤 것을 분석하여 의미를 풀이하고 해석한 것 원전을 비교하고 실험해 풀이해서 써라 편 산만하고 복잡한 자료를 편집해 질서를 부여한 것 순서를 요약해서 써라 집 여러 사람의 견해나 흩어진 자료를 한데 모아 정리한 것 자료를 모아 핵심을 엮어 써라 Ps. 느낀점 # 개발을 막 시작한 시점에서 함수나 변수명을 작명하는 방법이 가장 직접적으로 도움이 되었다. 다른 부분들은 취업 후에 본격적으로 도움이 될 거 같다. 가장 인상 깊었던 부분은 장점(자신 기준)과 강점(경쟁사와 비교)의 분류였다. 정확하고 간결하게 글을 쓰자! 3 March 2022 짧지만 프로젝트를 진행해 보고 다시 정리 글을 읽어보니 아는 것과 실행하는 것의 난이도는 엄청난 차이가 있다는 것을 절감했다. 특히 함수 만들기 부분을 제대로 적용하지 못했다. 당장 필요한 함수를 만드는 것에 집중하다 보니 함수 하나에 너무 많은 기능이 들어가게 되었고, 이름을 짓기도 어려웠다. 리팩토링 과정에서는 이 책의 내용을 복기하면서 제대로 만들 것이다. ","date":"29 August 2021","permalink":"/posts/what-i-read/wir-1/","section":"Posts","summary":"개발자의 글쓰기는 정확하고 간결하고 가독성이 높아야 한다.","title":"개발자의 글쓰기 - 김철수"},{"content":"Today I learned # HTML(Structure), CSS(Presentation), JS(Interaction)\nHTML # 웹 페이지를 구성하는 마크업 언어 트리구조 태그들의 집합 닫힌 태그: 열린 태그: 자주 쓰는 태그 설명 \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; block level tag, 한 줄 차지 \u0026lt;span\u0026gt;\u0026lt;/span\u0026gt; inline level tag, 콘텐츠 크기만큼 공간 차지 \u0026lt;img src=\u0026rsquo;\u0026rsquo; /\u0026gt; 이미지 삽입 \u0026lt;a\u0026gt;\u0026lt;/a\u0026gt; 링크 삽입 \u0026lt;ul\u0026gt;\u0026lt;/ul\u0026gt; 순서가 없는 목록 묶음(부모 요소) \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; 목록(자식 요소) \u0026lt;input type=\u0026rsquo;\u0026rsquo;\u0026gt;\u0026lt;/input\u0026gt; 사용자가 직접 입력하는 부분 \u0026lt;textarea\u0026gt;\u0026lt;/textarea\u0026gt; 줄 바꿈이 되는 입력 폼 \u0026lt;button\u0026gt;\u0026lt;/button\u0026gt; 버튼 Today\u0026rsquo;s takeaway # 전에 혼자 공부할 때는 div로 다 처리하면 되지 왜 굳이 header, section 등의 sematic tag를 쓰는지 이해하지 못했었다. 이제는 나 스스로도 구조를 파악하기 쉽고, 무엇보다 나와 함께 작업할 동료가 읽기 편해서 쓴다는 점을 이해했다. 동기부여 세션을 진행했다. 어떤 개발자가 되기 위해서 지금 공부하고 있는지 다시 한번 생각해 보는 계기가 되었다. 나는 이 세상을 조금이라도 더 나은 방향으로 바꿀 수 있는 서비스를 만드는 개발자가 되고 싶다. 구매를 했던 텝스 책이 오늘 도착했다. 본격적인 공부에 앞서 텝스 단어 PDF를 엑셀 파일로 변환하여 단어장 앱에 넣었다. 이 과정에서도 수도 코드를 활용해 일일이 수정해야 할 부분을 필터와 함수 매크로 등을 이용해 조금 더 빠르고 쉽게 끝낼 수 있었다. 토익의 경우는 점수만을 위해 빠르게 3주 동안 하루 종일 공부하고 시험을 쳤지만, 이번 텝스는 영어 실력을 기르기 위해 공부하는 것이니, 꾸준히 차근차근 내실을 쌓을 것이다. 물론 주 공부는 코딩이지만 남는 틈틈이 잘해보겠다. Weekend I\u0026rsquo;ll learn # 이번 주에 공부했던 내용들을 다시 한번 읽고, 기억해야 할 부분들을 다시 한번 기록할 것이다. 백신을 맞는 날이라 간단한 복습 후 푹 쉴 것이다. 단어장에서 이미 알고 있는 단어와 모르는 단어를 구분해서 공부할 양을 줄일 것이다. ","date":"27 August 2021","permalink":"/posts/bootcamp/bc-1w-5/","section":"Posts","summary":"Today I learned # HTML(Structure), CSS(Presentation), JS(Interaction)","title":"BC-1w-5 / [HTML/CSS] HTML 기초"},{"content":"","date":null,"permalink":"/tags/html/","section":"Tags","summary":"","title":"HTML"},{"content":"Today I learned #반복문 # 같거나 비슷한 코드를 여러 번 실행시켜야 할 경우에 씀 for(초기값; 반복 조건; 증감값) { 반복 내용 } 초기값\nwhile(반복 조건) { 반복 내용; 증감값;} 반복문 문제 # 1-증감 연산자(for 구문에서는 전위, 후위 상관없음)\n++/\u0026ndash;a는 값을 먼저 1 증가/감소시킨 뒤 연산 a++/\u0026ndash;는 연산을 먼저 한 뒤 값을 1 증가/감소 5-result\nfunction func(str, num) { let result = str; if (num === 0) { return \u0026#34;\u0026#34;; } else { for (n = 1; n \u0026lt; num; n += 1) { result += str; // 결과에 값을 누적 } return result; } } 8-count\nfunction func(num) { let result = \u0026#34;\u0026#34;; let n = 1; while (n \u0026lt;= num * 2) { // 홀수 num개는 (num * 2 / 2)개임 // Ex. 홀수 3개는 1~6(3*2)까지 중에 홀수 if (n % 2 !== 0) { result += `${n}`; } n += 1; } return result; } /* let result = \u0026#34;\u0026#34;; let count = 0; let i = 1; while (count \u0026lt; num) { result = result + String(i); i = i + 2; count++; } return result; */ 17-소수와 효율성!!\nfunction func(num) { // 약수는 루트값을 중심으로 대칭 // Ex. 81의 약수는 1, 3, √81, 27, 81 const sqrt = Math.sqrt(num); // 유일한 짝수인 소수 if (num === 2) { return true; } // 2를 제외한 짝수와 1은 소수가 될 수 없다 if (num % 2 === 0 || num === 1) { return false; } // 홀수의 약수는 홀수 // \u0026lt;= 인 이유는 루트값만 약수로 가지는 수 때문 for (let i = 3; i \u0026lt;= sqrt; i += 2) { if (num % i === 0) { return false; } } return true; } 13-이중 반복문\nfunction func(num) { let result = \u0026#34;2\u0026#34;; for (let i = 3; i \u0026lt;= num; i += 2) { let isPrime = true; for (let j = 3; j \u0026lt;= Math.sqrt(i); j += 2) { if (i % j === 0) { isPrime = false; break; // 효율성을 위해 false를 발견 하는 순간 종료 } } if (isPrime) { result += `-${i}`; } } return result; } 20\nfunction func(str) { for (let i = 0; i \u0026lt; str.length - 1; i++) { for (let j = i + 1; j \u0026lt; str.length; j++) { if (str[i] === str[j]) { return true; } } } return false; } Today\u0026rsquo;s takeaway # 내가 작성한 코드를 페어에게 설명하는 것이 생각보다 힘들었다. 수도코드와 주석을 통해 항상 왜 이런 식으로 작성했는지를 생각하고 기록해야겠다. 다른 사람의 코드를 읽는 능력이 많이 부족하다. 나와 작성 방식이 조금만 달라져도 알아보기 힘들다. 다양한 코드들을 많이 읽고 쓰면서 관련 능력을 기를 것이다. 항상 오타를 조심하고 신경쓰자! Tomorrow I\u0026rsquo;ll learn # HTML과 CSS를 배운다. 이미 혼자서 학습했던 부분이라 크게 걱정되지는 않는다. HTML은 구조, CSS는 스타일, JS는 기능을 담당한다. ","date":"26 August 2021","permalink":"/posts/bootcamp/bc-1w-4/","section":"Posts","summary":"Today I learned #반복문 # 같거나 비슷한 코드를 여러 번 실행시켜야 할 경우에 씀 for(초기값; 반복 조건; 증감값) { 반복 내용 } 초기값","title":"BC-1w-4 / [JS/Node] 반복문"},{"content":"Today I learned #조건문 문제 # 03\nfunction func(num) { //ref return num === 10 if (num === 10) { return true; } else { return false; } } 11\nfunction func(num1, num2) { if (num1 \u0026lt; 10 \u0026amp;\u0026amp; num2 \u0026lt; 10 \u0026amp;\u0026amp; (num1 % 2 !== 0 || num2 % 2 !== 0)) { return true; } else { return false; } } function ref(num1, num2) { // if 안의 if if (num1 \u0026lt; 10 \u0026amp;\u0026amp; num2 \u0026lt; 10) { if (num1 % 2 !== 0 || num2 % 2 !== 0) { return true; } } return false; } 13\nfunction func(score) { let onesDigit = score % 10; let grade = \u0026#34;\u0026#34;; let sign = \u0026#34;\u0026#34;; // 가장 예외부터 걸러냄 if (score \u0026gt; 100 || score \u0026lt; 0) { return \u0026#34;불가능한 점수입니다.\u0026#34;; } if (score === 100) { return \u0026#34;수+\u0026#34;; } if (score \u0026gt;= 90) { grade = \u0026#34;수\u0026#34;; } else if (score \u0026gt;= 80) { grade = \u0026#34;우\u0026#34;; } else if (score \u0026gt;= 70) { grade = \u0026#34;미\u0026#34;; } else if (score \u0026gt;= 60) { grade = \u0026#34;양\u0026#34;; } else if (score \u0026lt; 60) { return \u0026#34;가\u0026#34;; } if (onesDigit \u0026lt;= 2) { sign = \u0026#34;-\u0026#34;; } else if (onesDigit \u0026gt;= 8) { sign = \u0026#34;+\u0026#34;; } return grade + sign; } 14-제곱을 구하는 3가지 방법\nx * x x ** 2 Math.pow(x, 2) 16\nfunction func(hh, mm, ss) { if (hh === 23 \u0026amp;\u0026amp; mm === 59 \u0026amp;\u0026amp; ss === 59) { return \u0026#34;1초 뒤에 0시 0분 0초 입니다\u0026#34;; } else if (mm === 59 \u0026amp;\u0026amp; ss === 59) { return `1초 뒤에 ${hh + 1}시 0분 0초 입니다`; } else if (ss === 59) { return `1초 뒤에 ${hh}시 ${mm + 1}분 0초 입니다`; } else { return `1초 뒤에 ${hh}시 ${mm}분 ${ss + 1}초 입니다`; } } /* 좀 더 보편적인 조건 if (ss === 59) { mm += 1; ss = 0; } else { ss += 1; } if (mm === 60) { hh += 1; mm = 0; } if (hh === 24) { hh = 0; } return \u0026#34;1초 뒤에 \u0026#34; + hh + \u0026#34;시 \u0026#34; + mm + \u0026#34;분 \u0026#34; + ss + \u0026#34;초 입니다\u0026#34;; } */ 문자열 # str[n]은 char 문자열은 string(str), 문자 하나는 character(char) index로 접근은 가능하지만 쓸 수는 없음(read-only) +를 이용해서 문자열을 합칠 수 있음 string을 다른 타입과 같이 +를 쓰면, string 형식으로 변환 .length로 문자열의 길이를 알 수 있음 .indexOf(searchValue)나. lastIndexOf(searchValue)로 원하는 문자의 index를 찾을 수 있음 .includes(searchValue)로 문자 포함 여부를 알 수 있음, 구형 브라우저(IE)에서는 작동 안 함 .split(separator)는 separator을 기준으로 분리된 문자열이 포함된 배열을 반환 Ex. \u0026lsquo;Hello from the other side\u0026rsquo;. split(\u0026rsquo; \u0026lsquo;)은 [\u0026lsquo;Hello\u0026rsquo;, \u0026lsquo;from\u0026rsquo;, the\u0026rsquo;, \u0026lsquo;other\u0026rsquo;, \u0026lsquo;side\u0026rsquo;] csv형식을 처리할 때 유용 Ex. let csv =\n`연도,제조사,모델,설명,가격\n1997,Ford,E350,\u0026ldquo;ac, abs, moon\u0026rdquo;,3000.00\n1999,Chevy,\u0026ldquo;Venture \u0026ldquo;\u0026ldquo;Extended Edition\u0026rdquo;\u0026rdquo;\u0026rdquo;,\u0026quot;\u0026quot;,4900.00\n1999,Chevy,\u0026ldquo;Venture \u0026ldquo;\u0026ldquo;Extended Edition, Very Large\u0026rdquo;\u0026rdquo;\u0026rdquo;,,5000.00\n1996,Jeep,Grand Cherokee,\u0026ldquo;MUST SELL!\nair, moon roof, loaded\u0026rdquo;,4799.00`\nlet lines = csv.split(\u0026rsquo;\\n\u0026rsquo;)\nlines[0].split(\u0026rsquo;,\u0026rsquo;)은 [\u0026lsquo;연도\u0026rsquo;, \u0026lsquo;제조사\u0026rsquo;, \u0026lsquo;모델\u0026rsquo;, \u0026lsquo;설명\u0026rsquo;, \u0026lsquo;가격\u0026rsquo;]\n*줄바꿈은 \u0026lsquo;\\n\u0026rsquo;으로 찾을 수 있음 .slice(start, end)로 문자열을 원하는 만큼 선택 가능(~이상~미만) .toUpperCase()와 .toLowerCade()로 대소문자 변경 가능 모든 string타입 메소드는 원본을 변형시키지 않음 추가 사항(스스로 공부) .trim(), .replace(), 정규표현식 이스케이프 시퀀스 \\n: enter, \\t: tap, \\b: backspace 문자열 문제 # 17\nfunction func(name, period) { if (period \u0026lt; 60) { return `${name}: ${period}분 전에 접속함`; } else if (period \u0026gt;= 60 \u0026amp;\u0026amp; period \u0026lt; 1440) { period = Math.floor(period / 60); return `${name}: ${period}시간 전에 접속함`; } else if (period \u0026gt;= 1440) { period = Math.floor(period / 1440); return `${name}: ${period}일 전에 접속함`; } } // 나누기를 이용한 단위의 구분​ Today\u0026rsquo;s takeaway # 아는 내용이었지만, 직접 문제들을 풀어보니 알기만 하는 것과 직접 코드를 써보는 것은 차이가 매우 컸다. if 문을 사용할 때는 순서가 매우 중요하고, return을 하면 그 즉시 함수가 종료된다. 페어 프로그래밍도 페어와의 커뮤니케이션을 통해 점점 더 좋아지고 있다. 첫날은 문제를 푸는 것에만 집중을 했다면, 오늘은 문제를 푸는 과정을 설명하는 것에도 집중했다. Tomorrow I\u0026rsquo;ll learn # 반복문 for() 반복문의 활용 간단한 기능을 반복하여 수행시킬 수 있음 ","date":"25 August 2021","permalink":"/posts/bootcamp/bc-1w-3/","section":"Posts","summary":"Today I learned #조건문 문제 # 03","title":"BC-1w-3 / [JS/Node] 조건문, 문자열"},{"content":"Today I learned #변수 # 변수 기초 변수란 이름이 붙은 값 메모리에 저장된 변수(데이터)를 불러내서 활용 가능 카멜 케이스로 작성 선언과 할당 선언 let 재할당 가능 const 재할당 불가능 할당 (여기에) = (여기를 할당) Ex.\n선언: let myName\n할당: myName = \u0026lsquo;Yuchan\u0026rsquo;\n선언 + 할당: let myName = \u0026lsquo;Yuchan\u0026rsquo; 타입 # 원시형 데이터 string, number, boolean, null, undefined 참조형 데이터 array, object, function 함수 # 함수 기초 논리적인 일련의 작업을 하는 하나의 단위 코드들이 하나의 블록에 모인 것 반복적인 일처리 가능 입력(parameter)과 출력(return)의 매핑 리턴이 없을 때, undefined 선언(매개변수, parameter)과 호출(전달 인자, argument) 함수 선언 함수 선언식(기명 함수)\nfunction getFullName(firstName, lastName) {\nreturn console.log(`${firstName} ${fullName}`)\n} 함수 표현식(익명 함수)\nconst getFullName = function(firstName, lastName) {\nreturn console.log(`${firstName} ${fullName}`)\n} 화살표 함수\nconst getFullName = (firstName, lastName) =\u0026gt;\nconsole.log(`${firstName} ${fullName}`)\n*{return} 생략 가능\nbut 한 줄의 단순한 형태일 때만 생략하자(bcs 직관성 해침) 코드 학습법 # 구글링도 중요한 능력 mdn, how to 를 적극 활용 하자 개발자 도구 활용(크롬은 F12, 사파리는 cmd+opt+i) 코플릿(코드 스테이츠 학습 플랫폼)에서 테스트 진행 모르는 내용은 고민 후 아고라(코드 스테이츠 버전 Stack Overflow)에 질문 조건문 # 원할 때만 기능이 작동하도록 할때, 조건문이 필요함 비교 연산자 연산자 설명 \u0026gt; 초과 \u0026lt; 미만 \u0026gt;= 이상 \u0026lt;= 이하 === 같다(타입 까지) !== 다르다(타입 까지) == 값만 같다 != 값만 다르다 if 조건문\nif (조건 1) {\n// 조건 1이 통과할 경우\n} else if (조건 2) {\n// 조건2가 통과할 경우\n} else {\n// 모든 조건이 통과하지 않을 경우\n}\n*조건에는 boolean 데이터 논리 연산자 연산자 설명 || or \u0026amp;\u0026amp; and ! truthy와 falsy(false, null, undefined, \u0026lsquo;\u0026rsquo;, 0, NaN)를 반전 ps. 에러 메시지 알아보기 # 엣지 케이스(극단적인 상황)에서도 에러가 나지 않아야 함 디버그 과정 문제의 요구사항 파악 테스트 케이스 확인 테스트 실패 이유 확인 from 에러 메시지 ps. 알고리즘 # 문제를 해결하기 위한 일련의 절차나 방법을 의미 너무나 당연한 과정을 기계가 이해할 수 있도록 세분화해서 논리적으로 접근 하지만 처음부터 세분화해서 접근하기는 어렵기 때문에, 수도 코드(자연어로 작성된 절차)를 먼저 작성 알고리즘 작성 과정 전제 문제를 작은 문제로 분해 수도코드(pseudo code) 작성 코드 작성 *반복된 코드를 작성하고 있다면, 좀 더 보편화(하나의 코드로 처리)되게 만드는 게 좋음\n*하나의 코드가 하나의 기능만 해야지 여러 기능을 하는건 좋지 않음\nToday\u0026rsquo;s takeaway # 본격적인 공부 시작! 아직은 기초를 다지는 부분인데다 이미 혼자서 공부했던 부분이라 쉽게 따라가고 있다. 처음으로 페어 프로그래밍 진행! 파트너가 전공자+전직 개발자라 첫 번째 과제는 아주 쉽고 빠르게 통과했다. 난이도가 더 올라가기 전에 내실을 튼튼히 다져 놓아야겠다. Tomorrow I\u0026rsquo;ll learn # 조건문 아침에 바로 페어 프로그래밍으로 문제풀이 진행 문자열 String.prototype.method()와 정규표현식을 사용한 문자열 다루기 ","date":"24 August 2021","permalink":"/posts/bootcamp/bc-1w-2/","section":"Posts","summary":"Today I learned #변수 # 변수 기초 변수란 이름이 붙은 값 메모리에 저장된 변수(데이터)를 불러내서 활용 가능 카멜 케이스로 작성 선언과 할당 선언 let 재할당 가능 const 재할당 불가능 할당 (여기에) = (여기를 할당) Ex.","title":"BC-1w-2 / [JS/Node] 변수, 타입, 함수"},{"content":"Today I learned #학습 환경 설정 # UrClass Zoom Discord Notion GitHub GoogleCalendar 학습 방향 설정 # 자기 주도 학습 개발자는 끊임없이 학습해야한다.\n그렇기에 스스로 학습하는 능력을 길러야 한다. 협업 원활한 협업이 주는 시너지 효과는 매우 크다.\n이를 위해서는 커뮤니케이션 능력이 중요하다. 수도 코드 수도 코드는 이질적인 자연어와 프로그래밍 언어 사이를 중계한다. 기록 기록은 증명이자 무기가 된다. Today\u0026rsquo;s takeaway # 이미 사전 공지했던 사안들을 다시 한번 확인하면서 진행하였기에 크게 할 것은 없었다. 그 덕에 학습 방향 설정에 좀 더 많은 시간을 투자할 수 있었다. 블로그에는 그날 그날 배운 내용을 간략히 기록하고, 자세한 내용은 GitHub의 WIL(what I learned)에 정리할 것이다. (Ps. WIL을 블로그로 이동) Tomorrow I\u0026rsquo;ll learn # JS 변수 const와 let으로 선언 데이터를 저장하고 불러서 씀 = 은 같다는 의미가 아니라 할당 JS 타입 원시형 자료 string, number, boolean, null, undefined 참조형 자료 array, object, function JS 함수 기명 함수, 익명 함수, 화살표 함수, 즉시 실행 함수, 콜백함수 등 함수 그 자체와 선언의 구분 JS 조건문 if, case로 조건에 따라 다른 처리 Ps. Blog Log #2021-09-21 티스토리 블로그에서 갓허브 블로그로 이전 시작 # 반복되는 에러(특히 코드 블록) 발생으로 인한 시간 낭비 때문에 블로그 이전에 시간이 소요되더라도 장기적으로 이전이 더 이득이라고 판단. 2021-09-22 Jekyll에서 Hugo로 변경 # 로컬 서버 구축과 포스팅에 문제가 발생하여 해결을 시도하였으나, 추가 에러가 계속 발생하여 속도도 더 빠른 Hugo로 블로그 재개설. 2021-09-24 Github with Hugo로 게시물 이전 완료 # 티스토리 블로그에서 적은 글들을 마크다운 형식으로 수정해서 깃허브 블로그로 이전하면서, 해당 내용 복습.\n*hugo serve로 로컬 서버 오픈\n*./push.sh로 배포 2022-01-29 Today I Learn 카테고리에서 Coding Bootcamp로 카테고리 전환 # 혼자 추가로 학습한 부분도 많이 들어 있으나 부트캠프를 진행하는 동안 배운 내용임을 표현하고 싶어서 카테고리 전환. 부트캠프가 끝난 다음부터는 학습하는 내용들을 카테고리별로 정리할 예정. 2022-03-16 테마 변경 # Today I Learn 카테고리에서 Bootcamp로 카테고리 전환. 더 마음에 드는 테마를 발견하여 테마 변경. 이 과정에서 변경 사항이 submodule에 반영이 되지 않는 에러를 만났고, 해결법을 찾지 못해서 레포지토리 삭제 후 재개설. ","date":"23 August 2021","permalink":"/posts/bootcamp/bc-1w-1/","section":"Posts","summary":"Today I learned #학습 환경 설정 # UrClass Zoom Discord Notion GitHub GoogleCalendar 학습 방향 설정 # 자기 주도 학습 개발자는 끊임없이 학습해야한다.","title":"BC-1w-1 / [학습 방향] Learn How to Learn"},{"content":"","date":null,"permalink":"/tags/summary/","section":"Tags","summary":"","title":"(Summary)"},{"content":"","date":null,"permalink":"/categories/%5Csummaries/","section":"Categories","summary":"","title":"\\summaries"},{"content":"","date":null,"permalink":"/categories/what-i-learned/","section":"Categories","summary":"","title":"\u003cWhat I learned\u003e"},{"content":" Cascading Style Sheets\nselector { property: value; } Selector #1. 복합 선택자 # Selector Details selector1selector2 일치 선택자 selector1 selector2 하위 선택자 selector1 \u0026gt; selector2 자식 선택자 selector1 + selector2 인접 형제 선택자 selector1 ~ selector2 일반 형제 선택자 2. 가상 클래스 선택자 # Selector Details selector:hover 커서 selector:active 클릭 selector:focus 포커스 selector:first-child 첫 번째 자식 요소 selector:last-child 마지막 자식 요소 selector:nth-child(n) n 번째 자식 요소 selector:not(\u0026hellip;) \u0026hellip;이 아닌 것 selector:link 방문하지 않은 링크 selector:visited 방문한 링크 selector::before { content: \u0026ldquo;\u0026hellip;\u0026rdquo;; } 내용 앞에 \u0026hellip; 삽입 selector::after { content: \u0026ldquo;\u0026hellip;\u0026rdquo;; } 내용 뒤에 \u0026hellip; 삽입 3. 속성 선택자 # Selector Details [attribute] 해당 속성 tag[attribute] 해당 태그 중 해당 속성 [attribute=\u0026ldquo;value\u0026rdquo;] 해당 속성의 해당 값 [attribute~=\u0026ldquo;value\u0026rdquo;] 해당 값 \u0026amp; 해당 값 포함(띄어쓰기) [attribute|=\u0026ldquo;value\u0026rdquo;] 해당 값 \u0026amp; 해당 값-으로 시작 [attribute^=\u0026ldquo;value\u0026rdquo;] 해당 값으로 시작 [attribute$=\u0026ldquo;value\u0026rdquo;] 해당 값으로 끝 [attribute*=\u0026ldquo;value\u0026rdquo;] 해당 값 포함 Property #1. Box model Style #크기\nProperty Details width 넓이 height 높이 max/min-width 최대/최소 넓이 max/min-height 최대/최소 높이 여백 및 테두리\nProperty Details margin 외부 여백, 음수 가능 padding 내부 여백, 내용 선택 가능 border: width style color 테두리└ style solid | dotted | dashed border-radius 테두리 둥글게 깍는 정도 boxing-size: border-box; 크기가 내부 여백과 테두리 포함 (원래는 컨텐츠 크기만 포함) 출력\nProperty Details display: none; | flex; | block; 요소 출력 방식 opacity 투명도(0~1) overflow: hidden; | auto; 넘친 내용 제어: 잘라냄 | 자른 후 스크롤바 생성 box-shadow: x y blur color 그림자 2. Text \u0026amp; Font Style #문자\nProperty Details text-align: left; | right; | center; | justify; 문자 정렬 text-decoration: none; | underline; | line-through; 문자를 꾸미는 선 text-transform: uppercase; | lowercase; 대소문자 변환 text-indent 들여쓰기, 내어쓰기(음수) line-height 행간 letter-spacing 자간 글자\nProperty Details color 글자 색상 font-size 글자 크기 font-weight: 400; | 700; 글자 두께: normal | bold font-style: italic; 이탤릭체 font-family: 글꼴1, “글꼴 2”, …, 글꼴계열 글꼴└ 글꼴계열 - serif | san-serif 3. Background # Property Details background-color 배경색 background-image: url(\u0026quot;\u0026hellip;\u0026quot;) 배경 이미지 background-repeat: repeat; (def) | repeat-x/y; | no-repeat; 배경 반복 background-position: top bottom left right center;: x y; 배경 위치 background-size: contain;: cover;: x y; 배경 크기: 더 좁은 범위 맞춤: 더 넓은 범위 맞춤: 가로 x, 세로 y background-attachment: fixed; 배경 뷰포트에 고정 4. Position # Property Details position^: relative;: absolute;: fixed;: sticky; 기준: 자신 기준: 부모(position 필요) 기준: 뷰포트 기준 고정: 스크롤 시 뷰포트 기준 고정 topbottomleft right 위치 z-index 쌓임 맥락에서 자신의 위치 sticky가 작동하지 않을 때 확인 사항\r고정될 위치를 지녀야함\r부모 요소가 %가 아닌 height 값을 지녀야 함\r상위 요소에 overflow 속성이 없어야 함\r5. Flex #Flex container (부모 요소)\nProperty Details display: flex;: inline-flex; 요소 출력 방식: container가 block요소: container가 inline요소 justify-content: flex-start; (def): flex-end;: center;: space-between;: space-around; items 주축(수평) 정렬: 시작점 정렬: 끝점 정렬: 가운데 정렬: 나눔정렬(양 끝 붙임): 나눔정렬(양 끝 띄움) align-content items 교차축(수직) 정렬,2줄 이상일 때 묶어서 정렬 align-items: stretch; (def): flex-start;: flex-end;: center; items 교차축(수직) 정렬: 늘림: 시작점 정렬: 끝점 정렬: 가운데 정렬 flex-wrap: wrap; items 줄바꿈 허가 gap items 간격 flex-direction: row; (def): column; 주축 방향: 수평 주축: 수직 주축 Flex item (자식 요소)\nProperty Details Default order 순서(오름차순), 음수가능 0 align-self 개별 item의 교차축 정렬 auto flex^ grow, shrink, basis의 단축 속성 1 1 auto flex-grow item의 증가 너비 비율 1 flex-shrink item의 감소 너비 비율 1 flex-basis item의 기본 너비, 주로 0 auto 6. Transition \u0026amp; Transform #Transition (전환)\nProperty Details transition^: property duration timing-function delay 해당 요소 변화 시 전환 효과└ timing-function - ease | linear | ease-in | ease-out Transform (변환)\nProperty Details transform^: scale(xy | x, y);: translate(x | x, y);: skew(x | x, y);: rotate(deg);: perspective(n);: rotateX/Y(deg); 형태 변환: 크기 변환: 위치 변환: 기울기 변환: 2d 회전: 3d 원근감 (먼저 작성 필요): 3d 회전 backface-visibility: hidden; 뒷면 감추기 7. Etc # Property Details cursor^ 커서 모양 -moz-user-select: none;\n-webkit-user-select: none;\n-ms-user-select: none;\nuser-select: none; 사용자가 텍스트 선택 못함 scroll-snap-type : x/y mandatory; | proximity; ^\nscroll-snap-align: start; | end; | center; snap 축 (부모요소에 입력)\nsnap 위치 (자식요소에 입력) Etc # @media^\n/* 데스크탑 스타일 */ @media screen and (max-width: 768px) { /* 모바일 스타일 */ } --- /* 모바일 스타일 */ @media screen and (min-width: 769px) { /* 데스크탑 스타일 */ } :root⋯\n:is()⋯\nmodule.css⋯\nEtc\n우선순위는 inline \u0026gt; #id \u0026gt; .class \u0026gt; tag \u0026gt; * \u0026gt; 나중에 적힌 순\n*value !important;는 최우선 순위 방향 단축 특성은 \u0026ldquo;상하 좌우\u0026rdquo;, \u0026ldquo;상 좌우 하\u0026rdquo;, \u0026ldquo;상 우 하 좌\u0026rdquo;\n*margin, padding, gap에 적용 문자관련 특성은 자동 상속 색상: white, #fff, rgb(0,0,0), rgba(0,0,0,.5) 크기: px, %, vw, vh, em, rem @import url(\u0026quot;...\u0026quot;)로 CSS 병열 연결 ","date":null,"permalink":"/what-i-learned/html-css/css/","section":"What I Learneds","summary":"Cascading Style Sheets","title":"CSS"},{"content":"Root Selector #:root { --background-color: #f4f5f6; } body { background-color: var(--background-color); } is Pseudo Selector #:is(section, article, aside, nav) :is(h1, h2, h3, h4, h5, h6) { color: #f4f5f6; } /* ... which would be the equivalent of: */ section h1, section h2, section h3, section h4, section h5, section h6, article h1, article h2, article h3, article h4, article h5, article h6, aside h1, aside h2, aside h3, aside h4, aside h5, aside h6, nav h1, nav h2, nav h3, nav h4, nav h5, nav h6 { color: #f4f5f6; } CSS Module + classnames #- classnames\nnpm i classnames /* example.module.css */ :global(.inner) /* module의 고유화 방지 */ { width: 1200px; /* 최대 넓이 */ max-width: 100%; /* 모바일용 */ margin: 0 auto; /* 가로 가운데 정렬 (auto는 양쪽의 여백을 같게 만들겠다는 뜻) */ position: relative; } .show { display: block; } .hide { display: none; } import styles from \u0026#34;./example.module.css\u0026#34;; import classNames from \u0026#34;classnames/bind\u0026#34;; const cx() = classNames.bind(styles); export default function Example() { return ( \u0026lt;div className={styles.inner}\u0026gt; \u0026lt;h1 className={cx(\u0026#34;show\u0026#34;, { hide: false })}\u0026gt;Hello world!\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } ","date":null,"permalink":"/storage/wil/html-css/ex-css/","section":"Storages","summary":"Root Selector #:root { --background-color: #f4f5f6; } body { background-color: var(--background-color); } is Pseudo Selector #:is(section, article, aside, nav) :is(h1, h2, h3, h4, h5, h6) { color: #f4f5f6; } /* .","title":"CSS Example"},{"content":"1) 기본 설정 # Command Details git init 깃 추적 시작 git config --global --list 기본 설정 보기 git config --global core.autocrlf true 개행문자 설정 git config --global user.name YuchanJeong 사용자 이름 설정 git config --global user.email yuchanjeong0923@gmail.com 사용자 메일 설정 git config --global core.editor vim 기본 에디터 설정 git config --global init.defaultBranch main 기본 브랜치 설정 git config --global commit.template ~/.gitmessage.txt 커밋 템플릿 설정 .vimrc\rset nocompatible \u0026#34; 오리지날 VI와 호환하지 않음 set autoindent \u0026#34; 자동 들여쓰기 set cindent \u0026#34; C 프로그래밍용 자동 들여쓰기 set smartindent \u0026#34; 스마트한 들여쓰기 set wrap set nowrapscan \u0026#34; 검색할 때 문서의 끝에서 처음으로 안돌아감 set nobackup \u0026#34; 백업 파일을 안만듬 set noswapfile \u0026#34;set visualbell \u0026#34; 키를 잘못눌렀을 때 화면 프레시 set ruler \u0026#34; 화면 우측 하단에 현재 커서의 위치(줄,칸) 표시 set shiftwidth=4 \u0026#34; 자동 들여쓰기 4칸 set number \u0026#34; 행번호 표시, set nu 도 가능 set fencs=ucs-bom,utf-8,euc-kr.latin1 \u0026#34; 한글 파일은 euc-kr로, 유니코드는 유니코드로 set fileencoding=utf-8 \u0026#34; 파일저장인코딩 set tenc=utf-8 \u0026#34; 터미널 인코딩 \u0026#34;set expandtab \u0026#34; 탭대신 스페이스 set hlsearch \u0026#34; 검색어 강조, set hls 도 가능 set ignorecase \u0026#34; 검색시 대소문자 무시, set ic 도 가능 set tabstop=4 \u0026#34; 탭을 4칸으로 set lbr set incsearch \u0026#34; 키워드 입력시 점진적 검색 set cursorline \u0026#34; 편집 위치에 커서 라인 설정 set laststatus=2 \u0026#34; 상태바 표시를 항상한다 syntax on \u0026#34; 구문강조 사용 filetype indent on \u0026#34; 파일 종류에 따른 구문강조 set background=dark \u0026#34; 하이라이팅 lihgt / dark set backspace=eol,start,indent \u0026#34; 줄의 끝, 시작, 들여쓰기에서 백스페이스시 이전줄로 set history=1000 \u0026#34; vi 편집기록 기억갯수 .viminfo에 기록 highlight Comment term=bold cterm=bold ctermfg=4 \u0026#34; 코멘트 하이라이트 set mouse=a \u0026#34; vim에서 마우스 사용 set t_Co=256 \u0026#34; 색 조정 2) 원격 저장소 # Command Details git remote -v 원격 저장소 연결 확인 git remote add [name] [url] 원격 저장소 연결 git remote remove [name] 원격 저장소 연결 해제 git push [name] [branch] (-f) 원격 저장소에 Push (강제) git pull [name] [branch] (--rebase) 원격 저장소 Pull (이어 붙히기) git clone [url] ([directory]) 원격 저장소 복사 (폴더명) 3) 파일 상태 # Command Details git status 파일 상태 확인 git diff 파일 상태 비교*작업역역과 스테이지 차이 git diff --cached 파일 상태 비교*스테이지와 저장소 차이 git diff [commit] [commit] 커밋 간 상태 비교 git diff [branch] [branch] 브랜치 간 상태 비교 4) 스테이징 (추가) # Command Details git add -p 변경 내용을 확인 후 청크 별로 추가*y(추가), n(제외), q(종료) git add [directory] 해당 폴더 및 하위 폴더의 변경 내용을 추가 git add . 현재 폴더 및 하위 폴더의 변경 내용을 추가 5) 커밋 (확정) # Command Details git commit 커밋 생성 git commit -m \u0026ldquo;[msg]\u0026rdquo; 커밋 메시지와 함께 커밋 생성 git commit -am \u0026ldquo;[msg]\u0026rdquo; 스테이징 후 커밋 메시지와 함께 커밋 생성 *한 번 이상 커밋 한 파일만 가능 git commit --amend 마지막 커밋 메시지 수정 6) 커밋 기록 # Command Details git log 커밋 기록 보기 git log -p 커밋 기록과 패치내용 보기 git log --stat 커밋 기록과 패치통계 보기 git log --graph 커밋 기록과 그래프 보기 git log [branch]..[branch] 후자에만 있는 커밋 기록 보기 7) 되돌리기 # Command Details git reset --hard [commit] | HEAD[~n] 해당 커밋으로 되돌린 후이후의 커밋, 스테이징, 작업 초기화 git reset [commit] | HEAD[~n] 해당 커밋으로 되돌린 후이후의 커밋, 스테이징 초기화 git reset --soft [commit] | HEAD[~n] 해당 커밋으로 되돌린 후이후의 커밋 초기화 git revert [commit] 해당 커밋의 수정사항 취소 후 새 커밋 생성 git revert [commit]..[commit] 해당 범위의 수정사항 취소 후 새 커밋 생성 git rebase -i [commit] | HEAD[~n] p: 커밋 그냥 사용, 재정렬 및 삭제 가능r: 커밋 메시지 수정e: 커밋 메시지 및 내용 수정*HEAD가 해당 커밋으로 이동, 추가 작업 가능*git rebase --continue (작업 종료)*git rebase --abort (작업 중단)s: squash merged: 커밋 삭제 8) 임시 저장 # Command Details git stash (-u) 임시 저장 후 직전 커밋 상태로 되돌아감 (새 파일도)*한 번 이상 스테이징 한 파일만 가능 git stash list 임시 저장 목록 보기 git stash apply (stash@{[n]}) 최근(해당) 임시 저장 상태로 돌아가기 git stash drop (stash@{[n]}) 최근(해당) 임시 저장 상태 지우기 git stash pop 최근 임시 저장 상태 apply 후 drop 9) 브랜치 # Command Details git branch (-a) 브랜치 목록 보기 (원격 목록도) git branch [branch] 브랜치 생성 git branch -d [branch] 해당 브랜치 삭제 git branch -m [branch] [branch] 브랜치명 바꾸기 git checkout [branch] 브랜치 전환 git checkout -b [branch] 브랜치 생성 후 전환 git checkout -t [branch] 원격 브랜치 가져오기 후 전환 git merge [branch] (--squash) 현재 브랜치에 해당 브랜치 병합 (스쿼시 병합) git rebase [branch] 현재 브랜치에 해당 브랜치 이어 붙이기 10) 삭제 # Command Details git rm (--cached) [file] 해당 파일 삭제 (원격에서만) git rm -r (--cached) [directory] 해당 폴더 삭제 (원격에서만) git fetch --all --prune 원격 브랜치 흔적 삭제 Etc #1) .gitignore # List Details example.xxx 해당 파일명 전부 제외 /example.xxx 현재 폴더의 해당 파일 제외 example/ 해당 폴더와 하위 경로 제외 example/example.xxx 해당 폴더의 해당 파일 제외 *.xxx 특정 확장자 파일 전부 제외 !example.xxx 예외 파일명 (버전 관리 ON) 2) SSH 등록 # ssh-keygen으로 ~/.ssh/에 id_rsa.pub(공개키)와 id_rsa(개인키) 생성 공개키를 Github의 Settings/SSH and GPG keys에 등록 3) Github 계정 오류 # 키체인 접근 -\u0026gt; github.com ","date":null,"permalink":"/posts/summaries/git/","section":"Posts","summary":"1) 기본 설정 # Command Details git init 깃 추적 시작 git config --global --list 기본 설정 보기 git config --global core.","title":"Git"},{"content":" Work Space -add-\u0026gt; Stage -commit-\u0026gt; Local Repo -push-\u0026gt; Remote Repo\n버전 관리 #1. .gitignore # List Details [fileName.ext] 해당 파일명 전부 제외 /[fileName.ext] 현재 폴더의 해당 파일 제외 [folderName]/ 해당 폴더의 하위 경로 제외 [folderName]/[fileName.ext] 해당 폴더의 해당 파일 제외 *.[ext] 특정 확장자 파일 전부 제외 ![fileName.ext] 예외 파일명 (버전 관리 ON) 2. 시작 \u0026amp; 전역 속성 # Command Details git init 깃 추적 시작 git config \u0026ndash;global core.autocrlf true 개행문자 설정 git config \u0026ndash;global user.name \u0026ldquo;[사용자 이름]\u0026rdquo; 사용자 이름 설정 git config \u0026ndash;global user.email \u0026ldquo;[사용자 메일]\u0026rdquo; 사용자 메일 설정 git config \u0026ndash;global core.editor \u0026ldquo;[vim|nano]\u0026rdquo; 에디터 vim|nano로 설정 git config \u0026ndash;global commit.template ~/.gitmessage.txt commit 템플릿 설정 git config \u0026ndash;global \u0026ndash;list 전역 속성 보기 3. 원격 저장소 # Command Details git remote add [원격 저장소 이름] [주소] 원격 저장소에 연결 git remote remove [원격 저장소 이름] 원격 저장소 연결 해제 git remote -v 원격 저장소 연결 확인 git push [원격 저장소 이름] [브랜치명] 로컬 저장소를 원격 저장소에 Push git pull [원격 저장소 이름] [브랜치명] 원격 저장소를 로컬 저장소에 Pull git clone [주소] ([폴더명]) 현재 폴더에 클론폴더(폴더명) 생성 4. 파일 상태 # Command Details git status 파일 상태 확인 git diff 파일 상태 비교(작업역역과 스테이지 차이) git diff \u0026ndash;cached 파일 상태 비교(스테이지와 저장소 차이) git diff [커밋ID] [커밋ID] 커밋간 상태 비교 git diff [브랜치명] [브랜치명] 브랜치간 상태 비교 5. 스테이징 (추가) # Command Details git add -p 변경 내용을 확인하고 헝큰 별로 추가*y(추가), n(제외), q(종료) git add [경로명] 해당 폴더 및 하위 폴더의 변경 내용을 추가 git add . 현재 폴더 및 하위 폴더의 변경 내용을 추가 6. 커밋 (확정) # Command Details git commit 커밋 생성 git commit -m \u0026ldquo;[메시지]\u0026rdquo; 메시지와 함께 커밋 생성 git commit -am \u0026ldquo;[메시지]\u0026rdquo; 스테이징 후 커밋*한번 이상 커밋한 파일만 가능 git commit \u0026ndash;amend 마지막 커밋 메시지 수정 7. 커밋 기록 # Command Details git log 커밋 기록 보기 git log -p 커밋 기록과 패치내용 보기 git log \u0026ndash;stat 커밋 기록과 패치통계 보기 git log \u0026ndash;online 커밋ID와 메시지만 보기 git log [브랜치명]..[브랜치명] 후자에만 있는 커밋 기록 보기 8. 작업 되돌리기 # Command Details git reset \u0026ndash;hard [커밋ID]|HEAD[~n] 해당 커밋으로 되돌린 후이후의 커밋, 스테이징, 작업 초기화 git reset [커밋ID]|HEAD[~n] 해당 커밋으로 되돌린 후이후의 커밋, 스테이징 초기화 git reset \u0026ndash;soft [커밋ID]|HEAD[~n] 해당 커밋으로 되돌린 후이후의 커밋만 초기화 git revert [커밋ID] 해당 커밋의 수정사항 취소 후 새 커밋 생성 git revert [커밋ID]..[커밋ID] 해당 범위의 수정사항 취소 후 새 커밋 생성 9. 작업 임시 저장 # Command Details git stash (-u) 임시 저장 후 이전 커밋 상태로 되돌아감\n(새로 추가한 파일도 임시 저장)*한번 이상 스테이징한 파일만 임시 저장 git stash list 스태시 목록 보기 git stash pop 최근 스태시 apply 후 drop git stash apply (stash@{[n]}) 최근(해당) 스태시 상대로 돌아가기 git stash drop (stash@{[n]}) 최근(해당) 스태시 지우기 브랜치 #1. 브랜치 목록 및 관리 # Command Details git branch (-a) 브랜치 목록(+원격 목록) 보기 git branch [브랜치명] 브랜치 생성 git branch -d [브랜치명] 해당 브랜치 삭제 git branch -m [브랜치명] [브랜치명] 브랜치명 바꾸기 2. 브랜치 전환 및 병합 # Command Details git checkout [브랜치명] 브랜치 전환 git checkout -b [브랜치명] 브랜치 생성 후 전환 git checkout -t [원격저장소명]/[브랜치명] 원격 브랜치 로드 후 전환 git merge [브랜치명] 현재 브랜치에 해당 브랜치 병합 Etc #1. 파일 및 폴더 삭제 # Command Details git rm (\u0026ndash;cached) [파일명] 해당 파일 지움(원격에서만 지움) git rm -r (\u0026ndash;cached) [경로명] 해당 폴더 지움(원격에서만 지움) 2. Fork를 이용한 공동작업 # Fork로 내 원격 저장소에 다른 원격 저장소의 파일 찍어오기 로컬에 불러와서 작업 후 내 원격 저장소에 Push 내 원격 저장소에서 Pull Request 3. SSH 등록 # ssh-keygen ~/.ssh/에 id_rsa.pub(공개키)와 id_rsa(개인키) 생성 cat ~/.ssh/id_rsa.pub 공개키를 복사해서 Settings -\u0026gt; SSH and GPG keys에 등록 4. GitHub 계정 오류 있을 때 # 키체인 접근 -\u0026gt; github.com ","date":null,"permalink":"/what-i-learned/etc/git/","section":"What I Learneds","summary":"Work Space -add-\u0026gt; Stage -commit-\u0026gt; Local Repo -push-\u0026gt; Remote Repo","title":"Git"},{"content":" Command Details brew update brew 자체 업데이트 brew outdated 업데이트 필요한 파일 조회 brew upgrade [프로그램명] 프로그램 업그레이드 brew search [프로그램명] 프로그램 검색 brew info [프로그램명] 프로그램 정보 확인 brew install [프로그램명] 프로그램 설치 brew uninstall [프로그램명] 프로그램 삭제 brew list 설치된 프로그램 보기 ","date":null,"permalink":"/storage/wil/etc/homebrew/","section":"Storages","summary":" Command Details brew update brew 자체 업데이트 brew outdated 업데이트 필요한 파일 조회 brew upgrade [프로그램명] 프로그램 업그레이드 brew search [프로그램명] 프로그램 검색 brew info [프로그램명] 프로그램 정보 확인 brew install [프로그램명] 프로그램 설치 brew uninstall [프로그램명] 프로그램 삭제 brew list 설치된 프로그램 보기 ","title":"HomeBrew"},{"content":" HyperText Markup Language\n\u0026lt;tag attribute=\u0026#34;value\u0026#34;\u0026gt;contents\u0026lt;/tag\u0026gt; Head #1. Meta Tag #\u0026lt;meta name=\u0026#34;author\u0026#34; content=\u0026#34;...\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;...\u0026#34; /\u0026gt; SEO\n\u0026lt;meta name=\u0026#34;keywords\u0026#34; content=\u0026#34;..., ...\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;robots\u0026#34; content=\u0026#34;noindex, nofollow\u0026#34; /\u0026gt; Open Graph^\n\u0026lt;meta property=\u0026#34;og:type\u0026#34; content=\u0026#34;website\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:site_name\u0026#34; content=\u0026#34;...\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:title\u0026#34; content=\u0026#34;...\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:description\u0026#34; content=\u0026#34;...\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;...\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:url\u0026#34; content=\u0026#34;...\u0026#34; /\u0026gt; Twitter Cards^\n\u0026lt;meta property=\u0026#34;twitter:card\u0026#34; content=\u0026#34;summary\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;twitter:site\u0026#34; content=\u0026#34;...\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;twitter:title\u0026#34; content=\u0026#34;...\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;twitter:description\u0026#34; content=\u0026#34;...\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;twitter:image\u0026#34; content=\u0026#34;...\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;twitter:url\u0026#34; content=\u0026#34;...\u0026#34; /\u0026gt; 2. Favicon #\u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;...\u0026#34; /\u0026gt; \u0026lt;!-- └ /favicon.ico로 대체 가능 --\u0026gt; \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;...\u0026#34; /\u0026gt; 3. Style Reset #\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/reset-css@5.0.1/reset.min.css\u0026#34; /\u0026gt; 4. CSS 연결 #\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;...\u0026#34; /\u0026gt; 5. JS 연결 #\u0026lt;script defer|async src=\u0026#34;...\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 순서 적용 defer 문서 위치 순 DOM 전체가 필요한 스크립트나 실행 순서가 중요한 경우 적용 async 다운로드 순 독립적인 스크립트나 실행 순서가 중요하지 않은 경우 적용 Tag # Global Attribute Details title=\u0026quot;\u0026hellip;\u0026quot; 커서 시 설명 class=\u0026quot;\u0026hellip; \u0026hellip;\u0026quot; 중복 가능한 이름 (.) id=\u0026quot;\u0026hellip;\u0026quot; 고유한 이름 (#) style=\u0026ldquo;property: value; \u0026hellip;;\u0026rdquo; 인라인 스타일 1. Block Level Tag #- 요소가 수직으로 쌓임\n- 가로는 부모 요소의 크기만큼 자동으로 늘어남\n- 세로는 포함한 콘텐츠의 크기만큼 자동으로 줄어듦\n\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;h1-6\u0026gt;\u0026lt;/h1-6\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;br /\u0026gt; 2. Inline Level Tag #- 요소가 수평으로 나열됨\n- 포함한 콘텐츠의 크기만큼 자동으로 줄어듦\n- Inline 요소 하위에는 Block 요소 불가능\n\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;img src=\u0026#34;...\u0026#34; alt=\u0026#34;...\u0026#34; /\u0026gt; \u0026lt;a href=\u0026#34;...\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;!-- └ target=\u0026#34;_blank\u0026#34;로 새 창에서 열기 가능 --\u0026gt; \u0026lt;!-- └ #ID로 문서 내 연결 가능 --\u0026gt; \u0026lt;button onClick=\u0026#34;...\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; 3. List Tag #\u0026lt;!-- 순서가 있는 목록 --\u0026gt; \u0026lt;ol\u0026gt;\u0026lt;/ol\u0026gt; \u0026lt;!-- 순서가 없는 목록 --\u0026gt; \u0026lt;ul\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;!-- 목록 요소 --\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; 4. Form Tag #- form, input\n\u0026lt;form\u0026gt;\u0026lt;/form\u0026gt; \u0026lt;input type=\u0026#34;...\u0026#34; /\u0026gt; \u0026lt;!-- 폼을 하나의 그룹으로 묶음 --\u0026gt; \u0026lt;fieldset\u0026gt;\u0026lt;/fieldset\u0026gt; \u0026lt;!-- 폼 그룹의 제목 --\u0026gt; \u0026lt;legend\u0026gt;\u0026lt;/legend\u0026gt; \u0026lt;!-- input과 contents 연결 --\u0026gt; \u0026lt;label\u0026gt;\u0026lt;/label\u0026gt; Ex.\n\u0026lt;form action=\u0026#34;javascript:void(0)\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;fieldset\u0026gt; \u0026lt;legend\u0026gt;Alphabet\u0026lt;/legend\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;Alphabet\u0026#34; required /\u0026gt;A\u0026lt;/label\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;Alphabet\u0026#34; required /\u0026gt;B\u0026lt;/label\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;Alphabet\u0026#34; required /\u0026gt;C\u0026lt;/label\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;/form\u0026gt; 5. Select Tag #- select, option\n\u0026lt;select\u0026gt; \u0026lt;option value=\u0026#34;...\u0026#34;\u0026gt;contents\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; 6. Multimedia Tag #- audio\n\u0026lt;audio src=\u0026#34;경로\u0026#34;\u0026gt;\u0026lt;/audio\u0026gt; - video\n\u0026lt;video src=\u0026#34;경로\u0026#34;\u0026gt;\u0026lt;/video\u0026gt; 7. Semantic Tag #\u0026lt;header\u0026gt;\u0026lt;/header\u0026gt; \u0026lt;section\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;nav\u0026gt;\u0026lt;/nav\u0026gt; \u0026lt;aside\u0026gt;\u0026lt;/aside\u0026gt; \u0026lt;footer\u0026gt;\u0026lt;/footer\u0026gt; Etc # ! HTML 기본 형태 구성 BEM 클래스 속성 작명법 Block__Element\u0026ndash;Modifier javascript:void(0) 경로 지정 시 주소를 할당하지 않고 기능만 확인 Emmet Ex. ul#Father\u0026gt;(li.Son\u0026gt;a)*5 ","date":null,"permalink":"/what-i-learned/html-css/html/","section":"What I Learneds","summary":"HyperText Markup Language","title":"HTML"},{"content":"JS Data #1. Type # Data Type Details string - 쌍따음표(\u0026quot;\u0026quot;)나 따음표(\u0026rsquo;\u0026rsquo;)로 감싸서 표현\n- Template literals(`${변수}`)로 변수 사용 가능\n- +로 합치기 가능(이때 다른 타입은 문자화)\n- str[n]으로 character 읽기 가능(read only)\n- String(data), data.toString()으로 문자화 가능\n*Escape Sequence\nㅤ└ \\n (new line)\nㅤ└ \\t (tap) number - Number(str)로 숫자화 가능\nㅤ*숫자가 아닌 문자열이 있으면 NaN\n- parseInt(str)로 정수화 가능, parseFloat(str)으로 숫자화 가능\nㅤ*숫자가 아닌 문자열이 뒤에 있으면 숫자인 부분까지 숫자화 boolean true | false array - 대괄호([])로 감싸서 표현\n- arr[i]로 element 읽기 가능\n- arr[i] = value로 arr의 i index에 value 할당 가능\n- new Array.from({ length: n })으로 n개의 undefined를 가진 배열 생성 가능\n- new Array(n).fill(element)로 n개의 element를 가진 배열 생성 가능 object - 중괄호({})로 감싸서 표현\n- odj.key와 obj[str]으로 value 읽기 가능\n- odj.key = value와 obj[str] = value로 obj의 key에 value (생성)할당 가능\n- delete obj[str]로 key-value 삭제 가능\n- str in obj로 key 존재 여부 판단 가능*Optional Chainingㅤ└ obj.key1?.key2는 key1이 있을 때만 key2 확인 null 의도적으로 비움 undefined 값이 할당되지 않음 falsy false, null, undefined, \u0026ldquo;\u0026rdquo;, 0, NaN (나머지는 truthy) typeof 평가 전 데이터 타입을 string으로 반환 function은 \u0026ldquo;function\u0026rdquo; undeclared variable은 \u0026ldquo;undefined\u0026rdquo; null과 array는 \u0026ldquo;object\u0026rdquo; null은 data === null로 판단 array는 Array.isArray(data)로 판단 NaN은 isNaN(number)으로 판단 2. Properties \u0026amp; Methods #1) String #\rProperties \u0026 Methods\rReturn\rstr.length\r문자열 안의 코드 유닛 수\rstr.indexOf(searchValue[, fromIndex])\rsearchValue의 첫 번째 등장 인덱스,\n찾을 수 없으면 -1\n*.lastIndexOf()는 마지막 등장 인덱스\rstr.includes(searchValue[, fromIndex])\rsearchValue를 포함하고 있는지 여부\rstr.slice(beginIndex[, endIndex])\r추출된 부분(~이상~미만)을 담는 새로운 string\rstr.split([separator[, limit]])\rseparator(문자열|정규식)로 끊은 문자열들의 array\rstr.match(regexp)\r정규식과 일치하는 문자열을 포함하는 array,\n찾을 수 없으면 null\n*g옵션이 없을 때 캡처된 그룹 및 정보도 배열에 포함\rstr.replace(regexp|subStr, newSubStr|function)\r패턴과 처음 일치하는 부분이 교체된 새로운 string\n*.replaceAll()은 모든 일치 문자 교체\rstr.toUpperCase()\nstr.toLowerCase()\r모두 대문자로 바꾼 string\n모두 소문자로 바꾼 string\rstr.trim()\r양끝의 공백을 제거한 string\r2) Number \u0026amp; Math #\rProperties \u0026 Methods\rReturn\rnum.toFixed([digits])\r고정 소수점 표기법을 사용하여 나타낸 수의 string\n*digits: 소수점 뒤에 나타날 자릿수, 기본값 0\rMath.abs(x)\r숫자의 절댓값\rMath.max([x[, y[, …]]])\nMath.min([x[, y[, …]]])\r0개 이상의 인수 중에서 제일 큰 수\n0개 이상의 인수 중에서 제일 작은 수\rMath.ceil(x)\nMath.floor(x)\nMath.round(x)\r인수보다 크거나 같은 수 중에서 가장 작은 정수\n인수보다 작거나 같은 수 중에서 가장 큰 정수\n인수에 가장 가까운 정수\rMath.sqrt(x)\r√x\rMath.pow(x, n)\rx의 n제곱값\rMath.random()\r0 이상 1 미만의 부동소수점 의사 난수\r3) Array #\rProperties \u0026 Methods\rReturn\rarr.length\r배열 안의 요소 수\n*arr.length === 0은 빈 배열\rarr.indexOf(searchValue[, beginIndex])\rsearchValue의 첫 번째 등장 인덱스,\n찾을 수 없으면 -1\n*.lastIndexOf()는 마지막 등장 인덱스\rarr.includes(searchValue[, beginIndex])\rsearchValue를 요소로 포함하고 있는지 여부\rarr.slice(beginIndex[, endIndex])\r추출된 부분(~이상~미만)을 담는 array\rarr.join([separator])\r모든 요소를 separator로 구분지어 연결한 string\n*separator를 생략하면 쉼표(,)로 구분\rarr.concat([value1[, ...[, valueN]]])\r콜백 배열이나 값들을 기존 배열에 합친 array\rarr.forEach(callback(currentValue\n[, index[, array]])[, thisArg])\rundefined\n*콜백 함수를 각 요소에 대해 실행\rarr.map(callback(currentValue\n[, index[, array]])[, thisArg])\r콜백 함수를 각 요소에 대해 실행한 결과의 array\rarr.filter(callback(currentValue\n[, index[, array]])[, thisArg])\r콜백 함수의 결과가 참인 요소의 array\rarr.find(callback(currentValue\n[, index[, array]])[, thisArg])\r콜백 함수의 결과가 참인 요소 중 첫 번째 item,\n찾을 수 없으면 undefined\rarr.findIndex(callback(currentValue\n[, index[, array]])[, thisArg])\r콜백 함수의 결과가 참인 요소 중 첫 번째 요소의 인덱스,\n찾을 수 없으면 -1\rarr.reduce(callback(accValue[, curValue\n[, curIndex[, array)[, initialValue]]]])\r콜백 함수의 누적 결과 값(last accValue)\n*initialValue는 첫 accValue의 값이며,\n생략 시 arr[0]이 첫 accValue, arr[1]이 첫 curValue\rarr.sort([compareFunction])\r정열된 array(원본)\rarr.reverse()\r순서가 반전된 array(원본)\rarr.splice(beginIndex[, deleteCount\n[, item1[, ...[, itemN]]]])\r제거한 요소를 담은 array\n*배열(원본)의 요소를 교체\n*deleteCount를 생략하면 배열(원본)의 마지막까지 삭제\rarr.push(item1[, ...[, itemN]])\r요소가 추가된 배열의 새로운 length\n*배열(원본)의 끝에 하나 이상의 요소를 추가\n*.unshift()는 배열(원본)의 앞에 추가\rarr.pop(item1[, ...[, itemN]])\r배열의 마지막 item\n*배열(원본)의 마지막 요소 삭제\n*.shift()는 배열(원본)의 첫 번째 요소 삭제\rarr.flat([depth])\rdepth 번 만큼 다차원 배열을 푼 array\n*depth의 기본값은 1\r*beginIndex, endIndex의 값이 음수일 때, 끝에서부터의 위치를 의미 4) Object #\rProperties \u0026 Methods\rReturn\rObject.assign(target, ...sources)\r출처 객체들로부터 하나 이상의 속성들이 복사된 목표 object\n*동일한 키를 갖는 속성은 뒤의 출처 값으로 덮어쓰여짐\rObject.keys(obj)\r모든 속성의 키(문자열)를 반환한 array\n*Object.values(obj)는 값의 array\rObject.fromEntries(arr)\r[key, value] 형태의 다차원 배열을 변환한 object\n*Object.entries(obj)는 [key, value] 형태의 이차원 array\rObject.hasOwnProperty(key)\r특정 프로퍼티를 가지고 있는지 여부\r3. Etc #1) Destructuring Assignment(구조 분해 할당)\n배열/객체의 속성을 해체 후 그 값을 개별 변수에 할당하는 표현식\nArray const arr = [1, 2, 3, 4, 5]; const [a, , b, ...rest] = arr; // a는 1, b는 3, rest는 [4, 5] Object const obj = { name: \u0026#34;X\u0026#34;, age: 10, gender: \u0026#34;male\u0026#34; }; const { name, gender: sex, address = \u0026#34;Korea\u0026#34; } = obj; // name는 \u0026#34;X\u0026#34;, sex는 \u0026#34;male\u0026#34;, address는 \u0026#34;Korea\u0026#34; 2) Spread Syntax(전개 구문)\n\u0026hellip;data의 형태로 문자열·배열·객체를 펼치는 표현식\nString const str = \u0026#34;Che\u0026#34;; // [...str]는 [\u0026#34;C\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;e\u0026#34;] // {...str}는 { \u0026#34;0\u0026#34;: \u0026#34;C\u0026#34;, \u0026#34;1\u0026#34;: \u0026#34;h\u0026#34;, \u0026#34;2\u0026#34;: \u0026#34;e\u0026#34; } Array const arr1 = [1, 2, 3]; // [...arr1]은 [1, 2, 3], !== arr1 // {...arr1}는 { \u0026#34;0\u0026#34;: 1, \u0026#34;1\u0026#34;: 2, \u0026#34;2\u0026#34;: 3 } const arr2 = [4, 5, 6]; // [...arr1, ...arr2]는 [1, 2, 3, 4, 5, 6] Object const obj = { a: 1, b: 2, c: 3 }; // {...obj1}은 { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 3 }, !== obj1 const obj2 = { c: 1, d: 2, e: 3 }; // {...obj1, ...obj2}는 { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 1, \u0026#34;d\u0026#34;: 2, \u0026#34;e\u0026#34;: 3} Rest Prams const func = (team, ...members) =\u0026gt; ({ 팀: team, 멤버: members }); const myTeam = func(\u0026#34;KT\u0026#34;, \u0026#34;Smeb\u0026#34;, \u0026#34;Score\u0026#34;, \u0026#34;Ucal\u0026#34;, \u0026#34;Deft\u0026#34;, \u0026#34;Mata\u0026#34;); /* myTeam은 { 팀: \u0026#34;KT\u0026#34;, 멤버: [\u0026#34;Smeb\u0026#34;, \u0026#34;Score\u0026#34;, \u0026#34;Ucal\u0026#34;, \u0026#34;Deft\u0026#34;, \u0026#34;Mata\u0026#34;], }; */ 3) Immutability(불변성)\nPrimitive Type(원시 타입) string, number, boolean, undefined, null 변수에 값을 저장 immutable Reference Type(참조형 타입) array, object, function 변수에 heap의 주소를 저장, 값은 heap에 저장 같은 주소(heap)를 참조할 때 하나 변화 시 일괄 변화 mutable 4) Shallow Copy(얕은 복사) \u0026amp; Deep Copy(깊은 복사)\nShallow Copy 복사한 참조형 데이터 내부의 참조형 데이터는 같은 주소 참조 Deep Copy 복사한 참조형 데이터 내부의 참조형 데이터도 다른 주소 참조 JS Operator #1) Ternary Operator(삼항 연산자)\n조건 ? 조건이 true일 때 : 조건이 false일 때 2) Logical Operator(논리 연산자)\nOperator\rDetails\r\u0026\u0026\r- and (모두 truthy일 때 true)\n- leftExpr \u0026\u0026 rightExpr\nㅤ└ leftExpr이 truthy일 때, rightExpr\nㅤ└ leftExpr이 falsy일 때, leftExpr\r||\r- or (하나라도 truthy일 때 true)\n- leftExpr || rightExpr\nㅤ└ leftExpr이 truthy일 때, leftExpr\nㅤ└ leftExpr이 falsy일 때, rightExpr\r??\r- leftExpr ?? rightExpr (nullish coalescing(널 병합))\nㅤ└ leftExpr이 null 혹은 undefined가 아닐 때, leftExpr ㅤ└ leftExpr이 null 혹은 undefined 때, rightExpr\r!\r- not (falsy일 때 true)\r3) Comparison Operator(비교 연산자)\nOperator\rDetails\ra === b\r값과 타입이 같을 때 true\ra !== b\r값이나 타입이 다를 때 true\ra \u003e b\ra \u003e b일 때 true\ra \u003c b\ra \u003c b일 때 true\ra \u003e= b\ra \u003e= b일 때 true\ra \u003c= b\ra \u003c= b일 때 true\r4) Arithmetic Operator(산술 연산자)\nOperator\rDetails\ra + b\r덧셈\ra - b\r뺄셈\ra * b\r곱셈\ra / b\r나눗셈\ra % b\r나머지\r5) Assignment Operator(할당 연산자)\nOperator\rDetails\ra += b\ra = a + b\ra -= b\ra = a - b\ra *= b\ra = a * b\ra /= b\ra = a / b\ra %= b\ra = a % b\r6) Increment Operator(증감 연산자)\nOperator\rDetails\ra++/--\r연산 후 1증가/감소\r++/--a\r1증가/감소 후 연산\rJS Control Statement #1) Conditional Statement(조건문)\nif 조건문 if (조건1) { 조건1이 truthy일 때 } else if (조건n) { 조건n이 truthy일 때 } else { 조건이 모두 falsy일 때 } switch 조건문 switch (대상) { case 케이스n: 대상이 케이스n일 때 break; default: 해당 케이스가 없을 때 } 2) Iterative Statement(반복문)\nfor 반복문\nfor (초기값; 반복 조건; 증감값) { 반복내용; } // for of 배열 for (let item of iterator) { 반복내용; } // for in 객체 for (let key in object) { 반복내용; } while 반복문\nwhile (반복 조건) { 반복 내용 } Escape Details break 해당 반복문 종료 continue 해당 반복 내용을 종료하고 다음 반복으로 넘어감 label 해당 label의 반복문을 대상으로 함 outer: for (item of arr) { inner: for (el of item) { if (el === 0) { break outer; } if (el === 1) { continue inner; } } } JS Function #1) 함수 작성\nNamed Function Declaration(기명 함수 선언)\nfunction 함수() {} 호이스팅 시 일시적 사각지대(코드 실행 전까지 초기화가 일어나지 않음)에 빠지지 않음 Anonymous Function Expression(익명 함수 표현)\nconst 변수 = function () {}; Arrow Function(화살표 함수)\nconst 변수 = () =\u0026gt; {}; 인자가 하나일 때, 인자의 소괄호 생략 가능 { return } 생략 가능 객체 데이터는 소괄호로 묶어야 함 메서드 함수로 적합하지 않음 생성자 함수로 사용할 수 없음 2) 고차 함수\nTimer Function(타이머 함수)\nType Details setImmediate(콜백) 즉시 함수 실행*setTimeout(콜백, 0) 사용은 지양 setTimeout(콜백, ms) 일정 시간 후 함수 실행 setInterval(콜백, ms) 일정 시간 마다 함수 실행 clearImmediate(타이머) 해당 Immediate 함수를 종료 clearTimeout(타이머) 해당 Timeout 함수를 종료 clearInterval(타이머) 해당 Interval 함수를 종료 Callback Function(콜백 함수)\n함수의 「인자」로 사용되는 함수 function timeout(cb) { setTimeout(() =\u0026gt; { console.log(\u0026#34;start\u0026#34;); // 함수의 실행 위치 보장 cb(); }, 1000); } timeout(() =\u0026gt; { console.log(\u0026#34;done\u0026#34;); }); Closure Function(클로저 함수)\n함수를 return하는 함수 외부 함수의 「변수」를 내부 함수에서 재사용 const makeCounter = (x) =\u0026gt; { // 함수 변경 없이 value에 할당 불가능 (캡슐화) let value = x; // 내부함수 여러개 생성 가능 return { // 스코프 체이닝 (하위 스코프 우선) up: (x) =\u0026gt; { value += x; return value; }, down: (y) =\u0026gt; { value -= y; return value; }, }; }; // 함수 재활용 가능 const counter1 = makeCounter(1); const counter2 = makeCounter(2); counter1.up(7); // -\u0026gt; 8 counter2.down(7); // -\u0026gt; -5 counter2.up(7); // -\u0026gt; 2 // counter1과 counter2의 value는 서로에게 영향 X Curry Function(커리 함수)\n함수를 return하는 함수 외부 함수의 「인자」를 내부 함수에서 재사용 const greeting = (x) =\u0026gt; { return (y) =\u0026gt; { return `${x} ${y}`; }; }; // 함수 재활용 가능 const hello = greeting(\u0026#34;Hello\u0026#34;); const goodMorning = greeting(\u0026#34;goodMorning\u0026#34;); hello(\u0026#34;guys\u0026#34;); // -\u0026gt; \u0026#39;Hello guys\u0026#39; hello(\u0026#34;ladies\u0026#34;); // -\u0026gt; \u0026#39;Hello ladies\u0026#39; goodMorning(\u0026#34;guys\u0026#34;); // -\u0026gt; \u0026#39;goodMorning guys\u0026#39; goodMorning(\u0026#34;ladies\u0026#34;); // -\u0026gt; \u0026#39;goodMorning ladies\u0026#39; JS Class #class 클래스 { constructor() {} } class 하위_클래스 extends 상위_클래스 { constructor() { super(); } } const 인스턴스 = new 클래스(); static : 클래스에서만 참조 및 호출 가능 # : 내부에서만 참조 및 호출 가능 example\r/* 1) 클래스 */ class Vehicle { //constructor: 클래스의 파라미터 constructor(name, wheel) { this.name = name; this.wheel = wheel; } //static static hi = \u0026#34;hi\u0026#34;; static isVehicle(vehicle) { return vehicle instanceof Vehicle; } //private #private = \u0026#34;private\u0026#34;; #saySecret() { console.log(this.#private); } //property bye = \u0026#34;bye\u0026#34;; //method beep() { this.#saySecret(); console.log(\u0026#34;beep!\u0026#34;); } } /* 2) 클래스 상속 */ class Car extends Vehicle { constructor(name, wheel, year) { //super: 상위 클래스의 파라미터 super(name, wheel); this.year = year; } getWheel() { this.beep(); console.log(`bye: ${this.bye}`); console.log(`wheel: ${this.wheel}`); } } /* 3) prototype */ // 공통 메서드 함수는 생성자의 prototype에 할당해서 메모리 절약 가능 // prototype chain : 해당 객체 -\u0026gt; 생성자 -\u0026gt; 상위 생성자 -\u0026gt; Object Vehicle.prototype.getInfo = function () { console.log(`${this.name}(${this.year})`); }; /* 4) 클래스로 인스턴스(객체) 생성 */ const myCar = new Car(\u0026#34;벤츠\u0026#34;, 4, \u0026#34;2016\u0026#34;); const yourCar = new Car(\u0026#34;BMW\u0026#34;, 4, \u0026#34;2020\u0026#34;); // ========== // Vehicle.hi; // \u0026#34;hi\u0026#34; Vehicle.isVehicle(myCar); // true myCar.bye; // \u0026#34;bye\u0026#34; myCar.beep; // -\u0026gt; private -\u0026gt; beep! myCar.getWheel(); // -\u0026gt; private -\u0026gt; beep! -\u0026gt; wheel: 4 myCar.getInfo(); // -\u0026gt; 벤츠(2016) yourCar.getInfo(); // -\u0026gt; BMW(2020) JS Asynchronous #1) Promise\n실행은 되지었지만 아직 결과를 반환하지 않은 객체 resolve는 성공값으로 then으로 연결 reject는 실패값으로 catch로 연결 finally는 마지막에 무조건 실행 Promise changing then에서 반환한 값이 다음 then으로 넘어감 반환값이 프로미스면 resolve 후 넘어감 에러는 catch에서 한 번에 처리 여러 프로미스 동시 실행 Promise.all([promise, ...]) 하나라도 실패하면 catch로 이동 각 결과는 배열에 담겨서 반환 Promise.allSettled([promise, ...]) 실패가 있어도 catch로 이동하지 않음 각 결과는 status 프로퍼티를 가지고 status가 fulfilled인 경우 value 프로퍼티, rejected인 경우 reason 프로퍼티를 가짐 2) async/await\n프로미스 앞에 await을 붙히면, 해당 프로미스가 resolve될 때까지 기다린 뒤 다음 로직으로 넘어감 async 함수 내에서만 await 사용 가능 async 함수는 항상 프로미스 반환 try/catch로 에러 처리 for await (promise of [promise, ...])으로 반복 가능 JS Etc #1. DOM # DOM(문서 객체 모델)은 메모리에 웹 페이지 문서 구조를 표현함으로써 스크립트 및 프로그래밍 언어와 페이지를 연결함\nMethods Details document.querySelector(\u0026ldquo;selector\u0026rdquo;) 문서 내에서 selector와 일치하는 첫 번째 요소 document.querySelectorAll(\u0026ldquo;selector\u0026rdquo;) 문서 내에서 selector와 일치하는 NodeList\n*NodeList[i]로 개별 요소 선택\n*for이나 forEach로 요소들 반복처리 document.createElement(\u0026ldquo;tag\u0026rdquo;) 문서 내에 해당 tag 요소 생성\n*아직 DOM tree에 연결 X .appendChild(aChild) 대상의 마지막 자식 노드로 붙임\n*DOM tree에 연결 .addEventListener(\u0026ldquo;event\u0026rdquo;, functionRef*) 이벤트 발생 시 함수 호출\n*event: click|focus|blur|scroll\n*event.target은 이벤트의 대상 요소 .onclick = functionRef* 대상 클릭 시 함수 호출 .classList\nㅤ.add(String [, String [, \u0026hellip;]])\nㅤ.remove(String [, String [, \u0026hellip;]])\nㅤ.contains(String) 클래스 추가\n클래스 삭제\n클래스 포함 여부 .setAttribute(\u0026ldquo;attribute\u0026rdquo;, \u0026ldquo;value\u0026rdquo;)\n.[attribute] = \u0026ldquo;value\u0026rdquo; 속성(HTML) 할당 .style.[property] = \u0026ldquo;value\u0026rdquo; 특성(CSS) 할당 .textContent = \u0026ldquo;content\u0026rdquo; 내용 할당\n*innerText(보안상 사용 금지)와 유사 .remove() 노드를 메모리에서 삭제 .removeChild(aChild) 대상과 자식 노드의 연결을 끊음 .children 자식 요소 목록\n*.firstElementChild는 첫 번째 자식\n*.lastElementChild는 마지막 자식 .parentsElement 부모 요소 *functionRef(Event Handler):\n함수의 실행이 아닌 함수 자체를 넣어야함 아무런 인자를 담지 않으면 event 객체만 전달 특정 인자를 전달하기 위해서는 콜백함수 사용\nㅤEx. eventHandler={(e) =\u0026gt; (param, \u0026hellip;, e) =\u0026gt; {}}; e.preventDefault(); (고유 동작을 막음) e.stopPropagation(); (이벤트 전파를 막음) if (e.target !== e.currentTarget) return; (해당 요소만 이벤트의 대상) 2. Scope \u0026amp; Declarations # Scope Details Global Scope window(브라우저의 객체)에 저장 Function Level Scope var중복 선언 가능 Block Level Scope letㅤ중복 선언 불가능ㅤ값의 재할당 가능constㅤ중복 선언 불가능ㅤ값의 재할당 불가능, 초기화 필수ㅤ참조형 데이터의 요소는 재할당, 추가, 삭제 가능ㅤ *하위 스코프 우선(Scope Chaining)\n*선언(호출 X)된 위치에 따라 상위 스코프 결정(Lexical Scoping)\n3. This # Type Condition Target 일반 함수 호출 1. 일반 호출: 전역 객체2. 메서드 호출: 호출 객체 화살표 함수 선언 화살표 함수를 감싸고 있는 외부 함수의 객체 example\rconst obj1 = { normal: function () { console.log(this); }, arrow: () =\u0026gt; { console.log(this); }, }; obj1.normal(); // 메서드 호출, this === obj1 const obj11 = obj1.normal; obj11(); // 일반 호출, this === window obj1.arrow(); // this === { } // ========== // const obj2 = { normal: function () { setTimeout(function () { console.log(this); }, 1000); }, arrow: function () { setTimeout(() =\u0026gt; { console.log(this); }, 1000); }, }; obj2.normal(); // this === window // obj2의 normal을 메서드 호출 // -\u0026gt; normal의 setTimeout함수(내부함수)를 일반 호출 obj2.arrow(); // this === obj2 // ========== // const obj3 = { name: \u0026#34;yuchan\u0026#34;, outer: function () { console.log(this); // --- (1)obj3 const innerFunc = function () { console.log(this); // --- (2)window (3)obj4 }; innerFunc(); // --- (2) const obj4 = { name: \u0026#34;che\u0026#34;, innerMethod: innerFunc, }; obj4.innerMethod(); // --- (3) }, }; obj3.outer(); // --- (1) // (1)메서드 호출 (2)일반 호출 (3)메서드 호출 4. JSON # Methods Details JSON.stringify(obj) obj -\u0026gt; jsonStr, 직렬화(serialize) JSON.parse(jsonSrt) jsonStr -\u0026gt; obj, 역직렬화(deserialize) *JSON(JavaScript Object Notation)문자열은 쌍따옴표(\u0026quot;\u0026quot;)만 사용 가능\n5. Export \u0026amp; Import #// 이름 필수 X, 파일 하나당 하나만 가능 export default 데이터 // 이름 필수 O, 파일 하나당 여러개 가능 export 데이터 // export default import 임의_데이터명 from \u0026#34;경로\u0026#34;; // export import { 데이터명 } from \u0026#34;경로\u0026#34;; import { 데이터명 as 임의_데이터명 } from \u0026#34;경로\u0026#34;; import * as 임의_객체명 from \u0026#34;경로\u0026#34;; 6. Web Storage(웹 저장소) # vs Cookie\n클라이언트에 정보만 존재 \u0026lt;-\u0026gt; 요청 마다 서버에 함께 전송 (성능 저하 원인, 탈취 위험 높음) 용량 제한이 없음 \u0026lt;-\u0026gt; 있음 만료일이 없음 \u0026lt;-\u0026gt; 있음 Local Storage\n별도로 삭제할 때까지 영구 유지 도메인만 같으면 전역 공유 가능 Methods Details localStorage.setItem(\u0026ldquo;key\u0026rdquo;, \u0026ldquo;value\u0026rdquo;) 데이터 저장 localStorage.getItem(\u0026ldquo;key\u0026rdquo;) 데이터 불러오기 localStorage.removeItem(\u0026ldquo;key\u0026rdquo;) 데이터 삭제 Session Storage\n탭이나 브라우저가 종료되면 삭제 같은 도메인이라도 다른 탭이나 브라우저면 공유 불가능 7. Map \u0026amp; Set # Map\n객체와 유사한 자료구조\nsymbol이나 string이 아닌 key 사용 가능\nfor (const [key, value] of map)\nWeakMap\nWeakMap의 key 외에 참조가 없는 객체를 가비지 컬렉팅의 대상으로 만듦\n원시형 데이터를 key로 사용 못함\n반복작업 및 반복자 객체 반환 메서드를 사용 못함\nexample\rlet user = { name: \u0026#34;adw\u0026#34;, age: 29 }; const userMap = new Map(); const userWeakMap = new WeakMap(); userMap.set(user, { married: false }); userWeakMap.set(user, { married: false }); user = null; console.log(user); // -\u0026gt; null console.log(userMap.get(user)); // -\u0026gt; undefined console.log(userMap.size); // -\u0026gt; 1 console.log(userWeakMap.get(user)); // -\u0026gt; undefined console.log(userWeakMap.size); // -\u0026gt; undefined Set\n배열과 유사한 자료구조 중복 요소를 가질 수 없음 const newArr = [\u0026hellip;new Set(arr)]로 배열의 중복 제거 가능 for (const item of set) Properties \u0026amp; Methods Type Details .size map, set 속성/요소의 갯수 .set(key, value) map 속성 추가, 문자열이 아닌 값도 키로 사용 가능 .get(key) map 속성 조회 .add(item) set 요소 추가 .has(key/item) map, set 해당 속성/요소 존재 여부 확인 .delete(key/item) map, set 해당 속성/요소 삭제 .clear() map, set 모든 속성/요소 삭제 .forEach() map, set 모든 속성/요소 삭제 .keys() map key를 삽입한 순서대로 가지고 있는 iterator(반복자 객체) 반환 .values() map value를 삽입한 순서대로 가지고 있는 iterator(반복자 객체) 반환 .entries() map [key, value]를 삽입한 순서대로 가지고 있는 iterator(반복자 객체) 반환 ","date":null,"permalink":"/posts/summaries/javascript/","section":"Posts","summary":"JS Data #1.","title":"Javascript"},{"content":"JS Data #1. Data Type # Data Type Details string - \u0026ldquo;\u0026hellip;\u0026rdquo;, \u0026lsquo;\u0026hellip;\u0026lsquo;로 표현\n- `\u0026hellip;${\u0026hellip;}` (Template literals)\n- +로 합침 (이때 다른 타입은 문자화)\n- str[n]으로 character 읽음 (read only)\n- String(data), data.toString()으로 문자화\n- Escape Sequence\nㅤ└ \\n (new line)\nㅤ└ \\t (tap) number - Number(str)로 숫자화\nㅤ*숫자가 아닌 문자열이 있으면 NaN\n- parseInt(str)로 정수화, parseFloat(str)으로 숫자화\nㅤ*숫자가 아닌 문자열이 뒤에 있으면 숫자인 부분까지 숫자화 boolean true | false array - [\u0026hellip;, \u0026hellip;]로 표현\n- arr[i]로 element 읽음\n- arr[i] = value로 arr의 i 인덱스에 value 할당\n- new Array(n).fill(element)로 n개의 element를 가진 배열 생성ㅤ└ .map(() =\u0026gt; Array())로 이중 배열 생성\n- [\u0026hellip;new Set(arr)]로 중복 요소를 제거한 새로운 Set 객체 생성 ^ object - { key: value, method() {}, }로 표현\n- odj.key와 obj[\u0026ldquo;key\u0026rdquo;]로 value 읽음\n- obj[\u0026ldquo;key\u0026rdquo;] = value로 obj의 key에 value (생성)할당\n- delete obj[\u0026ldquo;key\u0026rdquo;]로 key-value 삭제\n- \u0026ldquo;key\u0026rdquo; in obj로 key 존재 여부 판단- Optional Chainingㅤ└ obj.key1?.key2는 key1이 있을 때만 key2 확인 null 의도적으로 빔 undefined 값이 할당되지 않음 falsy\nfalse, null, undefined, \u0026ldquo;\u0026rdquo;, 0, NaN (나머지는 truthy) typeof^\n평가 전 데이터 타입을 string으로 반환 function은 \u0026ldquo;function\u0026rdquo; undeclaredVariable은 \u0026ldquo;undefined\u0026rdquo; null과 array는 \u0026ldquo;object\u0026rdquo; null은 data === null로 판단 array는 Array.isArray(data)로 판단 2. Data API #1) String\nAPI\rReturn\rstr.length\r문자열 안의 코드 유닛 수\rstr.indexOf(searchValue[, fromIndex])\rsearchValue의 첫 번째 등장 인덱스,\n찾을 수 없으면 -1\n*.lastIndexOf()는 마지막 등장 인덱스\rstr.includes(searchValue[, fromIndex])\rsearchValue를 포함하고 있는지 여부\rstr.slice(beginIndex[, endIndex])\r추출된 부분(~이상~미만)을 담는 새로운 string\rstr.split([separator[, limit]])\rseparator(문자열|정규식)로 끊은 문자열들의 array\rstr.match(regexp)\r정규식과 일치하는 문자열을 포함하는 array,\n찾을 수 없으면 null\n*g옵션이 없을 때 캡처된 그룹 및 정보도 배열에 포함\rstr.replace(regexp|subStr, newSubStr|function)\r패턴과 처음 일치하는 부분이 교체된 새로운 string\n*.replaceAll()은 모든 일치 문자 교체\rstr.toUpperCase()\nstr.toLowerCase()\r모두 대문자로 바꾼 string\n모두 소문자로 바꾼 string\rstr.trim()\r양끝의 공백을 제거한 string\r2) Number \u0026amp; Math\nAPI\rReturn\rnum.toFixed([digits])\r고정 소수점 표기법을 사용하여 나타낸 수의 string\n*digits: 소수점 뒤에 나타날 자릿수, 기본값 0\rMath.abs(x)\r숫자의 절댓값\rMath.max([x[, y[, …]]])\nMath.min([x[, y[, …]]])\r0개 이상의 인수 중에서 제일 큰 수\n0개 이상의 인수 중에서 제일 작은 수\rMath.ceil(x)\nMath.floor(x)\nMath.round(x)\r인수보다 크거나 같은 수 중에서 가장 작은 정수\n인수보다 작거나 같은 수 중에서 가장 큰 정수\n인수에 가장 가까운 정수\rMath.sqrt(x)\r√x\rMath.pow(x, n)\rx의 n제곱값\rMath.random()\r0 이상 1 미만의 부동소수점 의사 난수\r3) Array\nAPI\rReturn\rarr.length\r배열 안의 요소 수\n*arr.length === 0은 빈 배열\rarr.indexOf(searchValue[, beginIndex])\rsearchValue의 첫 번째 등장 인덱스,\n찾을 수 없으면 -1\n*.lastIndexOf()는 마지막 등장 인덱스\rarr.includes(searchValue[, beginIndex])\rsearchValue를 요소로 포함하고 있는지 여부\rarr.slice(beginIndex[, endIndex])\r추출된 부분(~이상~미만)을 담는 array\rarr.join([separator])\r모든 요소를 separator로 구분지어 연결한 string\n*separator를 생략하면 쉼표(,)로 구분\rarr.concat([value1[, ...[, valueN]]])\r콜백 배열이나 값들을 기존 배열에 합친 array\rarr.forEach(callback(currentValue\n[, index[, array]])[, thisArg])\rundefined\n*콜백 함수를 각 요소에 대해 실행\rarr.map(callback(currentValue\n[, index[, array]])[, thisArg])\r콜백 함수를 각 요소에 대해 실행한 결과의 array\rarr.filter(callback(currentValue\n[, index[, array]])[, thisArg])\r콜백 함수의 결과가 참인 요소의 array\rarr.find(callback(currentValue\n[, index[, array]])[, thisArg])\r콜백 함수의 결과가 참인 요소 중 첫 번째 item,\n찾을 수 없으면 undefined\rarr.findIndex(callback(currentValue\n[, index[, array]])[, thisArg])\r콜백 함수의 결과가 참인 요소 중 첫 번째 요소의 인덱스,\n찾을 수 없으면 -1\rarr.reduce(callback(accValue[, curValue\n[, curIndex[, array)[, initialValue]]]])\r콜백 함수의 누적 결과 값(last accValue)\n*initialValue는 첫 accValue의 값이며,\n생략 시 arr[0]이 첫 accValue, arr[1]이 첫 curValue\rarr.sort([compareFunction])\r정열된 array(원본)\rarr.reverse()\r순서가 반전된 array(원본)\rarr.splice(beginIndex[, deleteCount\n[, item1[, ...[, itemN]]]])\r제거한 요소를 담은 array\n*배열(원본)의 요소를 교체\n*deleteCount를 생략하면 배열(원본)의 마지막까지 삭제\rarr.push(item1[, ...[, itemN]])\r요소가 추가된 배열의 새로운 length\n*배열(원본)의 끝에 하나 이상의 요소를 추가\n*.unshift()는 배열(원본)의 앞에 추가\rarr.pop(item1[, ...[, itemN]])\r배열의 마지막 item\n*배열(원본)의 마지막 요소 삭제\n*.shift()는 배열(원본)의 첫 번째 요소 삭제\rarr.flat([depth])\rdepth 번 만큼 다차원 배열을 푼 array\n*depth 기본값은 1\r*beginIndex, endIndex의 값이 음수일 때, 끝에서부터의 위치를 의미 4) Object\nAPI\rReturn\rObject.assign(target, ...sources)\r출처 객체들로부터 하나 이상의 속성들이 복사된 목표 object\n*동일한 키를 갖는 속성은 뒤의 출처 값으로 덮어쓰여짐\rObject.keys(obj)\r모든 속성의 키(문자열)를 반환한 array\n*Object.values(obj)는 값의 array\rObject.fromEntries(arr)\r[key, value] 형태의 다차원 배열을 변환한 object\n*Object.entries(obj)는 [key, value] 형태의 이차원 array\rObject.hasOwnProperty(key)\r특정 프로퍼티를 가지고 있는지 boolean\r3. Etc #1) Destructuring Assignment(구조 분해 할당)\n배열/객체의 속성을 해체 후 그 값을 개별 변수에 할당하는 표현식\nArray\nconst arr = [1, 2, 3, 4, 5]; const [a, , b, ...rest] = arr; // a는 1, b는 3, rest는 [4, 5] Object\nconst obj = { name: \u0026#34;X\u0026#34;, age: 10, gender: \u0026#34;male\u0026#34; }; const { name, gender: sex, address = \u0026#34;Korea\u0026#34; } = obj; // name는 \u0026#34;X\u0026#34;, sex는 \u0026#34;male\u0026#34;, address는 \u0026#34;Korea\u0026#34; 2) Spread Syntax(전개 구문)\n\u0026hellip;data의 형태로 문자열·배열·객체를 펼치는 표현식\nString\nconst str = \u0026#34;Che\u0026#34;; // [...str]는 [\u0026#34;C\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;e\u0026#34;] // {...str}는 { \u0026#34;0\u0026#34;: \u0026#34;C\u0026#34;, \u0026#34;1\u0026#34;: \u0026#34;h\u0026#34;, \u0026#34;2\u0026#34;: \u0026#34;e\u0026#34; } Array\nconst arr1 = [1, 2, 3]; // [...arr1]은 [1, 2, 3], !== arr1 // {...arr1}는 { \u0026#34;0\u0026#34;: 1, \u0026#34;1\u0026#34;: 2, \u0026#34;2\u0026#34;: 3 } const arr2 = [4, 5, 6]; // [...arr1, ...arr2]는 [1, 2, 3, 4, 5, 6] Object\nconst obj = { a: 1, b: 2, c: 3 }; // {...obj1}은 { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 3 }, !== obj1 const obj2 = { c: 1, d: 2, e: 3 }; // {...obj1, ...obj2}는 { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 1, \u0026#34;d\u0026#34;: 2, \u0026#34;e\u0026#34;: 3} Rest Prams\nconst func = (team, ...members) =\u0026gt; ({ 팀: team, 멤버: members }); const myTeam = func(\u0026#34;KT\u0026#34;, \u0026#34;Smeb\u0026#34;, \u0026#34;Score\u0026#34;, \u0026#34;Ucal\u0026#34;, \u0026#34;Deft\u0026#34;, \u0026#34;Mata\u0026#34;); /* myTeam은 { 팀: \u0026#34;KT\u0026#34;, 멤버: [\u0026#34;Smeb\u0026#34;, \u0026#34;Score\u0026#34;, \u0026#34;Ucal\u0026#34;, \u0026#34;Deft\u0026#34;, \u0026#34;Mata\u0026#34;], }; */ 3) Data Immutability⋯\nPrimitive Type\nstring, number, boolean, undefined, null 변수에 값을 저장 immutable Reference Type\narray, object, function 변수에 heap의 주소를 저장, 값은 heap에 저장 같은 주소(heap)를 참조할 때 하나 변화 시 일괄 변화 mutable 4) Data Copy\nShallow Copy\n복사한 참조형 데이터 내부의 참조형 데이터는 같은 주소 참조 Deep Copy\n복사한 참조형 데이터 내부의 참조형 데이터도 다른 주소 참조 JS Operator #1) 삼항 연산자(Ternary Operator)\n조건 ? 조건이 true일 때 : 조건이 false일 때 2) 논리 연산자(Logical Operator)\nOperator\rDetails\r\u0026\u0026\r- and (모두 truthy일 때 true)\n- leftExpr \u0026\u0026 rightExpr\nㅤ└ leftExpr이 truthy일 때, rightExpr\nㅤ└ leftExpr이 falsy일 때, leftExpr\r||\r- or (하나라도 truthy일 때 true)\n- leftExpr || rightExpr\nㅤ└ leftExpr이 truthy일 때, leftExpr\nㅤ└ leftExpr이 falsy일 때, rightExpr\r??\r- leftExpr ?? rightExpr\nㅤ└ leftExpr이 null 혹은 undefined가 아닐 때, leftExpr ㅤ└ leftExpr이 null 혹은 undefined 때, rightExpr\r!\r- not (falsy일 때 true)\r3) 비교 연산자(Comparison Operator)\nOperator\rDetails\ra === b\r값과 타입이 같을 때 true\ra !== b\r값이나 타입이 다를 때 true\ra \u003e b\ra \u003e b일 때 true\ra \u003c b\ra \u003c b일 때 true\ra \u003e= b\ra \u003e= b일 때 true\ra \u003c= b\ra \u003c= b일 때 true\r4) 산술 연산자(Arithmetic Operator)\nOperator\rDetails\ra + b\r덧셈\ra - b\r뺄셈\ra * b\r곱셈\ra / b\r나눗셈\ra % b\r나머지\r5) 할당 연산자(Assignment Operator)\nOperator\rDetails\ra += b\ra = a + b\ra -= b\ra = a - b\ra *= b\ra = a * b\ra /= b\ra = a / b\ra %= b\ra = a % b\r6) 증감 연산자(Increment Operator)\nOperator\rDetails\ra++/--\r연산 후 1증가/감소\r++/--a\r1증가/감소 후 연산\rJS Control Statement #1) Conditional Statement\nif 조건문\nif (조건1) { 조건1이 truthy일 때 } else if (조건n) { 조건n이 truthy일 때 } else { 조건이 모두 falsy일 때 } switch 조건문\nswitch (대상) { case 케이스n: 대상이 케이스n일 때 break; default: 해당 케이스가 없을 때 } *switch문은 case가 문자열이나 정수일 때 주로 사용\n2) Iterative Statement\nfor 반복문\nfor (초기값; 반복 조건; 증감값) { 반복내용; } // for of 배열 for (let item of iterator) { 반복내용; } // for in 객체 for (let key in object) { 반복내용; } while 반복문\nwhile (반복 조건) { 반복 내용 } Escape Details break 해당 반복문 종료 continue 해당 반복 내용을 종료하고 다음 반복으로 넘어감 label 해당 label의 반복문을 대상으로 함 outer: for (item of arr) { inner: for (el of item) { if (el === 0) { break outer; } if (el === 1) { continue inner; } } } *while문은 반복 횟수가 정해져있지 않을 때 주로 사용\nJS Function #1) 함수 작성\nNamed Function Declaration(기명 함수 선언)\nfunction 함수() {} // Hoisting 가능 Anonymous Function Expression(익명 함수 표현)\nconst 변수 = function () {}; Arrow Function(화살표 함수)\nconst 변수 = () =\u0026gt; {}; // 인수가 하나일 때, 인수 소괄호 생략 가능 // { return } 생략 가능 // 객체 데이터는 소괄호로 묶어야 함 // 메서드 함수로 적합하지 않음 // 생성자 함수로 사용할 수 없음 2) 고차 함수\nTimer Function Type Details setTimeout(함수, ms) 일정 시간 후 함수 실핼 setInterval(함수, ms) 일정 시간 마다 함수 실행 clearTimeout(변수) 해당 Timeout 함수를 종료 clearInterval(변수) 해당 Interval 함수를 종료 Callback Function⋯ 함수의 「인자」로 사용되는 함수 Closure Function⋯ 함수를 return하는 함수 외부 함수의 「변수」를 내부 함수에서 재사용 Curry Function⋯ 함수를 return하는 함수 외부 함수의 「인자」를 내부 함수에서 재사용 JS Class #class 클래스 { constructor() {} } class 하위_클래스 extends 상위_클래스 { constructor() { super(); } } \u0026gt; const 객체 = new 클래스(); 생성자.prototype.메서드 = function () {}\n공통 메서드 함수는 생성자의 prototype에 할당해서 메모리 절약 해당 객체 -\u0026gt; 생성자 -\u0026gt; 상위 생성자 -\u0026gt; Object (Prototype chain) *JS Class 예시\nJS Asynchronous # 추가 예정 JS Etc #1. DOM API^ # API Details document.querySelector(\u0026ldquo;selector\u0026rdquo;) 문서 내에서 selector와 일치하는 첫 번째 요소 document.querySelectorAll(\u0026ldquo;selector\u0026rdquo;) 문서 내에서 selector와 일치하는 NodeList\n*NodeList[i]로 개별 요소 선택\n*for이나 forEach로 요소들 반복처리 document.createElement(\u0026ldquo;tag\u0026rdquo;) 문서 내에 해당 tag 요소 생성\n*아직 DOM tree에 연결 X .appendChild(aChild) 대상의 마지막 자식 노드로 붙임\n*DOM tree에 연결 .addEventListener(\u0026ldquo;event\u0026rdquo;, functionRef) 이벤트 발생 시 함수 호출\n*event: click|focus|blur|scroll\n*event.target은 이벤트의 대상 요소 .onclick = functionRef 대상 클릭 시 함수 호출 .classList\nㅤ.add(String [, String [, \u0026hellip;]])\nㅤ.remove(String [, String [, \u0026hellip;]])\nㅤ.contains(String) 클래스 추가\n클래스 삭제\n클래스 포함 여부 .setAttribute(\u0026ldquo;attribute\u0026rdquo;, \u0026ldquo;value\u0026rdquo;)\n.[attribute] = \u0026ldquo;value\u0026rdquo; 속성(HTML) 할당 .style.[property] = \u0026ldquo;value\u0026rdquo; 특성(CSS) 할당 .textContent = \u0026ldquo;content\u0026rdquo; 내용 할당\n*innerText(보안상 사용 금지)와 유사 .remove() 노드를 메모리에서 삭제 .removeChild(aChild) 대상과 자식 노드의 연결을 끊음 .children 자식 요소 목록\n*.firstElementChild는 첫 번째 자식\n*.lastElementChild는 마지막 자식 .parentsElement 부모 요소 functionRef (Event Handler)\n함수의 실행이 아닌 함수 자체를 넣어야함 아무런 인자를 담지 않으면 event 객체만 전달 특정 인자를 전달하기 위해서는 콜백함수 사용\nㅤEx. eventHandler={(e) =\u0026gt; (param, \u0026hellip;, e) =\u0026gt; {}}; e.preventDefault(); (고유 동작을 막음) e.stopPropagation(); (이벤트 전파를 막음) if (e.target !== e.currentTarget) return; (해당 요소만 이벤트의 대상) 2. Scope # Scope Details Global Scope window(브라우저의 객체)에 저장 Function Level Scope var중복 선언 가능 Block Level Scope letㅤ중복 선언 불가능ㅤ값의 재할당 가능constㅤ중복 선언 불가능ㅤ값의 재할당 불가능, 초깃값 필수ㅤ참조형 데이터의 요소는 재할당, 추가, 삭제 가능ㅤ *Scope Chaining (하위 스코프 우선)\n*Lexical Scoping은 선언(호출 X)된 위치에 따라 상위 스코프 결정\n3. This # Type Condition Target 일반 함수 호출 1. 일반 호출: 전역 객체2. 메서드 호출: 호출 객체 화살표 함수 선언 화살표 함수를 감싸고 있는 외부 함수의 객체 _*This 예제_\n4. JSON # API Details JSON.stringify(obj) obj -\u0026gt; jsonStr, 직렬화(serialize) JSON.parse(jsonSrt) jsonStr -\u0026gt; obj, 역직렬화(deserialize) *JSON(JavaScript Object Notation)문자열은 쌍따옴표(\u0026quot;\u0026quot;)만 사용 가능\n5. Export \u0026amp; Import #// 이름 필수 X, 파일 하나당 하나만 가능 export default 데이터 // 이름 필수 O, 파일 하나당 여러개 가능 export 데이터 // export default import 임의_데이터명 from \u0026#34;경로\u0026#34;; // export import { 데이터명 } from \u0026#34;경로\u0026#34;; import { 데이터명 as 임의_데이터명 } from \u0026#34;경로\u0026#34;; import * as 임의_객체명 from \u0026#34;경로\u0026#34;; 6. Storage API #Local Storage\n사이트에 종속되어 데이터 반영구 저장 API Details localStorage.setItem(\u0026ldquo;key\u0026rdquo;, \u0026ldquo;value\u0026rdquo;) 데이터 저장 localStorage.getItem(\u0026ldquo;key\u0026rdquo;) 데이터 불러오기 localStorage.removeItem(\u0026ldquo;key\u0026rdquo;) 데이터 삭제 Session Storage\n페이지를 닫기 전까지 데이터 임시 저장 ","date":null,"permalink":"/what-i-learned/javascript/javascript/","section":"What I Learneds","summary":"JS Data #1.","title":"JavaScript"},{"content":"Data Immutability #// 원시 데이터 (불변) // string, number, boolean, undefined, null // |a: 1 |b: 3 // |a: 1 |b: 1 // |a: 1 |b: 5 // |a: 1 |b: 5 |c: 1 let a = 1; let b = 3; console.log(a, b, a === b); // -\u0026gt; 1 3 false b = a; console.log(a, b, a === b); // -\u0026gt; 1 1 true b = 5; console.log(a, b, a === b); // -\u0026gt; 1 5 false let c = 1; console.log(a, c, a === c); // -\u0026gt; 1 1 true // 참조형 데이터 (가변) // object, array, function // |x: heapX |y: heapY // heapX: heapY: // |x: heapX |y: heapY // heapX: |k: 1 heapY: |k: 1 // |x: heapX |y: heapY // heapX: |k: 3 heapY: |k: 3 // |x: heapX |y: heapX // heapX: |k: 3 // |x: heapX |y: heapX // heapX: |k: 5 let x = {}; let y = {}; console.log(x, y, x === y); // -\u0026gt; {} {} false x = { k: 1 }; y = { k: 1 }; console.log(x.k, y.k, x.k === y.k); // -\u0026gt; 1 1 true console.log(x, y, x === y); // -\u0026gt; {k:1} {k:1} false x.k = 3; y.k = 3; console.log(x, y, x === y); // -\u0026gt; {k:3} {k:3} false y = x; console.log(x, y, x === y); // -\u0026gt; {k:3} {k:3} true y.k = 5; console.log(x, y, x === y); // -\u0026gt; {k:5} {k:5} true Callback #function timeout(cb) { setTimeout(() =\u0026gt; { console.log(\u0026#34;start\u0026#34;); // 함수의 실행 위치 보장 cb(); }, 1000); } timeout(() =\u0026gt; { console.log(\u0026#34;done\u0026#34;); }); Closure #const makeCounter = (x) =\u0026gt; { // 함수 변경 없이 value에 할당 불가능 (캡슐화) let value = x; // 내부함수 여러개 생성 가능 return { // 스코프 체이닝 (하위 스코프 우선) up: (x) =\u0026gt; { value += x; return value; }, down: (y) =\u0026gt; { value -= y; return value; }, }; }; // 함수 재활용 가능 const counter1 = makeCounter(1); const counter2 = makeCounter(2); counter1.up(7); // -\u0026gt; 8 counter2.down(7); // -\u0026gt; -5 counter2.up(7); // -\u0026gt; 2 // counter1과 counter2의 value는 서로에게 영향 X Curry #const greeting = (x) =\u0026gt; { return (y) =\u0026gt; { return `${x} ${y}`; }; }; // 함수 재활용 가능 const hello = greeting(\u0026#34;Hello\u0026#34;); const goodMorning = greeting(\u0026#34;goodMorning\u0026#34;); hello(\u0026#34;guys\u0026#34;); // -\u0026gt; \u0026#39;Hello guys\u0026#39; hello(\u0026#34;ladies\u0026#34;); // -\u0026gt; \u0026#39;Hello ladies\u0026#39; goodMorning(\u0026#34;guys\u0026#34;); // -\u0026gt; \u0026#39;goodMorning guys\u0026#39; goodMorning(\u0026#34;ladies\u0026#34;); // -\u0026gt; \u0026#39;goodMorning ladies\u0026#39; Class #/* 클래스 */ class Vehicle { constructor(name, wheel) { // 클래스의 파라미터 this.name = name; this.wheel = wheel; } } /* 클래스 상속 */ class Car extends Vehicle { constructor(name, wheel, year) { // 상위 클래스의 파라미터 super(name, wheel); // 하위 클래스의 파라미터 this.year = year; } } // 공통 메서드 Vehicle.prototype.getInfo = function () { console.log(`${this.name}(${this.license})`); }; // 클래스로 객체 생성 const myCar = new Car(\u0026#34;벤츠\u0026#34;, 4, \u0026#34;2016\u0026#34;); const yourCar = new Car(\u0026#34;BMW\u0026#34;, 4, \u0026#34;2020\u0026#34;); myCar.getInfo(); // -\u0026gt; 벤츠(2016) yourCar.getInfo(); // -\u0026gt; BMW(2020) This #const obj1 = { normal: function() { console.log(this) }, arrow: () =\u0026gt; { console.log(this) } } obj1.normal() // 메서드 호출, this === obj1 const obj11 = obj1.normal obj11() // 일반 호출, this === window obj1.arrow() // this === { } --- const obj2 = { normal: function () { setTimeout(function () { console.log(this) }, 1000) }, arrow: function () { setTimeout(() =\u0026gt; { console.log(this) }, 1000) } } obj2.normal() // this === window // obj2의 normal을 메서드 호출 // -\u0026gt; normal의 setTimeout함수(내부함수)를 일반 호출 obj2.arrow() // this === obj2 --- const obj3 = { name: \u0026#39;yuchan\u0026#39;, outer: function () { console.log(this); // --- (1)obj3 const innerFunc = function () { console.log(this); // --- (2)window (3)obj4 }; innerFunc(); // --- (2) const obj4 = { name: \u0026#39;che\u0026#39;, innerMethod: innerFunc, }; obj4.innerMethod(); // --- (3) }, }; obj3.outer(); // --- (1) // (1)메서드 호출 (2)일반 호출 (3)메서드 호출 ","date":null,"permalink":"/storage/wil/javascript/ex-javascript/","section":"Storages","summary":"Data Immutability #// 원시 데이터 (불변) // string, number, boolean, undefined, null // |a: 1 |b: 3 // |a: 1 |b: 1 // |a: 1 |b: 5 // |a: 1 |b: 5 |c: 1 let a = 1; let b = 3; console.","title":"JS Example"},{"content":" 리눅스 콘솔 명령어 추가 예정 1. 기본 명령어 # Command Details man [명령어] 메뉴얼 보기 clear 터미널 창 정리 open . 현재 경로를 Finder에서 열기 code . 현재 경로를 VSC에서 열기 sudo 관리자 권한 획득 2. 경로 탐색 # Command Details pwd 현재 절대 경로 보기 lsㅤ[경로명]ㅤ-lㅤ-a 현재 경로 목록 보기- 경로 지정- 자세히 보기- 숨겨진 목록 보기 which [프로그램명] 해당 프로그램의 실행 경로 보기 cdㅤ[경로명]ㅤ..ㅤ~ㅤ- 해당 경로로 이동상위 경로로 이동최상위 경로로 이동직전 경로로 이동 find . -type directory|file -name \u0026ldquo;[검색어]\u0026rdquo; 현재 및 하위 경로의 특정 폴더|파일 찾기(Ex. \u0026ldquo;*A*\u0026rdquo;, \u0026ldquo;*.md\u0026rdquo;) 권한 (ls -l로 볼 수 있음)\r사용 권한 (Ex. drwxr-xr-x)\rd(directory) | -(non-directory)\ruser group other\rr(read) | w(write) | x(execute)\r권한 변경: chmod\rSymbolic method (Ex. chmod a=r-x project)\ru(user) | g(group) | o(other) | a(all)\r+(add) | -(remove) | =(set exact)\rr(read) | w(write) | x(execute)\rAbsolute form (Ex. chmod 740 index.js)\ruser group other\r4(r)2(w)1(x)\r3. 파일·폴더 생성 및 관리 # Command Details mkdirㅤ[경로명]ㅤ-p [경로명] 하위 폴더 만들기해당 경로를 따라 하위 폴더 만들기 touch [파일명] 파일 만들기 echoㅤ\u0026quot;[문자열]\u0026quot; \u0026gt; [파일명]ㅤ\u0026quot;[문자열]\u0026quot; \u0026raquo; [파일명] 문자열을 덮어쓰면서 파일 만들기문자열을 추가하면서 파일 만들기 cat [파일명] (\u0026hellip;) 파일(들) 내용 확인 mv\nㅤ[경로·파일명] (\u0026hellip;) [경로]\nㅤ[경로·파일명] [경로·파일명] 해당 폴더로 폴더·파일(들) 이동\n이름 변경 (후자가 없는 경우) cp\nㅤ[파일명] [복사파일명]\nㅤ-r [경로명] [복사경로명] 해당 파일 복사\n해당 폴더 복사 rmㅤ[파일명]ㅤ-r [경로명] 해당 파일 삭제해당 폴더 삭세 grep \u0026ldquo;[검색어]\u0026rdquo; [경로명]ㅤ-nㅤ-iㅤ-r 특정 파일에서 특정 키워드 검색- 줄 표시- 대소문자 무시- 현재 및 하위경로 검색 4. 환경 변수 # Command Details export [환경변수]=[값] 환경 변수 임시 저장 unset [환경변수] 해당 환경 변수 삭제 env 모든 환경 변수 보기 5. 텍스트 에디터 # Name Command Details vim vi [파일명] i -\u0026gt; esc -\u0026gt; :wq nano nano [파일명] ctrl+X -\u0026gt; Y -\u0026gt; enter ","date":null,"permalink":"/what-i-learned/etc/linux/","section":"What I Learneds","summary":"리눅스 콘솔 명령어 추가 예정 1.","title":"Linux Console"},{"content":" 확장성 네트워크 애플리케이션(특히 서버 사이드) 개발에 사용되는 소프트웨어 플랫폼(런타임 환경). 작성 언어로 JavaScript를 활용하며, Non-blocking I/O과 Single thread Event loop를 통한 높은 처리 성능을 가짐.\nNVM(Node Version Manager) # Home Brew 설치 ⋯ /bin/bash -c \u0026#34;\\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; Error Handling # command not found: brew eval $(/opt/homebrew/bin/brew shellenv) # nvm install arch -x86_64 zsh Node.js 설치 brew install node Command Details node \u0026ndash;version node 버전 nvm \u0026ndash;version nvm 버전 nvm install [버전] 특정 버전 node 설치 nvm uninstall [버전] 특정 버전 node 삭제 nvm ls node 목록 nvm use [버전] 특정 버전 node 사용 NPM(Node Package Manager) # Command Details npm init -y package.json 생성 npm installnpm i (-D) [패키지명] package.json에 기록된 패키지 설치일반(개발) 의존성 패키지 설치 npm update [패키지명] 같은 major의 최신 버전으로 업데이트 *^major.minor.patch일 때만 가능 npm run [명령] package.json의 script에 \u0026ldquo;명령\u0026rdquo;: \u0026ldquo;명령어\u0026rdquo; 등록 후 사용 npx [명령어] 패키지의 명령어 바로 사용 *[패키지명]@[패키지 버전]으로 특정 버전 패키지 설치 가능*.cache/, dist/, node_modules/는 package.json에 기록되어 있어서 버전 관리 제외 필요\nPACKAGE # npm i -g nodemon npm i lodash npm i -D parcel-bundler npm i nanoid ","date":null,"permalink":"/what-i-learned/javascript/nodejs/","section":"What I Learneds","summary":"확장성 네트워크 애플리케이션(특히 서버 사이드) 개발에 사용되는 소프트웨어 플랫폼(런타임 환경).","title":"Node.js"},{"content":" React v18.0 업데이트 미반영 Ref. React Docs (en)\n선언형, 컴포넌트 기반, 범용성이 특징인 JavaScript 라이브러리\nReact Basic #1) JSX 문법\nClose Tag 필수 (Ex. \u0026lt;\u0026gt;\u0026lt;/\u0026gt; (Fragment)) {JS 표현식} 조건문 대신 삼항 연산자나 논리 연산자(||)만 사용 가능 className, onClick (class, onclick in JS) 2) Component\nClass Component\nimport React from \u0026#34;react\u0026#34;; class Welcome extends React.Component { render() { return \u0026lt;h1\u0026gt;Hello, {this.props.name}\u0026lt;/h1\u0026gt;; } } Function Component\nfunction Welcome(props) { return \u0026lt;h1\u0026gt;Hello, {props.name}\u0026lt;/h1\u0026gt;; } // Arrow Function Component is Bad with Type Script. // \u0026#34;Using props directly on parameters allow you to more correctly type components and avoid false positives while also being more flexible.\u0026#34; 3) Props\n상위 컴포넌트에서 전달받은 값 (read only)\nimport SubComponent1 from \u0026#34;./SubComponent1\u0026#34;; import SubComponent2 from \u0026#34;./SubComponent2\u0026#34;; // props 발신 const SupComponent = () =\u0026gt; { return ( \u0026lt;div className=\u0026#34;sup\u0026#34;\u0026gt; \u0026lt;SubComponent1 propsName={propsValue} /\u0026gt; \u0026lt;SubComponent2 propsName={propsValue} /\u0026gt; \u0026lt;/div\u0026gt; ); }; export default SupComponent; // props 수신 (1) export default function SubComponent1(props) =\u0026gt; { return ( \u0026lt;div className=\u0026#34;sub\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{props.propsName}\u0026lt;p\u0026gt; \u0026lt;/div\u0026gt; ); } // props 수신 (2) (recommended) export default function SubComponent2({propsName}) =\u0026gt; { return ( \u0026lt;div className=\u0026#34;sub\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{propsName}\u0026lt;p\u0026gt; \u0026lt;/div\u0026gt; ) } *Props Composition: Component를 Props로 넘겨줌\n4) State with useState^\n컴포넌트 내부에서 변화하는 값\nimport { useState } from \u0026#34;react\u0026#34;; export default function Component() { /* useState */ const [state, setState] = useState(initialState); // setState로만 state 변경 가능 const setStateFunc = (event) =\u0026gt; { setState(event.target.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={state} onChange={setStateFunc} /\u0026gt; \u0026lt;p\u0026gt;text: {state}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } // setState는 비동기적으로 작동해서 `함수형`으로 동기적으로 처리 해야함 const [state, setState] = useState({}); setState((prevState) =\u0026gt; ({ ...prevState, ...updatedValues })); *참조형 데이터의 요소는 변경해도 재랜더링이 일어나지 않음\nReact Hooks #1. useEffect^ ⋯ #/* useEffect */ useEffect(() =\u0026gt; { effect [return clean-up }[, [dependency]]]) side effect 처리 최초 수행 후 컴포넌트 재랜더링 마다 수행\n*부모 컴포넌트 재랜더링, props 및 state 변경 useEffect의 effect를 정리하는 함수 반환 가능 (clean-up) 최초 수행 후 dependency 요소 변화 시만 수행\n*dependency가 []일 때는 최초에만 수행 2. useRef^ ⋯ #/* 1) useRef */ const containerRef = useRef(initialValue); return ( \u0026lt;\u0026gt; {/* 2) ref */} \u0026lt;element ref={containerRef} /\u0026gt; \u0026lt;/\u0026gt; ); // 3) .current const currentDom = ContainerRef.current; 리액트에서 DOM에 접근 가능 ref.current는 값이 변해도 재랜더링이 일어나지 않아, 재랜더링이 일어나면 안 되는 데이터를 저장할 때도 사용 3. useCallback / useMemo^ ^ ⋯ #/* useCallback */ // 자주 사용될 함수를 props로 넘겨줄 때만 사용 const memoizedCallback = useCallback(() =\u0026gt; { doSomething(a, b); }, [a, b]); /* useMemo */ // 고비용의 계산이 필요할 때만 사용 const memoizedValue = useMemo(() =\u0026gt; computeExpensiveValue(a, b), [a, b]); 특정 함수나 결과값을 재사용 4. useContext^ ⋯ ⋯ #/* 1) React.createContext */ const MyContext = React.createContext(defaultValue); /* 2) .Provider */ \u0026lt;MyContext.Provider value={data}\u0026gt;\u0026lt;/MyContext.Provider\u0026gt;; /* 3) useContext */ const value = useContext(MyContext); 하위 컴포넌트 트리 전체에 데이터 제공 5) Custom Hook^ # 자주 사용하는 Custom Hook 정리 필요 React Etc #1) CRA with TS\nnpx create-react-app 프로젝트_이름 --template typescript 2) React.memo()\n이전과 같은 props가 들어올 때 렌더링 스킵 많이 반복되는 렌더링 요소를 가지고 있을 때 React.memo()로 감싸서 export *memo(), useCallback(), useMemo() 등의 최적화는 profile 실시 후 적용\n","date":null,"permalink":"/what-i-learned/javascript/react/","section":"What I Learneds","summary":"React v18.","title":"React"},{"content":"useEffect #import { useState, useEffect } from \u0026#34;react\u0026#34;; export default function Component() { const [name, setName] = useState(\u0026#34;\u0026#34;); const [count, setCount] = useState(0); const handleChangeName = (e) =\u0026gt; setName(e.target.value); const handleCountUp = () =\u0026gt; setCount(count + 1); /* useEffect */ useEffect(() =\u0026gt; { // effect setTimeout(() =\u0026gt; { console.log({ count, name }); }, 1000); // clean-up return clearTimeout(setTimeout); // dependency }, [count]); return ( \u0026lt;\u0026gt; \u0026lt;p\u0026gt;Name: {name}\u0026lt;/p\u0026gt; \u0026lt;input type={\u0026#34;text\u0026#34;} value={name} onChange={handleChangeName} /\u0026gt; \u0026lt;p\u0026gt;Count : {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handleCountUp}\u0026gt;up\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } useRef #function TextInputWithFocusButton() { /* useRef */ // DOM에 접근할 때 초깃값은 무조건 null! const inputEl = useRef(null); const onButtonClick = () =\u0026gt; { // .current inputEl.current.focus(); }; return ( \u0026lt;\u0026gt; {/* ref */} \u0026lt;input ref={inputEl} type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;button onClick={onButtonClick}\u0026gt;Focus the input\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } useCallback / useMemo #import { useState, useCallback, useMemo } from \u0026#34;react\u0026#34;; export default function Component() { const [count, setCount] = useState(0); const handleCount = () =\u0026gt; { setCount(count + 1); }; /* useCallback */ const handleClick = useCallback( () =\u0026gt; console.log(`Count : ${count}`), [count] ); /* useMemo */ const doubleCount = useMemo(() =\u0026gt; count * 2, [count]); const handleDouble = () =\u0026gt; { console.log(`Double Count : ${doubleCount}`); }; return ( \u0026lt;\u0026gt; \u0026lt;button onClick={handleCount}\u0026gt;카운트 올리기!\u0026lt;/button\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;보여주기!\u0026lt;/button\u0026gt; \u0026lt;button onClick={handleDouble}\u0026gt;두배로 보여주기!\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } useContext - 1 #// data const themes = { light: { foreground: \u0026#34;#000000\u0026#34;, background: \u0026#34;#eeeeee\u0026#34;, }, dark: { foreground: \u0026#34;#ffffff\u0026#34;, background: \u0026#34;#222222\u0026#34;, }, }; /* createContext(initial value of data) */ // light를 기본값으로 하는 테마 context를 만듦 const ThemeContext = React.createContext(themes.light); function App() { return ( {/* Context.Provider */} // Provider를 이용해 하위 트리에 테마 값을 보내줌 \u0026lt;ThemeContext.Provider value={themes.dark}\u0026gt; \u0026lt;Toolbar /\u0026gt; \u0026lt;/ThemeContext.Provider\u0026gt; ); } function Toolbar() { return ( \u0026lt;div\u0026gt; \u0026lt;ThemedButton /\u0026gt; \u0026lt;/div\u0026gt; ); } function ThemedButton() { /* useContext */ // 가장 가까이 있는 테마 Provider를 찾아 그 값을 사용 const theme = useContext(ThemeContext); return ( \u0026lt;button style={{ background: theme.background, color: theme.foreground }} \u0026gt; I am styled by theme context! \u0026lt;/button\u0026gt; ) } useContext - 2 #Store.js #import React, {useState} from \u0026#39;react\u0026#39;; /* createContext */ const StoreContext = React.createContext(null); const StoreProvider = ({children}) =\u0026gt; { const [number, setNumber] = useState(0); // data const store = { number, setNumber }; return ( {/* Context.Provider */} \u0026lt;StoreContext.Provider value={store}\u0026gt; {children} \u0026lt;/StoreContext.Provider\u0026gt; ) }; export { StoreContext StoreProvider, }; Display.js #import { useContext } from \u0026#34;react\u0026#34;; import { StoreContext } from \u0026#34;../store/Store\u0026#34;; const Display = () =\u0026gt; { /* useContext */ const { number } = useContext(StoreContext); return \u0026lt;div\u0026gt;number : {number}\u0026lt;/div\u0026gt;; }; export default Display; Controller.js #import { useContext } from \u0026#34;react\u0026#34;; import { StoreContext } from \u0026#34;../store/Store\u0026#34;; const Controller = () =\u0026gt; { /* useContext */ const { setNumber } = useContext(StoreContext); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setNumber(number + 1)}\u0026gt;increase\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setNumber(number - 1)}\u0026gt;decrease\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default Controller; App.js #import { StoreProvider } from \u0026#34;./store/Store\u0026#34;; import Display from \u0026#34;./components/Display\u0026#34;; import Controller from \u0026#34;./components/Controller\u0026#34;; const App = () =\u0026gt; { return ( \u0026lt;StoreProvider\u0026gt; \u0026lt;Display /\u0026gt; \u0026lt;Controller /\u0026gt; \u0026lt;/StoreProvider\u0026gt; ); }; export default App; ","date":null,"permalink":"/storage/wil/javascript/ex-react/","section":"Storages","summary":"useEffect #import { useState, useEffect } from \u0026#34;react\u0026#34;; export default function Component() { const [name, setName] = useState(\u0026#34;\u0026#34;); const [count, setCount] = useState(0); const handleChangeName = (e) =\u0026gt; setName(e.","title":"React Example"},{"content":"Redux Basic #1) Action #// 1) Action Type 정의 export const ADD_TODO = \u0026#34;ADD_TODO\u0026#34;; export const COMPLETE_TODO = \u0026#34;COMPLETE_TODO\u0026#34;; export const SHOW_ALL = \u0026#34;SHOW_ALL\u0026#34;; export const SHOW_COMPLETE = \u0026#34;SHOW_COMPLETE\u0026#34;; // 2) Action Creator(Action 객체 반환) 작성 export function addTodo(text) { return { type: ADD_TODO, text }; // { type: ADD_TODO, text: \u0026#34;todo\u0026#34; } } export function completeTodo(index) { return { type: COMPLETE_TODO, index }; // { type: COMPLETE_TODO, index: num } } export function showAll() { return { type: SHOW_ALL }; // { type: SHOW_ALL } } export function showComplete() { return { type: SHOW_COMPLETE }; // { type: SHOW_COMPLETE } 2) Reducer #// 3) reducers 작성 // redux/modules/reducers.js import { combineReducers } from \u0026#34;redux\u0026#34;; import todos from \u0026#34;./modules/todos\u0026#34;; import filter from \u0026#34;./modules/filter\u0026#34;; const reducers = combineReducers({ todos, filter, }); export default reducers; // 4-1) 개별 Reducer 작성 const initState1 = []; export default function todos(state = initState1, action) { if (action.type === ADD_TODO) { return [...state, { text: action.text, completed: false }]; } if (action.type === COMPLETE_TODO) { return state.map((todo, index) =\u0026gt; { if (index === action.index) { return { ...todo, completed: true }; } return todo; }); } return state; } // 4-2) 개별 Reducer 작성 const initState2 = \u0026#34;ALL\u0026#34;; export default function filter(state = initState2, action) { if (action.type === SHOW_ALL) { return \u0026#34;ALL\u0026#34;; } if (action.type === SHOW_COMPLETE) { return \u0026#34;COMPLETE\u0026#34;; } return state; } 3) Store #// 5) reducers로 store 생성 // redux/store.js import { createStore } from \u0026#34;redux\u0026#34;; import reducers from \u0026#34;./modules/reducers\u0026#34;; const store = createStore(reducers); export default store; 4) Provider #// 6) Provider로 App 전체에 전달 // index.js ... import App from \u0026#34;./App\u0026#34;; import store from \u0026#34;./redux/store\u0026#34;; import { Provider } from \u0026#34;react-redux\u0026#34;; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;Provider store={store}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/Provider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;) ); 5) Usage #Container\n// containers/TodoListContainer.jsx import TodoList from \u0026#34;../components/TodoList\u0026#34;; import { useSelector } from \u0026#34;react-redux\u0026#34;; export default function TodoListContainer() { const todos = useSelector((state) =\u0026gt; state.todos); return \u0026lt;TodoList todos={todos} /\u0026gt;; } // containers/TodoFormContainer.jsx import TodoForm from \u0026#34;../components/TodoForm\u0026#34;; import { useDispatch } from \u0026#34;react-redux\u0026#34;; import { useCallback } from \u0026#34;react\u0026#34;; import { addTodo } from \u0026#34;../redux/modules/todos\u0026#34;; export default function TodoFormContainer() { const dispatch = useDispatch(); const add = useCallback( (text) =\u0026gt; { dispatch(addTodo(text)); }, [dispatch] ); return \u0026lt;TodoForm add={add} /\u0026gt;; } Component\n// components/TodoList.jsx export default function TodoList({ todos }) { return ( \u0026lt;ul\u0026gt; {todos.map((todo) =\u0026gt; { return \u0026lt;li\u0026gt;{todo.text}\u0026lt;/li\u0026gt;; })} \u0026lt;/ul\u0026gt; ); } // components/TodoForm.jsx import { useRef } from \u0026#34;react\u0026#34;; export default function TodoForm({ add }) { const inputRef = useRef(); return ( \u0026lt;div\u0026gt; \u0026lt;input ref={inputRef} /\u0026gt; \u0026lt;button onClick={click}\u0026gt;add\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); function click() { add(inputRef.current.value); } } Redux-thunk #// redux/store.js import reducer from \u0026#34;./reducer/reducer\u0026#34;; import { applyMiddleware, createStore } from \u0026#34;redux\u0026#34;; import { composeWithDevTools } from \u0026#34;redux-devtools-extension\u0026#34;; import thunk from \u0026#34;redux-thunk\u0026#34;; const store = createStore(reducer, composeWithDevTools(applyMiddleware(thunk))); export default store; // redux/actions.js import axios from \u0026#34;axios\u0026#34;; ... export function getUsersStart() { return { type: GET_USERS_START, }; } export function getUsersSuccess(data) { return { type: GET_USERS_SUCCESS, data, }; } export function getUsersFail(error) { return { type: GET_USERS_FAIL, error, }; } export function getUsersThunk() { return async (dispatch) =\u0026gt; { try { dispatch(getUsersStart()); const res = await axios.get(\u0026#34;https://api.github.com/users\u0026#34;); dispatch(getUsersSuccess(res.data)); } catch (err) { dispatch(getUsersFail(err)); } }; } // components/UserListContainer.jsx import UserList from \u0026#34;../components/UserList\u0026#34;; import { useSelector, useDispatch } from \u0026#34;react-redux\u0026#34;; import { useCallback } from \u0026#34;react\u0026#34;; import { getUsersThunk } from \u0026#34;../redux/actions\u0026#34;; export default function UserListContainer() { const users = useSelector((store) =\u0026gt; store.users.data); const dispatch = useDispatch(); const getUsers = useCallback(() =\u0026gt; { dispatch(getUsersThunk()); }, [dispatch]); return \u0026lt;UserList users={users} getUsers={getUsers} /\u0026gt;; } connected-react-router #1) Setting #// 1) history.js import { createBrowserHistory } from \u0026#34;history\u0026#34;; const history = createBrowserHistory(); export default history; // 2) redux/store.js import reducers from \u0026#34;./modules/reducers\u0026#34;; import { applyMiddleware, createStore } from \u0026#34;redux\u0026#34;; import { composeWithDevTools } from \u0026#34;redux-devtools-extension\u0026#34;; import history from \u0026#34;../history\u0026#34;; import { routerMiddleware } from \u0026#34;connected-react-router\u0026#34;; const sagaMiddleware = createSagaMiddleware(); const store = createStore( reducers, composeWithDevTools(applyMiddleware(routerMiddleware(history))) ); export default store; // 3) redux/modules/reducers.js import { combineReducers } from \u0026#34;redux\u0026#34;; import history from \u0026#34;../../history\u0026#34;; import { connectRouter } from \u0026#34;connected-react-router\u0026#34;; ... const reducers = combineReducers({ router: connectRouter(history), ... }); export default reducers; // 4) index.js ... import store from \u0026#34;./redux/store\u0026#34;; import { Provider } from \u0026#34;react-redux\u0026#34;; import history from \u0026#34;./history\u0026#34;; import { ConnectedRouter } from \u0026#34;connected-react-router\u0026#34;; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;Provider store={store}\u0026gt; \u0026lt;ConnectedRouter history={history}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/ConnectedRouter\u0026gt; \u0026lt;/Provider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;) ); 2) Usage #// pages/home.jsx import { useDispatch } from \u0026#34;react-redux\u0026#34;; import { Link } from \u0026#34;react-router-dom\u0026#34;; import { push } from \u0026#34;connected-react-router\u0026#34;; export default function Home() { const dispatch = useDispatch(); return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Home\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;Link to=\u0026#34;/todos\u0026#34;\u0026gt;Todos\u0026lt;/Link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;Link to=\u0026#34;/users\u0026#34;\u0026gt;Users\u0026lt;/Link\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;button onClick={click}\u0026gt;todos로 이동\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); function click() { dispatch(push(\u0026#34;/todos\u0026#34;)); } } ","date":null,"permalink":"/storage/wil/javascript/ex-redux/","section":"Storages","summary":"Redux Basic #1) Action #// 1) Action Type 정의 export const ADD_TODO = \u0026#34;ADD_TODO\u0026#34;; export const COMPLETE_TODO = \u0026#34;COMPLETE_TODO\u0026#34;; export const SHOW_ALL = \u0026#34;SHOW_ALL\u0026#34;; export const SHOW_COMPLETE = \u0026#34;SHOW_COMPLETE\u0026#34;; // 2) Action Creator(Action 객체 반환) 작성 export function addTodo(text) { return { type: ADD_TODO, text }; // { type: ADD_TODO, text: \u0026#34;todo\u0026#34; } } export function completeTodo(index) { return { type: COMPLETE_TODO, index }; // { type: COMPLETE_TODO, index: num } } export function showAll() { return { type: SHOW_ALL }; // { type: SHOW_ALL } } export function showComplete() { return { type: SHOW_COMPLETE }; // { type: SHOW_COMPLETE } 2) Reducer #// 3) reducers 작성 // redux/modules/reducers.","title":"Redux Example"},{"content":" Next.js 및 TS 환경에서 설정 추가 예정 Ref. Redux-toolkit Usage Guide * Redux-toolkit 예시\nInit #npm i @reduxjs/toolkit react-redux 1. Provider #import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import App from \u0026#34;./App\u0026#34;; import store from \u0026#34;./redux/store\u0026#34;; import { Provider } from \u0026#34;react-redux\u0026#34;; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;Provider store={store}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/Provider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;) ); 2. store #/* redux/index */ import { configureStore } from \u0026#34;@reduxjs/toolkit\u0026#34;; import rootReducer from \u0026#34;./modules\u0026#34;; const store = configureStore({ reducer: rootReducer, // middleware: [], // devTools: process.env.NODE_ENV !== \u0026#34;production\u0026#34;, }); export default store; 3. rootReducer #/* redux/modules/index */ import { combineReducers } from \u0026#34;redux\u0026#34;; import reducer from \u0026#34;./reducer\u0026#34;; const rootReducer = combineReducers({ reducer, }); export default rootReducer; Reducer #1. createSlice #/* redux/modules/reducer */ import { createSlice } from \u0026#34;@reduxjs/toolkit\u0026#34;; const reducerSlice = createSlice({ name: \u0026#34;reducer\u0026#34;, initialState: initial_state, reducers: { actionCreator: (state, action) =\u0026gt; { // action.payload는 action_creator의 params // state 변경은 mutable, immutable 둘 다 가능 // state=value로 직접 변경은 안됨 }, }, }); export default reducerSlice.reducer; export const { actionCreator } = reducerSlice.actions; 2) createAsyncThunk^ #import { createAsyncThunk, createSlice } from \u0026#34;@reduxjs/toolkit\u0026#34;; import axios from \u0026#34;axios\u0026#34;; export const asyncActionCreator = createAsyncThunk( \u0026#34;reducer/asyncActionCreator\u0026#34;, async () =\u0026gt; { const response = await axios.get(\u0026#34;\u0026#34;); return response.data; } ); const asyncReducerSlice = createSlice({ name: \u0026#34;asyncReducer\u0026#34;, initialState: { loading: true, error: null, data: initial_data } reducers: {}, extraReducers: (builder) =\u0026gt; { builder.addCase(asyncActionCreator.pending, (state, action) =\u0026gt; { state.loading = true; }); builder.addCase(asyncActionCreator.fulfilled, (state, action) =\u0026gt; { state.loading = false; state.data = action.payload; }); builder.addCase(asyncActionCreator.rejected, (state, action) =\u0026gt; { state.loading = false; state.error = action.error; }); }, }); export default asyncReducerSlice.reducer; Component #1) useSelect #import { useSelector } from \u0026#34;react-redux\u0026#34;; const reducerState = useSelector((store) =\u0026gt; store.reducer); 2) useDispatch #import { useDispatch } from \u0026#34;react-redux\u0026#34;; const dispatch = useDispatch(); dispatch(actionCreator(params)); ","date":null,"permalink":"/what-i-learned/javascript/redux-toolkit/","section":"What I Learneds","summary":"Next.","title":"Redux-toolkit"},{"content":"Provider #import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import App from \u0026#34;./App\u0026#34;; import store from \u0026#34;./redux/store\u0026#34;; import { Provider } from \u0026#34;react-redux\u0026#34;; ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;Provider store={store}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/Provider\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;) ); store #/* redux/store.js */ import { configureStore } from \u0026#34;@reduxjs/toolkit\u0026#34;; import rootReducer from \u0026#34;./modules/rootReducer\u0026#34;; const store = configureStore({ reducer: rootReducer, // middleware: [...getDefaultMiddleware()] // devTools: process.env.NODE_ENV !== \u0026#34;production\u0026#34;, }); rootReducer #/* redux/modules/rootReducer.js */ import { combineReducers } from \u0026#34;redux\u0026#34;; import todos from \u0026#34;./todos\u0026#34;; import userList from \u0026#34;./userList\u0026#34;; const rootReducer = combineReducers({ todos, userList, }); export default rootReducer; Reducer #/* redux/modules/todos.js */ import { createSlice } from \u0026#34;@reduxjs/toolkit\u0026#34;; const todosSlice = createSlice({ name: \u0026#34;todos\u0026#34;, initialState: [], reducers: { addTodo: (state, action) =\u0026gt; { state.push({ text: action.payload.text, key: action.payload.key, }); }, deleteTodo: (state, action) =\u0026gt; { const nextState = state.filter((todo) =\u0026gt; todo.key !== action.payload); return nextState; }, }, }); export default todosSlice.reducer; export const { addTodo, deleteTodo } = todosSlice.actions; /* redux/modules/userList.js */ import { createAsyncThunk, createSlice } from \u0026#34;@reduxjs/toolkit\u0026#34;; import axios from \u0026#34;axios\u0026#34;; export const fetchUserList = createAsyncThunk( \u0026#34;users/fetchUserList\u0026#34;, async () =\u0026gt; { const response = await axios.get(\u0026#34;https://api.github.com/users\u0026#34;); return response.data; } ); const userListSlice = createSlice({ name: \u0026#34;userList\u0026#34;, initialState: { loading: true, error: null, data: [] }, reducers: {}, extraReducers: (builder) =\u0026gt; { builder.addCase(fetchUserList.pending, (state, action) =\u0026gt; { state.loading = true; }); builder.addCase(fetchUserList.fulfilled, (state, action) =\u0026gt; { state.loading = false; state.data = action.payload; }); builder.addCase(fetchUserList.rejected, (state, action) =\u0026gt; { state.loading = false; state.error = action.error; }); }, }); export default userListSlice.reducer; Component #/* components/Todos.jsx */ import { useCallback, useRef } from \u0026#34;react\u0026#34;; import { useDispatch } from \u0026#34;react-redux\u0026#34;; import { addTodo } from \u0026#34;../redux/modules/todos\u0026#34;; import { nanoid } from \u0026#34;nanoid\u0026#34;; export default function TodoForm() { const inputRef = useRef(); const dispatch = useDispatch(); const add = (todo) =\u0026gt; { dispatch(addTodo(todo)); }; return ( \u0026lt;div\u0026gt; \u0026lt;input ref={inputRef} /\u0026gt; \u0026lt;button onClick={() =\u0026gt; add({ text: inputRef.current.value, key: nanoid(), }) } \u0026gt; add \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } /* components/TodoList.jsx */ import { useCallback, memo } from \u0026#34;react\u0026#34;; import { useSelector, useDispatch } from \u0026#34;react-redux\u0026#34;; import { deleteTodo as deleteTodoAction } from \u0026#34;../redux/modules/todos\u0026#34;; export default memo(function TodoList() { const todos = useSelector((state) =\u0026gt; state.todos); const dispatch = useDispatch(); const deleteTodo = (key) =\u0026gt; { dispatch(deleteTodoAction(key)); }; return ( \u0026lt;ul\u0026gt; {todos.map((todo) =\u0026gt; { return ( \u0026lt;li key={todo.key} onClick={() =\u0026gt; deleteTodo(todo.key)}\u0026gt; {todo.text} \u0026lt;/li\u0026gt; ); })} \u0026lt;/ul\u0026gt; ); }); /* components/UserList.jsx */ import { useCallback, useEffect, memo } from \u0026#34;react\u0026#34;; import { useSelector, useDispatch } from \u0026#34;react-redux\u0026#34;; import { fetchUsers } from \u0026#34;../redux/modules/users\u0026#34;; export default memo(function UserList() { const users = useSelector((state) =\u0026gt; state.users.data); const dispatch = useDispatch(); useEffect(() =\u0026gt; { dispatch(fetchUsers()); }, [dispatch]); if (users.length === 0) { return \u0026lt;p\u0026gt;현재 유저 정보 없음\u0026lt;/p\u0026gt;; } return ( \u0026lt;ol\u0026gt; {users.map((user) =\u0026gt; ( \u0026lt;li key={user.id}\u0026gt;{user.login}\u0026lt;/li\u0026gt; ))} \u0026lt;/ol\u0026gt; ); }); ","date":null,"permalink":"/storage/wil/javascript/ex-redux-toolkit/","section":"Storages","summary":"Provider #import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import App from \u0026#34;.","title":"Redux-toolkit Example"},{"content":"","date":null,"permalink":"/tags/regex/","section":"Tags","summary":"","title":"RegEx"},{"content":"Ref. https://regexr.com\n1. 표현 방식 # Expression Method new RegExp(\u0026ldquo;표현\u0026rdquo;, \u0026ldquo;옵션\u0026rdquo;) 생성자 함수 방식 /표현/옵션 리터럴 방식 2. 테스트 # Expression Details 정규식.test(문자열) 일치 여부 반환 3. 플래그(옵션) # Flag Details g 전역 검색 (global) i 대소문자 구분 않고 검색 (ignore case) m 다중행 검색 (multi line) 4. 패턴 #Anchors \u0026amp; Escape\n패턴 설명 ^ 입력의 시작 부분, 다중행 검색에선 각 줄의 시작 부분 $ 입력의 끝 부분, 다중행 검색에선 각 줄의 끝 부분 \\b 공백과 개행문자 \\B 공백과 개행문자가 아님 \\ \\일반 문자는 특별한 문자로 변경\\특수 문자는 일반 문자로 변경 Character classes\n패턴 설명 . 개행 문자를 제외한 모든 단일 문자 (공백, 특수문자 포함) [xyz] x 또는 y 또는 z [^xyz] x 와 y와 z를 제외한 문자 [a-z] a부터 z 사이의 문자 구간 (영어 소문자) [A-Z] A부터 Z 사이의 문자 구간 (영어 대문자) [0-9] 0부터 9 사이의 문자 구간 (숫자) [가-힣] 가부터 힣 사이의 문자 구간 (한글) \\w 63개 문자 (대소영문 52개+숫자 10개+_) = [A-Za-z0-9_] \\W 63개 문자가 아님 =[^a-za-z0-9_] \\d 숫자 = [0-9] \\D 숫자가 아님 =[^0-9] \\s 공백 (Space, Tap 등) \\S 공백이 아님 Quantifiers \u0026amp; Alternations\n패턴 설명 {n} 앞의 표현식이 n회 연속으로 반복될 때만 대응 {n,} 앞의 표현식이 n회 이상 연속으로 반복될 때만 대응 {n,m} 앞의 표현식이 n회 이상, m회 이하 연속으로 반복될 때만 대응 * 앞의 표현식이 0회 이상 연속으로 반복될 때만 대응 = {0,} + 앞의 표현식이 1회 이상 연속으로 반복될 때만 대응 = {1,} ? 1. 앞의 표현식이 0 또는 1회 등장할 때만 대응 = {0, 1}2. 앞의 수량자({}, *, +, ?)를 가능한 한 적은 수의 문자와 일치ㅤ*수량자는 원래 가능한 한 많은 수의 문자와 일치 | or Lookaround\n패턴 설명 (?=xyz) 앞의 표현식 다음에 xyz가 있을 때만 대응 (?!xyz) 앞의 표현식 다음에 xyz가 없을 때만 대응 (?\u0026lt;=xyz) 뒤의 표현식 전에 xyz가 있을 때만 대응 (?\u0026lt;!xyz) 뒤의 표현식 전에 xyz가 없을 때만 대응 Groups \u0026amp; References\n패턴 설명 (xyz) 괄호 안의 표현식을 하나의 단위로 취급(기억o)\n*g옵션이 없을 때, match시 배열에 포함 (?:xyz) 괄호 안의 표현식을 하나의 단위로 취급(기억x) \\n n번째에 ()로 묶여서 기억된 문자열 ","date":null,"permalink":"/what-i-learned/etc/regex/","section":"What I Learneds","summary":"Ref. https://regexr.","title":"Regular Expression"},{"content":"","date":null,"permalink":"/tags/scss/","section":"Tags","summary":"","title":"SCSS"},{"content":" Sassy CSS; CSS preprocessor\n변수(유효범위, 재할당) - $ #.container { $size: 300px; top: $size; // 300px .item { $size: 100px; width: $size; //100px } left: $size; // 100px } 리터럴 템퍼링 - #{} #$size: 100px; .box-#{$size} { width: $size; } 선택자 중첩(Nesting) #.ancestor { \u0026gt; .children { // 자식 선택자 } .descendent { // 자손 선택자 } } 상위 선택자 참조 - \u0026amp; #.btn { \u0026amp;:hover { } \u0026amp;-small { } } 재사용 - @mixin, @include, @content #@mixin center { display: flex; justify-content: center; align-items: center; @content; } @mixin box($w: 100px, $h: 100px, $color: royalblue) { width: $w; height: $h; background-color: $color; } .container { @include center { margin: auto; } @include box(200px, 200px, orange); .item { @include box(); } } .box { @include box($color: tomato); } 색상 내장 함수 #.box { $color: royalblue; \u0026amp;.built-in-1 { background-color: rgba($color, 0.5); // 투명도 } \u0026amp;:hover { background-color: mix($color, red); // 섞기 } \u0026amp;.built-in-2 { background-color: lighten($color, 10%); // 밝게 } \u0026amp;.built-in-3 { background-color: darken($color, 10%); // 어둡게 } \u0026amp;.built-in-4 { background-color: saturate($color, 50%); // 채도 up } \u0026amp;.built-in-5 { background-color: desaturate($color, 50%); // 채도 down } } 함수 #@function ratio($size, $ratio) { @return $size * $ratio; } .box { $width: 300px; width: $width; height: ratio($width, (9/16)); } 반복문 - @for $i from \u0026hellip; through \u0026hellip; / $map, @each #@for $i from 1 through 10 { .item:nth-child(#{$i}) { width: 100px \\* $i; } } $map: ( o: orange, r: royalblue, y: yellow, ); @each $k, $v in $map { .box-#{$k} { color: $v; } } 단축 속성 #.box { margin: { top: 10px; left: 20px; } } 산술 연산 # +, -, \\*, % 는 정상적으로 동작 / 는 CSS에서 단축 속성 구분에 쓰여서 연산을 위해서는 괄호로 묶어야 함 연산은 산술 규칙을 따르며, 같은 단위만 연산 가능 calc() 는 다른 단위의 연산 시 사용 가져오기 #@import url(\u0026#34;./sub.scss\u0026#34;); @import \u0026#34;./sub.scss\u0026#34;; @import \u0026#34;./sub\u0026#34;, \u0026#34;./sub2\u0026#34;; ","date":null,"permalink":"/what-i-learned/html-css/scss/","section":"What I Learneds","summary":"Sassy CSS; CSS preprocessor","title":"SCSS"},{"content":"","date":null,"permalink":"/storage/","section":"Storages","summary":"","title":"Storages"},{"content":"Unknown #declare const maybe: unknown; if (typeof maybe === \u0026#34;boolean\u0026#34;) { const aBoolean: boolean = maybe; } if (typeof maybe === \u0026#34;string\u0026#34;) { const aString: string = maybe; } Getter \u0026amp; Setter #class Person { constructor(private _name: string, private _age: number) {} // 추가로 뭔가 할 수 있음 /* Getter */ get name() { return `Mr.${this._name}`; } get age() { return `${this._age}세`; } /* Setter */ set age(age: number) { this._age = age; } } const yuchan: Person = new Person(\u0026#34;Yuchan\u0026#34;, 27); console.log(yuchan.name); // -\u0026gt; Mr.Yuchan console.log(yuchan.age); // -\u0026gt; 27세 yuchan.name = \u0026#34;Yuchan\u0026#34;; // -\u0026gt; error (Setter가 없어서) yuchan.age = 28; console.log(yuchan.age); // -\u0026gt; 28세 Generic #// 1 - 배열의 요소 타입 function getLen\u0026lt;T\u0026gt;(arr: T[]): number { return arr.length; } getLen([\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]); getLen([1, 2, 3]); getLen\u0026lt;boolean\u0026gt;([true, true, false]); // 2 - 객체의 value 타입 interface Mobile\u0026lt;T\u0026gt; { company: string; price: number; option: T; } const Iphone: Mobile\u0026lt;object\u0026gt; = { company: \u0026#34;Apple\u0026#34;, price: 123, option: { color: \u0026#34;red\u0026#34;, }, }; const Galaxy: Mobile\u0026lt;null\u0026gt; = { company: \u0026#34;Samsung\u0026#34;, price: 123, option: null, }; // 3 상속 interface User { name: string; age: number; } interface Mobile { company: string; price: number; } ``; const user: User = { name: \u0026#34;yuchan\u0026#34;, age: 28 }; const phone: Mobile = { company: \u0026#34;Iphone\u0026#34;, price: 123 }; function findName\u0026lt;T extends { name: string }\u0026gt;(data: T): string { return data.name; } interface User { name: string; age: number; } interface Mobile { company: string; price: number; } ``; const user: User = { name: \u0026#34;yuchan\u0026#34;, age: 28 }; const phone: Mobile = { company: \u0026#34;Iphone\u0026#34;, price: 123 }; function findName\u0026lt;T extends { name: string }\u0026gt;(data: T): string { return data.name; } findName(user); findName(phone); // error //4 /* 일부는 required 일부는 optional로 받도록 설정 */ interface Person { name: string; age: number; gender: string; } type PickPerson = Pick\u0026lt;Person, \u0026#34;name\u0026#34; | \u0026#34;age\u0026#34;\u0026gt; \u0026amp; Pick\u0026lt;Partial\u0026lt;Person\u0026gt;, \u0026#34;gender\u0026#34;\u0026gt;; const pickPerson: PickPerson = { name: \u0026#34;Jade\u0026#34;, // required age: 29, // required gender: \u0026#34;male\u0026#34;, // optional }; as const #let hello = \u0026#34;world\u0026#34;; // hello: string const hello = \u0026#34;world\u0026#34;; // hello: \u0026#34;world\u0026#34; let hello = \u0026#34;world\u0026#34; as const; // hello: \u0026#34;world\u0026#34; ","date":null,"permalink":"/storage/wil/javascript/ex-typescript/","section":"Storages","summary":"Unknown #declare const maybe: unknown; if (typeof maybe === \u0026#34;boolean\u0026#34;) { const aBoolean: boolean = maybe; } if (typeof maybe === \u0026#34;string\u0026#34;) { const aString: string = maybe; } Getter \u0026amp; Setter #class Person { constructor(private _name: string, private _age: number) {} // 추가로 뭔가 할 수 있음 /* Getter */ get name() { return `Mr.","title":"TS Example"},{"content":"Ref. TypeScript Cheat sheets\nTS Init #1. 설치 및 사용 # Command Details npm i -D typescript typescript 설치 npx tsc \u0026ndash;init ^ tsconfig.json 생성 npx tsc ([파일명]) (해당 파일) 컴파일 npx tsc -w 자동 컴파일 모드 2. tsconfig.json^ # Property Details \u0026ldquo;compileOnSave\u0026rdquo; 저장 후 자동 컴파일 \u0026ldquo;extends\u0026rdquo; 컴파일러 옵션 상속 경로 \u0026ldquo;files\u0026rdquo; 컴파일 할 것들 배열 (\u0026gt;exclude) \u0026ldquo;include\u0026rdquo; 컴파일 할 것들 배열*확장자를 선언하지 않으면, .ts, .tsx, .d.ts만 포함 \u0026ldquo;exclude\u0026rdquo; include에 포함된 것들 중 제외할 것들 배열*설정하지 않으면, 4개 경로 자동 제외(node_modules, bower_components,jspm_packages, outDir) *\u0026ldquo;\u0026ldquo;를 입력하면 최상위 프로퍼티 목록 확인 가능*files, include, exclude를 셋다 설정하지 않으면 모든 관련 파일 컴파일\n\u0026ldquo;compileOptions\u0026rdquo; Details \u0026ldquo;target\u0026rdquo; 빌드 결과물의 버전을 지정*화살표 함수, 클래스는 es6 이상 \u0026ldquo;outDir\u0026rdquo; 컴파일 된 결과물을 모을 폴더 지정 (Ex. ./dist/) \u0026ldquo;rootDir\u0026rdquo; 컴파일 할 소스를 모을 폴더 지정 (Ex. ./src/) \u0026ldquo;strict\u0026rdquo; 엄격 모드 TS Data Type #data: valueType; //Type annotation 1. Primitive Type # : string : number : boolean : symbol (es6) ^ : null : undefined 2. Non-Primitive Type # object literal type : { key1: Type1; key2: Type2; \u0026hellip; } array : 타입[] : (타입1 | 타입2 | \u0026hellip;)[] tuple : [타입1, 타입2, \u0026hellip;] : any : unknown⋯ 타입을 확정한 뒤 할당 및 사용 가능 : never 항상 오류를 출력하거나, 절대 값을 반환하지 않는 함수의 리턴 타입 모든 타입의 서브타입이며 어떤 타입도 할당 불가 : void 값을 반환하지 않는 함수의 리턴 타입 undefined만 할당 가능 3. Union Type # : 타입1 | 타입2 | \u0026hellip; 4. Interaction Type # : 타입1 \u0026amp; 타입2 \u0026amp; \u0026hellip; TS Custom Type #1. Type alias #type 에일리아스 = union | interaction | tuple; 2. Interface #/* 인터페이스 */ interface 인터페이스 { key: valueType method(parameter: valueType, ...): returnType } /* 인터페이스 상속 */ interface 하위_인터페이스 extends 상위_인터페이스, ... { } /* 인터페이스 -\u0026gt; 클래스 */ class 클래스 implements 인터페이스 { } *인터페이스는 중복 작성했을 때, 자동으로 병합됨 (Declaration Merging)\n3. Class #/* class 클래스 { key: valueType // 초기값 필요(but, \u0026#34;!:\u0026#34;면 필요 X) constructor(parameter: valueType, ...) { this.key = parameter } } */ // this로 한 번 더 할당할 필요 X class 클래스 { constructor(public|private|protected parameter: valueType, ...) { } } class 하위_클래스 extends 상위_클래스 { constructor(public|private|protected parameter: valueType, ...) { super(/* 상위_클래스_parameter */) } } Access Modifier Details public 외부에서도 접근 가능 (def) private 내부에서만 접근 가능*관습적으로 앞에 _사용 protected 내부와 하위 클래스에서만 접근 가능 static 클래스 자체에서만 호출 가능*인스턴스에서 호출 불가능 abstract 추상 메서드는 정의만 되어있을 뿐 구현되어 있지 않음추상 클래스는 특정 클래스의 상속 대상이 되는 클래스상속하는 클래스는 반듯이 정의된 추상 메서드를 구현해야 함추상 클레스는 인스턴스 생성 불가능 readonly 초깃값만 할당 가능 *getter \u0026amp; setter 예제\n4. Generic^ ⋯ # Questions Answers 제네릭이란? 일종의 타입 변수 형태는? \u0026lt;Type\u0026gt; 상속은? \u0026lt;Type extends Super_Type\u0026gt; Utility Types Details Partial\u0026lt;Type\u0026gt; Type의 모든 프로퍼티를 선택으로 설정한 타입 생성 Required\u0026lt;Type\u0026gt; Type의 모든 프로퍼티를 필수로 설정한 타입 생성 Readonly\u0026lt;Type\u0026gt; Type의 모든 프로퍼티를 읽기 전용으로 설정한 타입 생성 Record\u0026lt;Keys, Values\u0026gt; 키의 타입은 Keys, 값의 타입은 Values인 타입 생성 Pick\u0026lt;Type, Keys\u0026gt; Type의 프로퍼티 중 Keys만 선택한 타입 생성 Omit\u0026lt;Type, Keys\u0026gt; Type의 프로퍼티 중 Keys만 제외한 타입 생성 Exclude\u0026lt;Type1, Type2\u0026gt; Type1의 유니온 멤버 중 Type2의 유니온 멤버만 제외한 타입 생성 NonNullable\u0026lt;Type\u0026gt; Type에서 null과 undefined를 제외한 타입 생성 TS Etc #1) Index Signatures\n[index: string]: valueType 이름, 존재 여부 상관없는 key들의 value의 타입 지정 2) Optional Type\n?: 해당 요소가 있어도 되고 없어도 됨 3) Non-Null Assertion Operator^\n!. 해당 피연산자가 null, undefined가 아니라고 단언 4) readonly \u0026hellip;\n해당 요소에 초기값만 할당 가능 5) keyof 타입\n해당 타입의 모든 키값을 union 멤버로 반환 6)Type Assertion\n\u0026hellip; as 타입 \u0026hellip; as const (readonly) ⋯ ","date":null,"permalink":"/what-i-learned/javascript/typescript/","section":"What I Learneds","summary":"Ref. TypeScript Cheat sheets","title":"TypeScript"},{"content":"","date":null,"permalink":"/what-i-learned/","section":"What I Learneds","summary":"","title":"What I Learneds"}]